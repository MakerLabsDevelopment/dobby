{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadTransaction = void 0;\n\nconst threads_pb_1 = require(\"@textile/threads-client-grpc/threads_pb\");\n\nconst Transaction_1 = require(\"./Transaction\");\n\nconst decoder = new TextDecoder();\n/**\n * ReadTransaction performs a read-only bulk transaction on the underlying store.\n * {@inheritDoc @textile/threads-client#Transaction}\n * @example\n * Create a new entry and check for it within a transaction\n * ```typescript\n * import {Client, ThreadID} from '@textile/threads'\n *\n * interface Astronaut {\n *   name: string\n *   missions: number\n *   _id: string\n * }\n *\n * async function createAndCheck (client: Client, threadID: ThreadID) {\n *   const buzz: Astronaut = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *\n *   const ids = await client.create(threadID, 'astronauts', [buzz])\n *   // Create and start transaction\n *   const t = client.readTransaction(threadID, 'astronauts')\n *   await t.start()\n *   const has = await t.has(ids)\n *   console.log(has) // true\n *   await t.end() // Finish\n * }\n * ```\n */\n\nclass ReadTransaction extends Transaction_1.Transaction {\n  constructor(context, client, threadID, modelName) {\n    super(client, threadID, modelName);\n    this.context = context;\n    this.client = client;\n    this.threadID = threadID;\n    this.modelName = modelName;\n  }\n  /**\n   * start begins the transaction. All operations between start and end will be applied as a single transaction upon a call to end.\n   */\n\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const startReq = new threads_pb_1.StartTransactionRequest();\n      startReq.setDbid(this.threadID.toBytes());\n      startReq.setCollectionname(this.modelName);\n      const req = new threads_pb_1.ReadTransactionRequest();\n      req.setStarttransactionrequest(startReq);\n      const metadata = JSON.parse(JSON.stringify(this.context));\n      this.client.start(metadata);\n      this.client.send(req);\n    });\n  }\n  /**\n   * has checks whether a given instance exists in the given store.\n   * @param IDs An array of instance ids to check for.\n   */\n\n\n  has(IDs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const hasReq = new threads_pb_1.HasRequest();\n        hasReq.setInstanceidsList(IDs);\n        const req = new threads_pb_1.ReadTransactionRequest();\n        req.setHasrequest(hasReq);\n        this.client.onMessage(message => {\n          const reply = message.getHasreply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          resolve(reply && reply.getExists());\n        });\n        this.setReject(reject);\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * find queries the store for entities matching the given query parameters. See Query for options.\n   * @param query The object that describes the query. See Query for options. Alternatively, see QueryJSON for the basic interface.\n   */\n\n\n  find(query) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const findReq = new threads_pb_1.FindRequest();\n        findReq.setQueryjson(Buffer.from(JSON.stringify(query)));\n        const req = new threads_pb_1.ReadTransactionRequest();\n        req.setFindrequest(findReq);\n        this.client.onMessage(message => {\n          const reply = message.getFindreply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          if (reply === undefined) {\n            resolve();\n          } else {\n            // TODO: Clean this up to avoid using Buffer\n            const ret = {\n              instancesList: reply.toObject().instancesList.map(instance => JSON.parse(Buffer.from(instance, \"base64\").toString()))\n            };\n            resolve(ret);\n          }\n        });\n        this.setReject(reject);\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * findByID queries the store for the id of an instance.\n   * @param ID The id of the instance to search for.\n   */\n\n\n  findByID(ID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const findReq = new threads_pb_1.FindByIDRequest();\n        findReq.setInstanceid(ID);\n        const req = new threads_pb_1.ReadTransactionRequest();\n        req.setFindbyidrequest(findReq);\n        this.client.onMessage(message => {\n          const reply = message.getFindbyidreply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          if (reply === undefined) {\n            resolve();\n          } else {\n            const ret = {\n              instance: JSON.parse(decoder.decode(reply.getInstance_asU8()))\n            };\n            resolve(ret);\n          }\n        });\n        this.setReject(reject);\n        this.client.send(req);\n      });\n    });\n  }\n\n}\n\nexports.ReadTransaction = ReadTransaction;","map":{"version":3,"sources":["../../src/models/ReadTransaction.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module @textile/threads-client/models\n */\nimport { grpc } from \"@improbable-eng/grpc-web\"\nimport { ContextInterface } from \"@textile/context\"\nimport {\n  FindByIDRequest,\n  FindRequest,\n  HasRequest,\n  ReadTransactionReply,\n  ReadTransactionRequest,\n  StartTransactionRequest,\n} from \"@textile/threads-client-grpc/threads_pb\"\nimport { ThreadID } from \"@textile/threads-id\"\nimport { Instance, InstanceList, QueryJSON } from \"./query\"\nimport { Transaction } from \"./Transaction\"\n\nconst decoder = new TextDecoder()\n\n/**\n * ReadTransaction performs a read-only bulk transaction on the underlying store.\n * {@inheritDoc @textile/threads-client#Transaction}\n * @example\n * Create a new entry and check for it within a transaction\n * ```typescript\n * import {Client, ThreadID} from '@textile/threads'\n *\n * interface Astronaut {\n *   name: string\n *   missions: number\n *   _id: string\n * }\n *\n * async function createAndCheck (client: Client, threadID: ThreadID) {\n *   const buzz: Astronaut = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *\n *   const ids = await client.create(threadID, 'astronauts', [buzz])\n *   // Create and start transaction\n *   const t = client.readTransaction(threadID, 'astronauts')\n *   await t.start()\n *   const has = await t.has(ids)\n *   console.log(has) // true\n *   await t.end() // Finish\n * }\n * ```\n */\nexport class ReadTransaction extends Transaction<\n  ReadTransactionRequest,\n  ReadTransactionReply\n> {\n  constructor(\n    protected readonly context: ContextInterface,\n    protected readonly client: grpc.Client<\n      ReadTransactionRequest,\n      ReadTransactionReply\n    >,\n    protected readonly threadID: ThreadID,\n    protected readonly modelName: string\n  ) {\n    super(client, threadID, modelName)\n  }\n  /**\n   * start begins the transaction. All operations between start and end will be applied as a single transaction upon a call to end.\n   */\n  public async start(): Promise<void> {\n    const startReq = new StartTransactionRequest()\n    startReq.setDbid(this.threadID.toBytes())\n    startReq.setCollectionname(this.modelName)\n    const req = new ReadTransactionRequest()\n    req.setStarttransactionrequest(startReq)\n    const metadata = JSON.parse(JSON.stringify(this.context))\n    this.client.start(metadata)\n    this.client.send(req)\n  }\n\n  /**\n   * has checks whether a given instance exists in the given store.\n   * @param IDs An array of instance ids to check for.\n   */\n  public async has(IDs: string[]): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      const hasReq = new HasRequest()\n      hasReq.setInstanceidsList(IDs)\n      const req = new ReadTransactionRequest()\n      req.setHasrequest(hasReq)\n      this.client.onMessage((message: ReadTransactionReply) => {\n        const reply = message.getHasreply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        resolve(reply && reply.getExists())\n      })\n      this.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * find queries the store for entities matching the given query parameters. See Query for options.\n   * @param query The object that describes the query. See Query for options. Alternatively, see QueryJSON for the basic interface.\n   */\n  public async find<T = any>(query: QueryJSON): Promise<InstanceList<T>> {\n    return new Promise<InstanceList<T>>((resolve, reject) => {\n      const findReq = new FindRequest()\n      findReq.setQueryjson(Buffer.from(JSON.stringify(query)))\n      const req = new ReadTransactionRequest()\n      req.setFindrequest(findReq)\n      this.client.onMessage((message: ReadTransactionReply) => {\n        const reply = message.getFindreply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        if (reply === undefined) {\n          resolve()\n        } else {\n          // TODO: Clean this up to avoid using Buffer\n          const ret: InstanceList<T> = {\n            instancesList: reply\n              .toObject()\n              .instancesList.map((instance) =>\n                JSON.parse(Buffer.from(instance as string, \"base64\").toString())\n              ),\n          }\n          resolve(ret)\n        }\n      })\n      this.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * findByID queries the store for the id of an instance.\n   * @param ID The id of the instance to search for.\n   */\n  public async findByID<T = any>(ID: string): Promise<Instance<T>> {\n    return new Promise<Instance<T>>((resolve, reject) => {\n      const findReq = new FindByIDRequest()\n      findReq.setInstanceid(ID)\n      const req = new ReadTransactionRequest()\n      req.setFindbyidrequest(findReq)\n      this.client.onMessage((message: ReadTransactionReply) => {\n        const reply = message.getFindbyidreply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        if (reply === undefined) {\n          resolve()\n        } else {\n          const ret: Instance<T> = {\n            instance: JSON.parse(decoder.decode(reply.getInstance_asU8())),\n          }\n          resolve(ret)\n        }\n      })\n      this.setReject(reject)\n      this.client.send(req)\n    })\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}