{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PeerId = exports.LogID = void 0;\n\nconst threads_crypto_1 = require(\"@textile/threads-crypto\");\n\nconst cids_1 = __importDefault(require(\"cids\"));\n\nconst multibase_1 = __importDefault(require(\"multibase\"));\n\nfunction areEqual(a, b) {\n  if (a.byteLength !== b.byteLength) return false;\n  return a.every((val, i) => val === b[i]);\n}\n\nconst computeDigest = pubKey => {\n  if (pubKey.bytes.length <= 42) {\n    return threads_crypto_1.multihash(pubKey.bytes, 0x00);\n  } else {\n    return pubKey.hash();\n  }\n};\n\nconst computeLogId = (privKey, pubKey) => __awaiter(void 0, void 0, void 0, function* () {\n  const key = pubKey !== null && pubKey !== void 0 ? pubKey : privKey === null || privKey === void 0 ? void 0 : privKey.public;\n  if (key === undefined) throw new Error(\"Valid public or private key required\");\n  const digest = yield computeDigest(key); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  return new LogID(digest, privKey, pubKey);\n});\n/**\n * LogID represents a simplified PeerID used for tracking thread logs.\n * It is a minimal implementation of PeerID useful mostly for marshaling and unmarshaling.\n */\n\n\nclass LogID {\n  constructor(id, privKey, pubKey = privKey === null || privKey === void 0 ? void 0 : privKey.public) {\n    this.id = id;\n    this.privKey = privKey;\n    this.pubKey = pubKey;\n\n    if (!(id instanceof Uint8Array)) {\n      throw new Error(\"invalid id provided\");\n    }\n\n    if (privKey && pubKey && !areEqual(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error(\"inconsistent arguments\");\n    }\n  }\n\n  static fromRandom(bytesLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const key = yield threads_crypto_1.keys.generateKeyPair(\"Ed25519\", bytesLength);\n      return computeLogId(key);\n    });\n  }\n\n  static fromBytes(buf) {\n    return new LogID(buf);\n  }\n\n  static fromB58String(str) {\n    const cid = new cids_1.default(str); // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n\n    if (!(cid.codec === \"libp2p-key\" || cid.codec === \"dag-pb\")) {\n      throw new Error(\"Invalid multicodec\");\n    }\n\n    return new LogID(cid.multihash);\n  }\n\n  static fromPublicKey(key) {\n    if (key instanceof Uint8Array) {\n      return computeLogId(undefined, threads_crypto_1.keys.unmarshalPublicKey(key));\n    }\n\n    return computeLogId(undefined, key);\n  }\n\n  static fromPrivateKey(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (key instanceof Uint8Array) {\n        return computeLogId(yield threads_crypto_1.keys.unmarshalPrivateKey(key));\n      }\n\n      return computeLogId(key);\n    });\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return threads_crypto_1.keys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return threads_crypto_1.keys.marshalPrivateKey(this.privKey);\n    }\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return multibase_1.default.encode(\"base58btc\", Buffer.from(this.id)).toString().slice(1);\n  } // Return self-describing String representation\n\n\n  toString() {\n    const cid = new cids_1.default(1, \"libp2p-key\", Buffer.from(this.id), \"base32\");\n    return cid.toBaseEncodedString(\"base32\");\n  }\n  /**\n   * Checks the equality of `this` peer against a given LogID.\n   */\n\n\n  equals(id) {\n    if (id instanceof Uint8Array) {\n      return areEqual(this.id, id);\n    } else if (id.id) {\n      return areEqual(this.id, id.id);\n    } else {\n      throw new Error(\"not valid Id\");\n    }\n  }\n  /*\n   * Check if this LogID instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid() {\n    var _a;\n\n    return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && ((_a = this.pubKey) === null || _a === void 0 ? void 0 : _a.bytes) instanceof Uint8Array && areEqual(this.privKey.public.bytes, this.pubKey.bytes));\n  }\n\n}\n\nexports.LogID = LogID;\nexports.PeerId = {\n  BytesToString: buf => new LogID(buf).toB58String()\n};","map":{"version":3,"sources":["../../src/thread/log.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Multiaddr } from \"@textile/multiaddr\"\nimport { keys, multihash, PrivateKey, PublicKey } from \"@textile/threads-crypto\"\nimport CID from \"cids\"\nimport multibase from \"multibase\"\n\nfunction areEqual(a: Uint8Array, b: Uint8Array) {\n  if (a.byteLength !== b.byteLength) return false\n  return a.every((val, i) => val === b[i])\n}\n\nconst computeDigest = (pubKey: PublicKey) => {\n  if (pubKey.bytes.length <= 42) {\n    return multihash(pubKey.bytes, 0x00)\n  } else {\n    return pubKey.hash()\n  }\n}\n\nconst computeLogId = async (privKey?: PrivateKey, pubKey?: PublicKey) => {\n  const key = pubKey ?? privKey?.public\n  if (key === undefined) throw new Error(\"Valid public or private key required\")\n  const digest = await computeDigest(key)\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return new LogID(digest, privKey, pubKey)\n}\n\n/**\n * LogID represents a simplified PeerID used for tracking thread logs.\n * It is a minimal implementation of PeerID useful mostly for marshaling and unmarshaling.\n */\nexport class LogID {\n  constructor(\n    readonly id: Uint8Array,\n    readonly privKey?: PrivateKey,\n    readonly pubKey: PublicKey | undefined = privKey?.public\n  ) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error(\"invalid id provided\")\n    }\n    if (privKey && pubKey && !areEqual(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error(\"inconsistent arguments\")\n    }\n  }\n\n  static async fromRandom(bytesLength?: number): Promise<LogID> {\n    const key = await keys.generateKeyPair(\"Ed25519\", bytesLength)\n    return computeLogId(key)\n  }\n\n  static fromBytes(buf: Uint8Array): LogID {\n    return new LogID(buf)\n  }\n\n  static fromB58String(str: string): LogID {\n    const cid = new CID(str)\n    // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n    if (!(cid.codec === \"libp2p-key\" || cid.codec === \"dag-pb\")) {\n      throw new Error(\"Invalid multicodec\")\n    }\n    return new LogID(cid.multihash)\n  }\n\n  static fromPublicKey(key: PublicKey | Uint8Array): Promise<LogID> {\n    if (key instanceof Uint8Array) {\n      return computeLogId(undefined, keys.unmarshalPublicKey(key))\n    }\n    return computeLogId(undefined, key)\n  }\n\n  static async fromPrivateKey(key: PrivateKey | Uint8Array): Promise<LogID> {\n    if (key instanceof Uint8Array) {\n      return computeLogId(await keys.unmarshalPrivateKey(key))\n    }\n    return computeLogId(key)\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey(): Uint8Array | undefined {\n    if (this.pubKey) {\n      return keys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey(): Uint8Array | undefined {\n    if (this.privKey) {\n      return keys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  toBytes(): Uint8Array {\n    return this.id\n  }\n\n  toB58String(): string {\n    return multibase\n      .encode(\"base58btc\", Buffer.from(this.id))\n      .toString()\n      .slice(1)\n  }\n\n  // Return self-describing String representation\n  toString(): string {\n    const cid = new CID(1, \"libp2p-key\", Buffer.from(this.id), \"base32\")\n    return cid.toBaseEncodedString(\"base32\")\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given LogID.\n   */\n  equals(id: Uint8Array | LogID): boolean {\n    if (id instanceof Uint8Array) {\n      return areEqual(this.id, id)\n    } else if (id.id) {\n      return areEqual(this.id, id.id)\n    } else {\n      throw new Error(\"not valid Id\")\n    }\n  }\n\n  /*\n   * Check if this LogID instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid(): boolean {\n    return Boolean(\n      this.privKey &&\n        this.privKey.public &&\n        this.privKey.public.bytes &&\n        this.pubKey?.bytes instanceof Uint8Array &&\n        areEqual(this.privKey.public.bytes, this.pubKey.bytes)\n    )\n  }\n}\n\nexport const PeerId = {\n  BytesToString: (buf: Uint8Array): string => new LogID(buf).toB58String(),\n}\n\n/**\n * LogInfo holds known info about a log.\n */\nexport interface LogInfo {\n  /**\n   * The logs ID.\n   */\n  id: LogID\n  /**\n   * The logs public key used to check signatures.\n   */\n  pubKey?: PublicKey\n  /**\n   * The logs private key, used to sign content when available.\n   */\n  privKey?: PrivateKey\n  /**\n   * The set of Multiaddrs associated with this log.\n   */\n  addrs?: Set<Multiaddr>\n  /**\n   * The set of heads for this log.\n   */\n  head?: CID\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}