{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst sha = require('multihashing-async/src/sha');\n\nconst protobuf = require('protons');\n\nconst multibase = require('multibase');\n\nconst errcode = require('err-code');\n\nconst crypto = require('./ed25519');\n\nconst pbm = protobuf(require('./keys.proto'));\n\nconst exporter = require('./exporter');\n\nclass Ed25519PublicKey {\n  constructor(key) {\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n\n  async verify(data, sig) {\n    // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return Buffer.from(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array or Buffer containing private key\n  // publicKey - 32 byte Uint8Array or Buffer containing public key\n  constructor(key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n\n  async sign(message) {\n    // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    return new Ed25519PublicKey(this._publicKey);\n  }\n\n  marshal() {\n    return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)]);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return multibase.encode('base58btc', hash).toString().slice(1);\n  }\n  /**\n   * Exports the key into a password protected `format`\n   *\n   * @param {string} password - The password to encrypt the key\n   * @param {string} [format=libp2p-key] - The format in which to export as\n   * @returns {Promise<Buffer>} The encrypted private key\n   */\n\n\n  async export(password, format = 'libp2p-key') {\n    // eslint-disable-line require-await\n    if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password);\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\n\nfunction unmarshalEd25519PrivateKey(bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n    const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n    const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength);\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n  const publicKeyBytes = bytes.slice(crypto.publicKeyLength);\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\n\nfunction unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\n\nasync function generateKeyPair() {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKey();\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nasync function generateKeyPairFromSeed(seed) {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKeyFromSeed(seed);\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nfunction ensureKey(key, length) {\n  key = Uint8Array.from(key || []);\n\n  if (key.length !== length) {\n    throw errcode(new Error(`Key must be a Uint8Array or Buffer of length ${length}, got ${key.length}`), 'ERR_INVALID_KEY_TYPE');\n  }\n\n  return key;\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n};","map":{"version":3,"sources":["/Users/nassarhayat/apps/textiletable/sushitable/node_modules/libp2p-crypto/src/keys/ed25519-class.js"],"names":["Buffer","require","sha","protobuf","multibase","errcode","crypto","pbm","exporter","Ed25519PublicKey","constructor","key","_key","ensureKey","publicKeyLength","verify","data","sig","hashAndVerify","marshal","from","bytes","PublicKey","encode","Type","KeyType","Ed25519","Data","equals","hash","multihashing","Ed25519PrivateKey","publicKey","privateKeyLength","_publicKey","sign","message","hashAndSign","public","concat","PrivateKey","id","toString","slice","export","password","format","Error","unmarshalEd25519PrivateKey","length","privateKeyBytes","publicKeyBytes","unmarshalEd25519PublicKey","generateKeyPair","privateKey","generateKey","generateKeyPairFromSeed","seed","generateKeyFromSeed","Uint8Array","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst sha = require('multihashing-async/src/sha')\nconst protobuf = require('protons')\nconst multibase = require('multibase')\nconst errcode = require('err-code')\n\nconst crypto = require('./ed25519')\nconst pbm = protobuf(require('./keys.proto'))\nconst exporter = require('./exporter')\n\nclass Ed25519PublicKey {\n  constructor (key) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return Buffer.from(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array or Buffer containing private key\n  // publicKey - 32 byte Uint8Array or Buffer containing public key\n  constructor (key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal () {\n    return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)])\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return multibase.encode('base58btc', hash).toString().slice(1)\n  }\n\n  /**\n   * Exports the key into a password protected `format`\n   *\n   * @param {string} password - The password to encrypt the key\n   * @param {string} [format=libp2p-key] - The format in which to export as\n   * @returns {Promise<Buffer>} The encrypted private key\n   */\n  async export (password, format = 'libp2p-key') { // eslint-disable-line require-await\n    if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nfunction unmarshalEd25519PrivateKey (bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.slice(crypto.publicKeyLength)\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nfunction unmarshalEd25519PublicKey (bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nasync function generateKeyPair () {\n  const { privateKey, publicKey } = await crypto.generateKey()\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nasync function generateKeyPairFromSeed (seed) {\n  const { privateKey, publicKey } = await crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nfunction ensureKey (key, length) {\n  key = Uint8Array.from(key || [])\n  if (key.length !== length) {\n    throw errcode(new Error(`Key must be a Uint8Array or Buffer of length ${length}, got ${key.length}`), 'ERR_INVALID_KEY_TYPE')\n  }\n  return key\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n}\n"]},"metadata":{},"sourceType":"script"}