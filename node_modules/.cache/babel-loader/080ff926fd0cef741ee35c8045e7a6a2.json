{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Libp2pCryptoIdentity = exports.Libp2pCryptoPublicKey = exports.privateKeyFromString = exports.privateKeyToString = exports.publicKeyToString = void 0;\n\nconst threads_crypto_1 = require(\"@textile/threads-crypto\");\n\nconst multibase_1 = __importDefault(require(\"multibase\"));\n\nfunction publicKeyToString(key) {\n  return multibase_1.default.encode(\"base32\", threads_crypto_1.keys.marshalPublicKey(key)).toString();\n}\n\nexports.publicKeyToString = publicKeyToString;\n\nfunction privateKeyToString(key) {\n  return multibase_1.default.encode(\"base32\", threads_crypto_1.keys.marshalPrivateKey(key)).toString();\n}\n\nexports.privateKeyToString = privateKeyToString;\n\nfunction privateKeyFromString(str) {\n  return threads_crypto_1.keys.unmarshalPrivateKey(multibase_1.default.decode(str));\n}\n\nexports.privateKeyFromString = privateKeyFromString;\n\nclass Libp2pCryptoPublicKey {\n  constructor(key) {\n    this.key = key;\n  }\n  /**\n   * Verify the given signed data.\n   * @param data The data to verify.\n   * @param sig The signature to verify.\n   */\n\n\n  verify(data, sig) {\n    return this.key.verify(data, sig);\n  }\n  /**\n   * Returns base32 encoded Public key representation.\n   */\n\n\n  toString() {\n    return publicKeyToString(this.key);\n  }\n  /**\n   * The raw bytes of the Public key.\n   */\n\n\n  get bytes() {\n    return this.key.bytes;\n  }\n\n}\n\nexports.Libp2pCryptoPublicKey = Libp2pCryptoPublicKey;\n\nclass Libp2pCryptoIdentity {\n  constructor(key) {\n    this.key = key;\n  }\n  /**\n   * Signs the given data with the Private key,\n   * @param data Data to be signed.\n   */\n\n\n  sign(data) {\n    return this.key.sign(data);\n  }\n  /**\n   * Returns the Public key.\n   */\n\n\n  get public() {\n    return new Libp2pCryptoPublicKey(this.key.public);\n  }\n  /**\n   * Create a random Ed25519 Identity.\n   */\n\n\n  static fromRandom() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Libp2pCryptoIdentity(yield threads_crypto_1.keys.supportedKeys.ed25519.generateKeyPair());\n    });\n  }\n  /**\n   * Returns base32 encoded private key representation.\n   */\n\n\n  toString() {\n    return privateKeyToString(this.key);\n  }\n  /**\n   * Creates key key from base32 encoded string representation\n   * @param str\n   */\n\n\n  static fromString(str) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Libp2pCryptoIdentity(yield privateKeyFromString(str));\n    });\n  }\n\n}\n\nexports.Libp2pCryptoIdentity = Libp2pCryptoIdentity;","map":{"version":3,"sources":["../src/identity.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,gBAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,MAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,SAAgB,iBAAhB,CAAkC,GAAlC,EAAgD;AAC9C,SAAO,WAAA,CAAA,OAAA,CACJ,MADI,CACG,QADH,EACa,gBAAA,CAAA,IAAA,CAAK,gBAAL,CAAsB,GAAtB,CADb,EAEJ,QAFI,EAAP;AAGD;;AAJD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAMA,SAAgB,kBAAhB,CAAmC,GAAnC,EAAkD;AAChD,SAAO,WAAA,CAAA,OAAA,CACJ,MADI,CACG,QADH,EACa,gBAAA,CAAA,IAAA,CAAK,iBAAL,CAAuB,GAAvB,CADb,EAEJ,QAFI,EAAP;AAGD;;AAJD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAMA,SAAgB,oBAAhB,CAAqC,GAArC,EAAgD;AAC9C,SAAO,gBAAA,CAAA,IAAA,CAAK,mBAAL,CAAyB,WAAA,CAAA,OAAA,CAAU,MAAV,CAAiB,GAAjB,CAAzB,CAAP;AACD;;AAFD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAqBA,MAAa,qBAAb,CAAkC;AAChC,EAAA,WAAA,CAAmB,GAAnB,EAAiC;AAAd,SAAA,GAAA,GAAA,GAAA;AAAkB;AAErC;;;;;;;AAKA,EAAA,MAAM,CAAC,IAAD,EAAmB,GAAnB,EAAkC;AACtC,WAAO,KAAK,GAAL,CAAS,MAAT,CAAgB,IAAhB,EAAsB,GAAtB,CAAP;AACD;AAED;;;;;AAGA,EAAA,QAAQ,GAAA;AACN,WAAO,iBAAiB,CAAC,KAAK,GAAN,CAAxB;AACD;AAED;;;;;AAGA,MAAI,KAAJ,GAAS;AACP,WAAO,KAAK,GAAL,CAAS,KAAhB;AACD;;AAxB+B;;AAAlC,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AA2BA,MAAa,oBAAb,CAAiC;AAC/B,EAAA,WAAA,CAAmB,GAAnB,EAAkC;AAAf,SAAA,GAAA,GAAA,GAAA;AAAmB;AAEtC;;;;;;AAIA,EAAA,IAAI,CAAC,IAAD,EAAiB;AACnB,WAAO,KAAK,GAAL,CAAS,IAAT,CAAc,IAAd,CAAP;AACD;AAED;;;;;AAGA,MAAI,MAAJ,GAAU;AACR,WAAO,IAAI,qBAAJ,CAA0B,KAAK,GAAL,CAAS,MAAnC,CAAP;AACD;AACD;;;;;AAGA,SAAa,UAAb,GAAuB;;AACrB,aAAO,IAAI,oBAAJ,CACL,MAAM,gBAAA,CAAA,IAAA,CAAK,aAAL,CAAmB,OAAnB,CAA2B,eAA3B,EADD,CAAP;AAGD,K;AAAA;AAED;;;;;AAGA,EAAA,QAAQ,GAAA;AACN,WAAO,kBAAkB,CAAC,KAAK,GAAN,CAAzB;AACD;AAED;;;;;;AAIA,SAAa,UAAb,CAAwB,GAAxB,EAAmC;;AACjC,aAAO,IAAI,oBAAJ,CAAyB,MAAM,oBAAoB,CAAC,GAAD,CAAnD,CAAP;AACD,K;AAAA;;AAvC8B;;AAAjC,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourcesContent":["import { keys, PrivateKey, PublicKey } from \"@textile/threads-crypto\"\nimport multibase from \"multibase\"\n\nexport function publicKeyToString(key: PublicKey): string {\n  return multibase\n    .encode(\"base32\", keys.marshalPublicKey(key) as Buffer)\n    .toString()\n}\n\nexport function privateKeyToString(key: PrivateKey): string {\n  return multibase\n    .encode(\"base32\", keys.marshalPrivateKey(key) as Buffer)\n    .toString()\n}\n\nexport function privateKeyFromString(str: string): Promise<PrivateKey> {\n  return keys.unmarshalPrivateKey(multibase.decode(str))\n}\n\nexport interface Public {\n  verify(data: Uint8Array, sig: Uint8Array): Promise<boolean>\n  toString(): string\n  bytes: Uint8Array\n}\n\n/**\n * Identity represents an entity capable of signing a message.\n * This is a simple 'private key' interface that must be capable of returning the associated public key for\n * verification. In many cases, this will just be a private key, but callers can use any setup that suits their needs.\n * The interface is currently modeled after @textile/threads-crypto PrivateKeys.\n */\nexport interface Identity {\n  sign(data: Uint8Array): Promise<Uint8Array>\n  public: Public\n}\n\nexport class Libp2pCryptoPublicKey implements Public {\n  constructor(public key: PublicKey) {}\n\n  /**\n   * Verify the given signed data.\n   * @param data The data to verify.\n   * @param sig The signature to verify.\n   */\n  verify(data: Uint8Array, sig: Uint8Array): Promise<boolean> {\n    return this.key.verify(data, sig)\n  }\n\n  /**\n   * Returns base32 encoded Public key representation.\n   */\n  toString(): string {\n    return publicKeyToString(this.key)\n  }\n\n  /**\n   * The raw bytes of the Public key.\n   */\n  get bytes(): Uint8Array {\n    return this.key.bytes\n  }\n}\n\nexport class Libp2pCryptoIdentity implements Identity {\n  constructor(public key: PrivateKey) {}\n\n  /**\n   * Signs the given data with the Private key,\n   * @param data Data to be signed.\n   */\n  sign(data: Uint8Array): Promise<Uint8Array> {\n    return this.key.sign(data)\n  }\n\n  /**\n   * Returns the Public key.\n   */\n  get public(): Libp2pCryptoPublicKey {\n    return new Libp2pCryptoPublicKey(this.key.public)\n  }\n  /**\n   * Create a random Ed25519 Identity.\n   */\n  static async fromRandom(): Promise<Libp2pCryptoIdentity> {\n    return new Libp2pCryptoIdentity(\n      await keys.supportedKeys.ed25519.generateKeyPair()\n    )\n  }\n\n  /**\n   * Returns base32 encoded private key representation.\n   */\n  toString(): string {\n    return privateKeyToString(this.key)\n  }\n\n  /**\n   * Creates key key from base32 encoded string representation\n   * @param str\n   */\n  static async fromString(str: string): Promise<Libp2pCryptoIdentity> {\n    return new Libp2pCryptoIdentity(await privateKeyFromString(str))\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}