{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = exports.Action = exports.maybeLocalAddr = exports.ReadTransaction = exports.WriteTransaction = exports.Where = exports.Query = void 0;\n/**\n * @packageDocumentation\n * @module @textile/threads-client\n */\n\nconst grpc_web_1 = require(\"@improbable-eng/grpc-web\");\n\nconst context_1 = require(\"@textile/context\");\n\nconst grpc_transport_1 = require(\"@textile/grpc-transport\");\n\nconst multiaddr_1 = require(\"@textile/multiaddr\");\n\nconst pb = __importStar(require(\"@textile/threads-client-grpc/threads_pb\"));\n\nconst threads_pb_service_1 = require(\"@textile/threads-client-grpc/threads_pb_service\");\n\nconst threads_core_1 = require(\"@textile/threads-core\");\n\nconst threads_id_1 = require(\"@textile/threads-id\");\n\nconst to_json_schema_1 = __importDefault(require(\"to-json-schema\"));\n\nconst models_1 = require(\"./models\");\n\nObject.defineProperty(exports, \"Query\", {\n  enumerable: true,\n  get: function () {\n    return models_1.Query;\n  }\n});\nObject.defineProperty(exports, \"ReadTransaction\", {\n  enumerable: true,\n  get: function () {\n    return models_1.ReadTransaction;\n  }\n});\nObject.defineProperty(exports, \"Where\", {\n  enumerable: true,\n  get: function () {\n    return models_1.Where;\n  }\n});\nObject.defineProperty(exports, \"WriteTransaction\", {\n  enumerable: true,\n  get: function () {\n    return models_1.WriteTransaction;\n  }\n});\nconst encoder = new TextEncoder();\n\nfunction maybeLocalAddr(ip) {\n  return [\"localhost\", \"\", \"::1\"].includes(ip) || ip.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/) || ip.startsWith(\"192.168.\") || ip.startsWith(\"10.0.\") || ip.endsWith(\".local\");\n}\n\nexports.maybeLocalAddr = maybeLocalAddr;\nvar Action;\n\n(function (Action) {\n  Action[Action[\"CREATE\"] = 0] = \"CREATE\";\n  Action[Action[\"SAVE\"] = 1] = \"SAVE\";\n  Action[Action[\"DELETE\"] = 2] = \"DELETE\";\n})(Action = exports.Action || (exports.Action = {}));\n/**\n * Client is a web-gRPC wrapper client for communicating with a webgRPC-enabled Threads server.\n * This client library can be used to interact with a local or remote Textile gRPC-service\n * It is a wrapper around Textile Thread's 'DB' API, which is defined here:\n * https://github.com/textileio/go-threads/blob/master/api/pb/api.proto.\n *\n * @example\n * ```typescript\n * import {Client, Identity, UserAuth} from '@textile/threads'\n *\n * async function setupDB(auth: UserAuth, identity: Identity) {\n *   // Initialize the client\n *   const client = Client.withUserAuth(auth)\n *\n *   // Connect the user to your API\n *   const userToken = await client.getToken(identity)\n *\n *   // Create a new DB\n *   const threadID = await client.newDB(undefined, 'nasa')\n *\n *   // Create a new Collection from an Object\n *   const buzz = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *   await client.newCollectionFromObject(threadID, 'astronauts', buzz)\n *\n *   // Store the buzz object in the new collection\n *   await client.create(threadID, 'astronauts', [buzz])\n *\n *   return threadID\n * }\n * ```\n */\n\n\nclass Client {\n  /**\n   * Creates a new gRPC client instance for accessing the Textile Threads API.\n   * @param context The context to use for interacting with the APIs. Can be modified later.\n   * @param debug Should we run in debug mode. Defaults to false.\n   */\n  constructor(context = new context_1.Context(), debug = false) {\n    this.context = context;\n    this.serviceHost = context.host;\n    this.rpcOptions = {\n      transport: grpc_transport_1.WebsocketTransport(),\n      debug\n    };\n  }\n  /**\n   * Create a new gRPC client instance from a supplied user auth object.\n   * Assumes all default gRPC settlings. For customization options, use a context object directly.\n   * The callback method will automatically refresh expiring credentials.\n   * @param auth The user auth object or an async callback that returns a user auth object.\n   * @example\n   * ```typescript\n   * import {UserAuth, Client} from '@textile/threads'\n   *\n   * function create (auth: UserAuth) {\n   *   return Client.withUserAuth(auth)\n   * }\n   * ```\n   * @example\n   * ```typescript\n   * import {UserAuth, Client} from '@textile/threads'\n   *\n   * function setCallback (callback: () => Promise<UserAuth>) {\n   *   return Client.withUserAuth(callback)\n   * }\n   * ```\n   */\n\n\n  static withUserAuth(auth, host = context_1.defaultHost, debug = false) {\n    const context = typeof auth === \"object\" ? context_1.Context.fromUserAuth(auth, host) : context_1.Context.fromUserAuthCallback(auth, host);\n    return new Client(context, debug);\n  }\n  /**\n   * Create a new gRPC client instance from a supplied key and secret\n   * @param key The KeyInfo object containing {key: string, secret: string, type: 0}. 0 === User Group Key, 1 === Account Key\n   * @param host The remote gRPC host to connect with. Should be left as default.\n   * @param debug Whether to run in debug mode. Defaults to false.\n   * @example\n   * ```typescript\n   * import {KeyInfo, Client} from '@textile/threads'\n   *\n   * async function create (keyInfo: KeyInfo) {\n   *   return await Client.withKeyInfo(keyInfo)\n   * }\n   * ```\n   */\n\n\n  static withKeyInfo(key, host = context_1.defaultHost, debug = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const context = new context_1.Context(host);\n      yield context.withKeyInfo(key);\n      return new Client(context, debug);\n    });\n  }\n  /**\n   * Create a random user identity.\n   * @deprecated\n   * @remarks\n   * See `PrivateKey`\n   */\n\n\n  static randomIdentity() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return threads_core_1.Libp2pCryptoIdentity.fromRandom();\n    });\n  }\n  /**\n   * Obtain a token per user (identity) for interacting with the remote API.\n   * @param identity A user identity to use for creating records in the database. A random identity\n   * can be created with `Client.randomIdentity(), however, it is not easy/possible to migrate\n   * identities after the fact. Please store or otherwise persist any identity information if\n   * you wish to retrieve user data later, or use an external identity provider.\n   * @param ctx Context object containing web-gRPC headers and settings.\n   * @example\n   * ```typescript\n   * import {Client, Identity} from '@textile/threads'\n   *\n   * async function newToken (client: Client, user: Identity) {\n   *   // Token is added to the client connection at the same time\n   *   const token = await client.getToken(user)\n   *   return token\n   * }\n   * ```\n   */\n\n\n  getToken(identity, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.getTokenChallenge(identity.public.toString(), challenge => __awaiter(this, void 0, void 0, function* () {\n        return identity.sign(challenge);\n      }), ctx);\n    });\n  }\n  /**\n   * Obtain a token per user (identity) for interacting with the remote API.\n   * @param publicKey The public key of a user identity to use for creating records in the database.\n   * A random identity can be created with `Client.randomIdentity(), however, it is not\n   * easy/possible to migrate identities after the fact. Please store or otherwise persist any\n   * identity information if you wish to retrieve user data later, or use an external identity\n   * provider.\n   * @param callback A callback function that takes a `challenge` argument and returns a signed\n   * message using the input challenge and the private key associated with `publicKey`.\n   * @param ctx Context object containing web-gRPC headers and settings.\n   * @remarks `publicKey` must be the corresponding public key of the private key used in `callback`.\n   */\n\n\n  getTokenChallenge(publicKey, callback, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = grpc_web_1.grpc.client(threads_pb_service_1.API.GetToken, {\n        host: this.serviceHost,\n        transport: this.rpcOptions.transport,\n        debug: this.rpcOptions.debug\n      });\n      return new Promise((resolve, reject) => {\n        let token = \"\";\n        client.onMessage(message => __awaiter(this, void 0, void 0, function* () {\n          if (message.hasChallenge()) {\n            const challenge = message.getChallenge_asU8();\n            const signature = yield callback(challenge);\n            const req = new pb.GetTokenRequest();\n            req.setSignature(signature);\n            client.send(req);\n            client.finishSend();\n          } else if (message.hasToken()) {\n            token = message.getToken();\n          }\n        }));\n        client.onEnd((code, message\n        /** trailers: grpc.Metadata */\n        ) => {\n          client.close();\n\n          if (code === grpc_web_1.grpc.Code.OK) {\n            this.context.withToken(token);\n            resolve(token);\n          } else {\n            reject(new Error(message));\n          }\n        });\n        const req = new pb.GetTokenRequest();\n        req.setKey(publicKey);\n        this.context.toMetadata(ctx).then(metadata => {\n          client.start(metadata);\n          client.send(req);\n        });\n      });\n    });\n  }\n  /**\n   * newDB creates a new store on the remote node.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the database\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function createDB (client: Client) {\n   *   const threadID: ThreadID = await client.newDB()\n   *   return threadID\n   * }\n   * ```\n   */\n\n\n  newDB(threadID, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const dbID = threadID !== null && threadID !== void 0 ? threadID : threads_id_1.ThreadID.fromRandom();\n      const req = new pb.NewDBRequest();\n      req.setDbid(dbID.toBytes());\n\n      if (name !== undefined) {\n        this.context.withThreadName(name);\n        req.setName(name);\n      }\n\n      yield this.unary(threads_pb_service_1.API.NewDB, req); // Update our context with out new thread id\n\n      this.context.withThread(dbID.toString());\n      return dbID;\n    });\n  }\n  /**\n   * open creates and enters a new store on the remote node.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the database\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function openDB (client: Client, threadID: ThreadID) {\n   *   await client.open(threadID)\n   * }\n   * ```\n   */\n\n\n  open(threadID, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.ListDBsRequest();\n      const res = yield this.unary(threads_pb_service_1.API.ListDBs, req);\n\n      for (const db of res.dbsList) {\n        const id = threads_id_1.ThreadID.fromBytes(Buffer.from(db.dbid, \"base64\"));\n\n        if (id === threadID) {\n          this.context.withThread(threadID.toString());\n          return;\n        }\n      }\n\n      yield this.newDB(threadID, name);\n      this.context.withThread(threadID.toString());\n    });\n  }\n  /**\n   * Deletes an entire DB.\n   * @param threadID the ID of the database.\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function deleteDB (client: Client, threadID: ThreadID) {\n   *   await client.deleteDB(threadID)\n   *   return\n   * }\n   * ```\n   */\n\n\n  deleteDB(threadID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.DeleteDBRequest();\n      req.setDbid(threadID.toBytes());\n      yield this.unary(threads_pb_service_1.API.DeleteDB, req);\n      return;\n    });\n  }\n  /**\n   * Lists all known DBs.\n   * @remarks this API is blocked on the Hub. Use `listThreads` when importing Client\n   * from `@textile/hub` as an alternative.\n   */\n\n\n  listDBs() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.ListDBsRequest();\n      const res = yield this.unary(threads_pb_service_1.API.ListDBs, req);\n      const dbs = {};\n\n      for (const db of res.dbsList) {\n        const id = threads_id_1.ThreadID.fromBytes(Buffer.from(db.dbid, \"base64\")).toString();\n        dbs[id] = db.info;\n      }\n\n      return dbs;\n    });\n  }\n  /**\n   * Lists the collections in a thread\n   * @param thread the ID of the database\n   */\n\n\n  listCollections(thread) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.ListCollectionsRequest();\n      req.setDbid(thread.toBytes());\n      const resp = yield this.unary(threads_pb_service_1.API.ListCollections, req);\n      return resp.collectionsList;\n    });\n  }\n  /**\n   * newCollection registers a new collection schema under the given name.\n   * The schema must be a valid json-schema.org schema, and can be a JSON string or object.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the collection.\n   * @param schema The actual json-schema.org compatible schema object.\n   * @param indexes A set of index definitions for indexing instance fields.\n   *\n   * @example\n   * Change a new astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const astronauts = {\n   *   title: \"Astronauts\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: {\n   *       type: \"string\",\n   *       description: \"The instance's id.\",\n   *     },\n   *     name: {\n   *       type: \"string\",\n   *       description: \"The astronauts name.\",\n   *     },\n   *     missions: {\n   *       description: \"The number of missions.\",\n   *       type: \"integer\",\n   *       minimum: 0,\n   *     },\n   *   },\n   * }\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, 'astronauts', astronauts)\n   * }\n   * ```\n   */\n\n\n  newCollection(threadID, name, // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  schema, indexes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.NewCollectionRequest();\n      const config = new pb.CollectionConfig();\n      config.setName(name);\n      config.setSchema(encoder.encode(JSON.stringify(schema)));\n      const idx = [];\n\n      for (const item of indexes !== null && indexes !== void 0 ? indexes : []) {\n        const index = new pb.Index();\n        index.setPath(item.path);\n        index.setUnique(item.unique);\n        idx.push(index);\n      }\n\n      config.setIndexesList(idx);\n      req.setDbid(threadID.toBytes());\n      req.setConfig(config);\n      yield this.unary(threads_pb_service_1.API.NewCollection, req);\n      return;\n    });\n  }\n  /**\n   * newCollectionFromObject creates and registers a new collection under the given name.\n   * The input object must be serializable to JSON, and contain only json-schema.org types.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the collection.\n   * @param obj The actual object to attempt to extract a schema from.\n   * @param indexes A set of index definitions for indexing instance fields.\n   *\n   * @example\n   * Change a new astronauts collection based of Buzz\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   const buzz = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *   return await client.newCollectionFromObject(threadID, 'astronauts', buzz)\n   * }\n   * ```\n   */\n\n\n  newCollectionFromObject(threadID, name, // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  obj, indexes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const schema = to_json_schema_1.default(obj);\n      return this.newCollection(threadID, name, schema, indexes);\n    });\n  }\n  /**\n   * updateCollection updates an existing collection.\n   * Currently, updates can include name and schema.\n   * @todo Allow update of indexing information.\n   * @param threadID the ID of the database\n   * @param name the new name of the collection\n   * @param schema the new schema of the collection\n   *\n   * @example\n   * Change the name of our astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const astronauts = {\n   *   title: \"Astronauts\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: {\n   *       type: \"string\",\n   *       description: \"The instance's id.\",\n   *     },\n   *     name: {\n   *       type: \"string\",\n   *       description: \"The astronauts name.\",\n   *     },\n   *     missions: {\n   *       description: \"The number of missions.\",\n   *       type: \"integer\",\n   *       minimum: 0,\n   *     },\n   *   },\n   * }\n   *\n   * async function changeName (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, 'toy-story-characters', astronauts)\n   * }\n   * ```\n   */\n\n\n  updateCollection(threadID, name, // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  schema, indexes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.UpdateCollectionRequest();\n      const conf = new pb.CollectionConfig();\n      conf.setName(name);\n      conf.setSchema(encoder.encode(JSON.stringify(schema)));\n      const idx = [];\n\n      for (const item of indexes !== null && indexes !== void 0 ? indexes : []) {\n        const index = new pb.Index();\n        index.setPath(item.path);\n        index.setUnique(item.unique);\n        idx.push(index);\n      }\n\n      conf.setIndexesList(idx);\n      req.setDbid(threadID.toBytes());\n      req.setConfig(conf);\n      yield this.unary(threads_pb_service_1.API.UpdateCollection, req);\n      return;\n    });\n  }\n  /**\n   * Deletes an existing collection.\n   * @param threadID the ID of the database.\n   * @param name The human-readable name for the collection.\n   * @param schema The actual json-schema.org compatible schema object.\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function deleteAstronauts (client: Client, thread: ThreadID) {\n   *   await client.deleteCollection(thread, 'astronauts')\n   *   return\n   * }\n   * ```\n   */\n\n\n  deleteCollection(threadID, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.DeleteCollectionRequest();\n      req.setDbid(threadID.toBytes());\n      req.setName(name);\n      yield this.unary(threads_pb_service_1.API.DeleteCollection, req);\n      return;\n    });\n  }\n  /**\n   * Returns an existing indexes for a collection.\n   * @param threadID the ID of the database.\n   * @param name The human-readable name for the collection.\n   *\n   * @example\n   * Return a set of indexes for our astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function getIndexes (client: Client, threadID: ThreadID) {\n   *   return await client.getCollectionIndexes(threadID, 'astronauts')\n   * }\n   * ```\n   */\n\n\n  getCollectionIndexes(threadID, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.GetCollectionIndexesRequest();\n      req.setDbid(threadID.toBytes());\n      req.setName(name);\n      const res = yield this.unary(threads_pb_service_1.API.GetCollectionIndexes, req);\n      return res.indexesList;\n    });\n  }\n\n  getCollectionInfo(threadID, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.GetCollectionInfoRequest();\n      req.setDbid(threadID.toBytes());\n      req.setName(name);\n      const res = yield this.unary(threads_pb_service_1.API.GetCollectionInfo, req);\n      res.schema = JSON.parse(Buffer.from(res.schema, \"base64\"));\n      return res;\n    });\n  }\n  /**\n   * newDBFromAddr initializes the client with the given store, connecting to the given\n   * thread address (database). It should be called before any operation on the store, and is an\n   * alternative to start, which creates a local store. newDBFromAddr should also include the\n   * read/follow key, which should be a Buffer, Uint8Array or base32-encoded string.\n   * @remarks\n   * See getDBInfo for a possible source of the address and keys. See ThreadKey for\n   * information about thread keys.\n   * @param address The address for the thread with which to connect.\n   * Should be of the form /ip4/<url/ip-address>/tcp/<port>/p2p/<peer-id>/thread/<thread-id>\n   * @param key The set of keys to use to connect to the database\n   * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.\n   */\n\n\n  newDBFromAddr(address, key, collections) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.NewDBFromAddrRequest();\n      const addr = new multiaddr_1.Multiaddr(address).buffer;\n      req.setAddr(addr); // Should always be encoded string, but might already be bytes\n\n      req.setKey(typeof key === \"string\" ? threads_core_1.ThreadKey.fromString(key).toBytes() : key);\n\n      if (collections !== undefined) {\n        req.setCollectionsList(collections.map(c => {\n          const config = new pb.CollectionConfig();\n          config.setName(c.name);\n          config.setSchema(encoder.encode(JSON.stringify(c.schema)));\n          return config;\n        }));\n      }\n\n      yield this.unary(threads_pb_service_1.API.NewDBFromAddr, req); // Hacky way to extract threadid from addr that succeeded\n      // @todo: Return this directly from the gRPC API?\n\n      const result = new multiaddr_1.Multiaddr(Buffer.from(req.getAddr_asU8())).stringTuples().filter(([key]) => key === 406);\n      return threads_id_1.ThreadID.fromString(result[0][1]);\n    });\n  }\n  /**\n   * Connect client to an existing database using information in the DBInfo object\n   * This should be called before any operation on the store, and is an alternative\n   * to open, which re-opens a database already opened by the user.\n   * @remarks This is a helper method around newDBFromAddr, which takes the 'raw' output\n   * from getDBInfo. See getDBInfo for a possible source of the address and keys.\n   * @param info The output from a call to getDBInfo on a separate peer.\n   * @param includeLocal Whether to try dialing addresses that appear to be on the local host.\n   * Defaults to false, preferring to add from public ip addresses.\n   * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.\n   *\n   * @example\n   * Get DB info and use DB info to join an existing remote thread (e.g. invited)\n   * ```typescript\n   * import {Client, DBInfo, ThreadID} from '@textile/threads'\n   *\n   * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {\n   *   return await client.getDBInfo(threadID)\n   * }\n   *\n   * async function joinFromInfo (client: Client, info: DBInfo) {\n   *   return await client.joinFromInfo(info)\n   * }\n   * ```\n   */\n\n\n  joinFromInfo(info, includeLocal = false, collections) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.NewDBFromAddrRequest();\n      const filtered = info.addrs.map(addr => new multiaddr_1.Multiaddr(addr)).filter(addr => includeLocal || !maybeLocalAddr(addr.toOptions().host));\n\n      for (const addr of filtered) {\n        req.setAddr(addr.buffer); // Should always be encoded string, but might already be bytes\n\n        req.setKey(typeof info.key === \"string\" ? threads_core_1.ThreadKey.fromString(info.key).toBytes() : info.key);\n\n        if (collections !== undefined) {\n          req.setCollectionsList(collections.map(c => {\n            const config = new pb.CollectionConfig();\n            config.setName(c.name);\n            config.setSchema(encoder.encode(JSON.stringify(c.schema)));\n            return config;\n          }));\n        } // Try to add addrs one at a time, if one succeeds, we are done.\n\n\n        yield this.unary(threads_pb_service_1.API.NewDBFromAddr, req); // Hacky way to extract threadid from addr that succeeded\n        // @todo: Return this directly from the gRPC API?\n\n        const result = new multiaddr_1.Multiaddr(Buffer.from(req.getAddr_asU8())).stringTuples().filter(([key]) => key === 406);\n        return threads_id_1.ThreadID.fromString(result[0][1]);\n      }\n\n      throw new Error(\"No viable addresses for dialing\");\n    });\n  }\n  /**\n   * Returns a DBInfo objection containing metadata required to invite other peers to join a given thread.\n   * @param threadID the ID of the database\n   * @returns An object with an encoded thread key, and a list of multiaddrs.\n   *\n   * @example\n   * Get DB info and use DB info to join an existing remote thread (e.g. invited)\n   * ```typescript\n   * import {Client, DBInfo, ThreadID} from '@textile/threads'\n   *\n   * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {\n   *   return await client.getDBInfo(threadID)\n   * }\n   *\n   * async function joinFromInfo (client: Client, info: DBInfo) {\n   *   return await client.joinFromInfo(info)\n   * }\n   * ```\n   */\n\n\n  getDBInfo(threadID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.GetDBInfoRequest();\n      req.setDbid(threadID.toBytes());\n      const res = yield this.unary(threads_pb_service_1.API.GetDBInfo, req);\n      const threadKey = Buffer.from(res.key, \"base64\");\n      const key = threads_core_1.ThreadKey.fromBytes(threadKey);\n      const addrs = [];\n\n      for (const addr of res.addrsList) {\n        const a = typeof addr === \"string\" ? Buffer.from(addr, \"base64\") : Buffer.from(addr);\n        const address = new multiaddr_1.Multiaddr(a).toString();\n        addrs.push(address);\n      }\n\n      return {\n        key: key.toString(),\n        addrs\n      };\n    });\n  }\n  /**\n   * Creates a new model instance in the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   *\n   * @example\n   * Create a new entry in our collection\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function createBuzz (client: Client, threadID: ThreadID) {\n   *   const buzz: Astronaut = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *\n   *   await client.create(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n\n\n  create(threadID, collectionName, values) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.CreateRequest();\n      req.setDbid(threadID.toBytes());\n      req.setCollectionname(collectionName);\n      const list = [];\n      values.forEach(v => {\n        list.push(encoder.encode(JSON.stringify(v)));\n      });\n      req.setInstancesList(list);\n      const res = yield this.unary(threads_pb_service_1.API.Create, req);\n      return res.instanceidsList;\n    });\n  }\n  /**\n   * Saves changes to an existing model instance in the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   * Each model instance must have a valid existing `_id` property.\n   *\n   * @example\n   * Update an existing instance\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function updateBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const buzz = result.instancesList[0]\n   *   buzz.missions += 1\n   *\n   *   return await client.save(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n\n\n  save(threadID, collectionName, values) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.SaveRequest();\n      req.setDbid(threadID.toBytes());\n      req.setCollectionname(collectionName);\n      const list = [];\n      values.forEach(v => {\n        if (!v.hasOwnProperty(\"_id\")) {\n          v[\"_id\"] = \"\"; // The server will add an ID if empty.\n        }\n\n        list.push(encoder.encode(JSON.stringify(v)));\n      });\n      req.setInstancesList(list);\n      yield this.unary(threads_pb_service_1.API.Save, req);\n      return;\n    });\n  }\n  /**\n   * Deletes an existing model instance from the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param IDs An array of instance ids to delete.\n   *\n   * @example\n   * Delete any instances that return from a query\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function deleteBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const ids = await result.instancesList.map((instance) => instance._id)\n   *   await client.delete(threadID, 'astronauts', ids)\n   * }\n   * ```\n   */\n\n\n  delete(threadID, collectionName, IDs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.DeleteRequest();\n      req.setDbid(threadID.toBytes());\n      req.setCollectionname(collectionName);\n      req.setInstanceidsList(IDs);\n      yield this.unary(threads_pb_service_1.API.Delete, req);\n      return;\n    });\n  }\n  /**\n   * Check if a given instance exists in the collection.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param IDs An array of instance ids to check for.\n   *\n   * @example\n   * Check if an instance exists\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * async function instanceExists (client: Client, threadID: ThreadID, id: string) {\n   *   return await client.has(threadID, 'astronauts', [id])\n   * }\n   * ```\n   */\n\n\n  has(threadID, collectionName, IDs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.HasRequest();\n      req.setDbid(threadID.toBytes());\n      req.setCollectionname(collectionName);\n      req.setInstanceidsList(IDs);\n      const res = yield this.unary(threads_pb_service_1.API.Has, req);\n      return res.exists;\n    });\n  }\n  /**\n   * Queries a collection for entities matching the given query parameters.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param query The object that describes the query. User Query class or primitive QueryJSON type.\n   *\n   * @example\n   * Query with return type\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function getAstronautByName (client: Client, threadID: ThreadID, name: string) {\n   *   const query = new Where('name').eq(name)\n   *   const astronaut = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *   return astronaut\n   * }\n   * ```\n   */\n\n\n  find(threadID, collectionName, query) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.FindRequest();\n      req.setDbid(threadID.toBytes());\n      req.setCollectionname(collectionName); // @todo: Find a more isomorphic way to do this base64 round-trip\n\n      req.setQueryjson(encoder.encode(JSON.stringify(query)));\n      const res = yield this.unary(threads_pb_service_1.API.Find, req);\n      const ret = {\n        instancesList: res.instancesList.map(instance => JSON.parse(Buffer.from(instance, \"base64\").toString()))\n      };\n      return ret;\n    });\n  }\n  /**\n   * Queries the collection by a known instance ID.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param ID The id of the instance to search for.\n   *\n   * @example\n   * Find and cast a known model by instance ID.\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function getAstronaut (client: Client, threadID: ThreadID, id: string) {\n   *   const astronaut = await client.findByID<Astronaut>(threadID, 'astronauts', id)\n   *   return astronaut\n   * }\n   * ```\n   *\n   * @example\n   * Simple find and return any instance\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function getInstance (client: Client, threadID: ThreadID, id: string) {\n   *   return await client.findByID(threadID, 'astronauts', id)\n   * }\n   * ```\n   */\n\n\n  findByID(threadID, collectionName, ID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.FindByIDRequest();\n      req.setDbid(threadID.toBytes());\n      req.setCollectionname(collectionName);\n      req.setInstanceid(ID);\n      const res = yield this.unary(threads_pb_service_1.API.FindByID, req);\n      const ret = {\n        instance: JSON.parse(Buffer.from(res.instance, \"base64\").toString())\n      };\n      return ret;\n    });\n  }\n  /**\n   * Verify checks existing instance changes.\n   * Each model instance must have a valid existing `_id` property.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   *\n   * @example\n   * Update an existing instance\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function verifyBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const buzz = result.instancesList[0]\n   *   buzz.missions += 1\n   *\n   *   // Is this going to be a valid update?\n   *   return await client.verify(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n\n\n  verify(threadID, collectionName, values) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const req = new pb.VerifyRequest();\n      req.setDbid(threadID.toBytes());\n      req.setCollectionname(collectionName);\n      const list = values.map(v => encoder.encode(JSON.stringify(v)));\n      req.setInstancesList(list);\n      const {\n        transactionerror\n      } = yield this.unary(threads_pb_service_1.API.Verify, req);\n      return transactionerror ? new Error(transactionerror) : undefined;\n    });\n  }\n  /**\n   * readTransaction creates a new read-only transaction object. See ReadTransaction for details.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   */\n\n\n  readTransaction(threadID, collectionName) {\n    const client = grpc_web_1.grpc.client(threads_pb_service_1.API.ReadTransaction, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug\n    });\n    return new models_1.ReadTransaction(this.context, client, threadID, collectionName);\n  }\n  /**\n   * writeTransaction creates a new writeable transaction object. See WriteTransaction for details.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   */\n\n\n  writeTransaction(threadID, collectionName) {\n    const client = grpc_web_1.grpc.client(threads_pb_service_1.API.WriteTransaction, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug\n    });\n    return new models_1.WriteTransaction(this.context, client, threadID, collectionName);\n  }\n  /**\n   * listen opens a long-lived connection with a remote node, running the given callback on each new update to the given instance.\n   * The return value is a `close` function, which cleanly closes the connection with the remote node.\n   * @param threadID the ID of the database\n   * @param filters contains an array of Filters\n   * @param callback The callback to call on each update to the given instance.\n   *\n   * @example\n   * ```typescript\n   * import {Client, ThreadID, Update} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   * function setupListener (client: Client, threadID: ThreadID) {\n   *   const callback = (update?: Update<Astronaut>) => {\n   *     // Not safe if more than the Astronauts collection existed in the same DB\n   *     if (!update || !update.instance) return\n   *     console.log('New update:', update.instance.name, update.instance.missions)\n   *   }\n   *   const closer = client.listen(threadID, [], callback)\n   *   return closer\n   * }\n   * ```\n   *\n   * @example\n   * Listen to only CREATE events on a specific Collection.\n   * ```typescript\n   * import {Client, ThreadID, Update} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   * function setupListener (client: Client, threadID: ThreadID) {\n   *   const callback = (update?: Update<Astronaut>) => {\n   *     if (!update || !update.instance) return\n   *     console.log('New update:', update.instance.name, update.instance.missions)\n   *   }\n   *   const filters = [\n   *     {collectionName: 'Astronauts'},\n   *     {actionTypes: ['CREATE']}\n   *   ]\n   *   const closer = client.listen(threadID, filters, callback)\n   *   return closer\n   * }\n   * ```\n   */\n\n\n  listen(threadID, filters, callback) {\n    const req = new pb.ListenRequest();\n    req.setDbid(threadID.toBytes());\n\n    for (const filter of filters) {\n      const requestFilter = new pb.ListenRequest.Filter();\n\n      if (filter.instanceID) {\n        requestFilter.setInstanceid(filter.instanceID);\n      } else if (filter.collectionName) {\n        requestFilter.setCollectionname(filter.collectionName);\n      }\n\n      if (filter.actionTypes) {\n        for (const at of filter.actionTypes) {\n          switch (at) {\n            case \"ALL\":\n              {\n                requestFilter.setAction(pb.ListenRequest.Filter.Action.ALL);\n                break;\n              }\n\n            case \"CREATE\":\n              {\n                requestFilter.setAction(pb.ListenRequest.Filter.Action.CREATE);\n                break;\n              }\n\n            case \"SAVE\":\n              {\n                requestFilter.setAction(pb.ListenRequest.Filter.Action.SAVE);\n                break;\n              }\n\n            case \"DELETE\":\n              {\n                requestFilter.setAction(pb.ListenRequest.Filter.Action.DELETE);\n                break;\n              }\n          }\n        }\n      } else {\n        requestFilter.setAction(0);\n      }\n\n      req.addFilters(requestFilter);\n    }\n\n    const decoder = new TextDecoder();\n    const client = grpc_web_1.grpc.client(threads_pb_service_1.API.Listen, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug\n    });\n    client.onMessage(message => {\n      // Pull it apart explicitly\n      const instanceString = decoder.decode(message.getInstance_asU8());\n      const actionInt = message.getAction();\n      const action = Action[actionInt];\n      const collectionName = message.getCollectionname();\n      const instanceID = message.getInstanceid();\n      const ret = {\n        collectionName,\n        instanceID,\n        action,\n        instance: undefined\n      };\n\n      if (instanceString !== \"\") {\n        ret.instance = JSON.parse(instanceString);\n      }\n\n      callback(ret);\n    });\n    client.onEnd((status, message\n    /** trailers: grpc.Metadata */\n    ) => {\n      if (status !== grpc_web_1.grpc.Code.OK) {\n        callback(undefined, new Error(message));\n      }\n\n      callback();\n    });\n    this.context.toMetadata().then(metadata => {\n      client.start(metadata);\n      client.send(req);\n      client.finishSend();\n    });\n    return {\n      close: () => client.close()\n    };\n  }\n\n  unary(methodDescriptor, req) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const metadata = yield this.context.toMetadata();\n      return new Promise((resolve, reject) => {\n        grpc_web_1.grpc.unary(methodDescriptor, {\n          transport: this.rpcOptions.transport,\n          debug: this.rpcOptions.debug,\n          request: req,\n          host: this.serviceHost,\n          metadata,\n          onEnd: res => {\n            const {\n              status,\n              statusMessage,\n              message\n            } = res;\n\n            if (status === grpc_web_1.grpc.Code.OK) {\n              if (message) {\n                resolve(message.toObject());\n              } else {\n                resolve();\n              }\n            } else {\n              reject(new Error(statusMessage));\n            }\n          }\n        });\n      });\n    });\n  }\n\n}\n\nexports.Client = Client;\nexports.default = Client;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module @textile/threads-client\n */\nimport { grpc } from \"@improbable-eng/grpc-web\"\nimport { Context, ContextInterface, defaultHost } from \"@textile/context\"\nimport { WebsocketTransport } from \"@textile/grpc-transport\"\nimport { Multiaddr } from \"@textile/multiaddr\"\nimport { KeyInfo, UserAuth } from \"@textile/security\"\nimport * as pb from \"@textile/threads-client-grpc/threads_pb\"\nimport {\n  API,\n  APIGetToken,\n  APIListen,\n} from \"@textile/threads-client-grpc/threads_pb_service\"\nimport {\n  Identity,\n  Libp2pCryptoIdentity,\n  ThreadKey,\n} from \"@textile/threads-core\"\nimport { ThreadID } from \"@textile/threads-id\"\nimport toJsonSchema from \"to-json-schema\"\nimport {\n  CriterionJSON,\n  Filter,\n  Instance,\n  InstanceList,\n  Query,\n  QueryJSON,\n  ReadTransaction,\n  SortJSON,\n  ValueJSON,\n  Where,\n  WriteTransaction,\n} from \"./models\"\n\nexport {\n  Filter,\n  Query,\n  Where,\n  WriteTransaction,\n  ReadTransaction,\n  Instance,\n  InstanceList,\n  QueryJSON,\n  ValueJSON,\n  CriterionJSON,\n  SortJSON,\n}\n\nexport interface CollectionInfo {\n  name: string\n  schema: any\n  indexesList: Array<pb.Index.AsObject>\n}\n\nexport interface CollectionConfig {\n  name: string\n  schema: any\n  indexes: pb.Index.AsObject\n}\n\nconst encoder = new TextEncoder()\n\nexport function maybeLocalAddr(ip: string): boolean | RegExpMatchArray {\n  return (\n    [\"localhost\", \"\", \"::1\"].includes(ip) ||\n    ip.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/) ||\n    ip.startsWith(\"192.168.\") ||\n    ip.startsWith(\"10.0.\") ||\n    ip.endsWith(\".local\")\n  )\n}\n\nexport enum Action {\n  CREATE = 0,\n  SAVE,\n  DELETE,\n}\n\nexport interface Update<T = any> extends Instance<T> {\n  collectionName: string\n  instanceID: string\n  action: Action\n}\n\n/**\n * DBInfo contains joining/sharing information for a Thread/DB.\n */\nexport interface DBInfo {\n  /**\n   * The Thread Key, encoded as a base32 string.\n   * @see ThreadKey for details.\n   */\n  key: string\n  /**\n   * The Multiaddrs for a peer hosting the given Thread/DB.\n   */\n  addrs: string[]\n}\n\n/**\n * Client is a web-gRPC wrapper client for communicating with a webgRPC-enabled Threads server.\n * This client library can be used to interact with a local or remote Textile gRPC-service\n * It is a wrapper around Textile Thread's 'DB' API, which is defined here:\n * https://github.com/textileio/go-threads/blob/master/api/pb/api.proto.\n *\n * @example\n * ```typescript\n * import {Client, Identity, UserAuth} from '@textile/threads'\n *\n * async function setupDB(auth: UserAuth, identity: Identity) {\n *   // Initialize the client\n *   const client = Client.withUserAuth(auth)\n *\n *   // Connect the user to your API\n *   const userToken = await client.getToken(identity)\n *\n *   // Create a new DB\n *   const threadID = await client.newDB(undefined, 'nasa')\n *\n *   // Create a new Collection from an Object\n *   const buzz = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *   await client.newCollectionFromObject(threadID, 'astronauts', buzz)\n *\n *   // Store the buzz object in the new collection\n *   await client.create(threadID, 'astronauts', [buzz])\n *\n *   return threadID\n * }\n * ```\n */\nexport class Client {\n  public serviceHost: string\n  public rpcOptions: grpc.RpcOptions\n  /**\n   * Creates a new gRPC client instance for accessing the Textile Threads API.\n   * @param context The context to use for interacting with the APIs. Can be modified later.\n   * @param debug Should we run in debug mode. Defaults to false.\n   */\n  constructor(public context: ContextInterface = new Context(), debug = false) {\n    this.serviceHost = context.host\n    this.rpcOptions = {\n      transport: WebsocketTransport(),\n      debug,\n    }\n  }\n\n  /**\n   * Create a new gRPC client instance from a supplied user auth object.\n   * Assumes all default gRPC settlings. For customization options, use a context object directly.\n   * The callback method will automatically refresh expiring credentials.\n   * @param auth The user auth object or an async callback that returns a user auth object.\n   * @example\n   * ```typescript\n   * import {UserAuth, Client} from '@textile/threads'\n   *\n   * function create (auth: UserAuth) {\n   *   return Client.withUserAuth(auth)\n   * }\n   * ```\n   * @example\n   * ```typescript\n   * import {UserAuth, Client} from '@textile/threads'\n   *\n   * function setCallback (callback: () => Promise<UserAuth>) {\n   *   return Client.withUserAuth(callback)\n   * }\n   * ```\n   */\n  static withUserAuth(\n    auth: UserAuth | (() => Promise<UserAuth>),\n    host = defaultHost,\n    debug = false\n  ): Client {\n    const context =\n      typeof auth === \"object\"\n        ? Context.fromUserAuth(auth, host)\n        : Context.fromUserAuthCallback(auth, host)\n    return new Client(context, debug)\n  }\n\n  /**\n   * Create a new gRPC client instance from a supplied key and secret\n   * @param key The KeyInfo object containing {key: string, secret: string, type: 0}. 0 === User Group Key, 1 === Account Key\n   * @param host The remote gRPC host to connect with. Should be left as default.\n   * @param debug Whether to run in debug mode. Defaults to false.\n   * @example\n   * ```typescript\n   * import {KeyInfo, Client} from '@textile/threads'\n   *\n   * async function create (keyInfo: KeyInfo) {\n   *   return await Client.withKeyInfo(keyInfo)\n   * }\n   * ```\n   */\n  static async withKeyInfo(\n    key: KeyInfo,\n    host = defaultHost,\n    debug = false\n  ): Promise<Client> {\n    const context = new Context(host)\n    await context.withKeyInfo(key)\n    return new Client(context, debug)\n  }\n\n  /**\n   * Create a random user identity.\n   * @deprecated\n   * @remarks\n   * See `PrivateKey`\n   */\n  static async randomIdentity(): Promise<Libp2pCryptoIdentity> {\n    return Libp2pCryptoIdentity.fromRandom()\n  }\n\n  /**\n   * Obtain a token per user (identity) for interacting with the remote API.\n   * @param identity A user identity to use for creating records in the database. A random identity\n   * can be created with `Client.randomIdentity(), however, it is not easy/possible to migrate\n   * identities after the fact. Please store or otherwise persist any identity information if\n   * you wish to retrieve user data later, or use an external identity provider.\n   * @param ctx Context object containing web-gRPC headers and settings.\n   * @example\n   * ```typescript\n   * import {Client, Identity} from '@textile/threads'\n   *\n   * async function newToken (client: Client, user: Identity) {\n   *   // Token is added to the client connection at the same time\n   *   const token = await client.getToken(user)\n   *   return token\n   * }\n   * ```\n   */\n  async getToken(identity: Identity, ctx?: ContextInterface): Promise<string> {\n    return this.getTokenChallenge(\n      identity.public.toString(),\n      async (challenge: Uint8Array) => {\n        return identity.sign(challenge)\n      },\n      ctx\n    )\n  }\n\n  /**\n   * Obtain a token per user (identity) for interacting with the remote API.\n   * @param publicKey The public key of a user identity to use for creating records in the database.\n   * A random identity can be created with `Client.randomIdentity(), however, it is not\n   * easy/possible to migrate identities after the fact. Please store or otherwise persist any\n   * identity information if you wish to retrieve user data later, or use an external identity\n   * provider.\n   * @param callback A callback function that takes a `challenge` argument and returns a signed\n   * message using the input challenge and the private key associated with `publicKey`.\n   * @param ctx Context object containing web-gRPC headers and settings.\n   * @remarks `publicKey` must be the corresponding public key of the private key used in `callback`.\n   */\n  async getTokenChallenge(\n    publicKey: string,\n    callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>,\n    ctx?: ContextInterface\n  ): Promise<string> {\n    const client = grpc.client<\n      pb.GetTokenRequest,\n      pb.GetTokenReply,\n      APIGetToken\n    >(API.GetToken, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    })\n    return new Promise<string>((resolve, reject) => {\n      let token = \"\"\n      client.onMessage(async (message: pb.GetTokenReply) => {\n        if (message.hasChallenge()) {\n          const challenge = message.getChallenge_asU8()\n          const signature = await callback(challenge)\n          const req = new pb.GetTokenRequest()\n          req.setSignature(signature)\n          client.send(req)\n          client.finishSend()\n        } else if (message.hasToken()) {\n          token = message.getToken()\n        }\n      })\n      client.onEnd((\n        code: grpc.Code,\n        message: string /** trailers: grpc.Metadata */\n      ) => {\n        client.close()\n        if (code === grpc.Code.OK) {\n          this.context.withToken(token)\n          resolve(token)\n        } else {\n          reject(new Error(message))\n        }\n      })\n      const req = new pb.GetTokenRequest()\n      req.setKey(publicKey)\n      this.context.toMetadata(ctx).then((metadata) => {\n        client.start(metadata)\n        client.send(req)\n      })\n    })\n  }\n\n  /**\n   * newDB creates a new store on the remote node.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the database\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function createDB (client: Client) {\n   *   const threadID: ThreadID = await client.newDB()\n   *   return threadID\n   * }\n   * ```\n   */\n  public async newDB(threadID?: ThreadID, name?: string): Promise<ThreadID> {\n    const dbID = threadID ?? ThreadID.fromRandom()\n    const req = new pb.NewDBRequest()\n    req.setDbid(dbID.toBytes())\n    if (name !== undefined) {\n      this.context.withThreadName(name)\n      req.setName(name)\n    }\n    await this.unary(API.NewDB, req)\n    // Update our context with out new thread id\n    this.context.withThread(dbID.toString())\n    return dbID\n  }\n\n  /**\n   * open creates and enters a new store on the remote node.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the database\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function openDB (client: Client, threadID: ThreadID) {\n   *   await client.open(threadID)\n   * }\n   * ```\n   */\n  public async open(threadID: ThreadID, name?: string): Promise<void> {\n    const req = new pb.ListDBsRequest()\n    const res = (await this.unary(API.ListDBs, req)) as pb.ListDBsReply.AsObject\n    for (const db of res.dbsList) {\n      const id = ThreadID.fromBytes(Buffer.from(db.dbid as string, \"base64\"))\n      if (id === threadID) {\n        this.context.withThread(threadID.toString())\n        return\n      }\n    }\n    await this.newDB(threadID, name)\n    this.context.withThread(threadID.toString())\n  }\n\n  /**\n   * Deletes an entire DB.\n   * @param threadID the ID of the database.\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function deleteDB (client: Client, threadID: ThreadID) {\n   *   await client.deleteDB(threadID)\n   *   return\n   * }\n   * ```\n   */\n  public async deleteDB(threadID: ThreadID): Promise<void> {\n    const req = new pb.DeleteDBRequest()\n    req.setDbid(threadID.toBytes())\n    await this.unary(API.DeleteDB, req)\n    return\n  }\n\n  /**\n   * Lists all known DBs.\n   * @remarks this API is blocked on the Hub. Use `listThreads` when importing Client\n   * from `@textile/hub` as an alternative.\n   */\n  public async listDBs(): Promise<\n    Record<string, pb.GetDBInfoReply.AsObject | undefined>\n  > {\n    const req = new pb.ListDBsRequest()\n    const res = (await this.unary(API.ListDBs, req)) as pb.ListDBsReply.AsObject\n    const dbs: Record<string, pb.GetDBInfoReply.AsObject | undefined> = {}\n    for (const db of res.dbsList) {\n      const id = ThreadID.fromBytes(\n        Buffer.from(db.dbid as string, \"base64\")\n      ).toString()\n      dbs[id] = db.info\n    }\n    return dbs\n  }\n\n  /**\n   * Lists the collections in a thread\n   * @param thread the ID of the database\n   */\n  public async listCollections(\n    thread: ThreadID\n  ): Promise<Array<pb.GetCollectionInfoReply.AsObject>> {\n    const req = new pb.ListCollectionsRequest()\n    req.setDbid(thread.toBytes())\n    const resp = (await this.unary(\n      API.ListCollections,\n      req\n    )) as pb.ListCollectionsReply.AsObject\n    return resp.collectionsList\n  }\n\n  /**\n   * newCollection registers a new collection schema under the given name.\n   * The schema must be a valid json-schema.org schema, and can be a JSON string or object.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the collection.\n   * @param schema The actual json-schema.org compatible schema object.\n   * @param indexes A set of index definitions for indexing instance fields.\n   *\n   * @example\n   * Change a new astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const astronauts = {\n   *   title: \"Astronauts\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: {\n   *       type: \"string\",\n   *       description: \"The instance's id.\",\n   *     },\n   *     name: {\n   *       type: \"string\",\n   *       description: \"The astronauts name.\",\n   *     },\n   *     missions: {\n   *       description: \"The number of missions.\",\n   *       type: \"integer\",\n   *       minimum: 0,\n   *     },\n   *   },\n   * }\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, 'astronauts', astronauts)\n   * }\n   * ```\n   */\n  public async newCollection(\n    threadID: ThreadID,\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    schema: any,\n    indexes?: pb.Index.AsObject[]\n  ): Promise<void> {\n    const req = new pb.NewCollectionRequest()\n    const config = new pb.CollectionConfig()\n    config.setName(name)\n    config.setSchema(encoder.encode(JSON.stringify(schema)))\n    const idx: pb.Index[] = []\n    for (const item of indexes ?? []) {\n      const index = new pb.Index()\n      index.setPath(item.path)\n      index.setUnique(item.unique)\n      idx.push(index)\n    }\n    config.setIndexesList(idx)\n    req.setDbid(threadID.toBytes())\n    req.setConfig(config)\n    await this.unary(API.NewCollection, req)\n    return\n  }\n\n  /**\n   * newCollectionFromObject creates and registers a new collection under the given name.\n   * The input object must be serializable to JSON, and contain only json-schema.org types.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the collection.\n   * @param obj The actual object to attempt to extract a schema from.\n   * @param indexes A set of index definitions for indexing instance fields.\n   *\n   * @example\n   * Change a new astronauts collection based of Buzz\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   const buzz = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *   return await client.newCollectionFromObject(threadID, 'astronauts', buzz)\n   * }\n   * ```\n   */\n  public async newCollectionFromObject(\n    threadID: ThreadID,\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    obj: any,\n    indexes?: pb.Index.AsObject[]\n  ): Promise<void> {\n    const schema = toJsonSchema(obj)\n    return this.newCollection(threadID, name, schema, indexes)\n  }\n\n  /**\n   * updateCollection updates an existing collection.\n   * Currently, updates can include name and schema.\n   * @todo Allow update of indexing information.\n   * @param threadID the ID of the database\n   * @param name the new name of the collection\n   * @param schema the new schema of the collection\n   *\n   * @example\n   * Change the name of our astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const astronauts = {\n   *   title: \"Astronauts\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: {\n   *       type: \"string\",\n   *       description: \"The instance's id.\",\n   *     },\n   *     name: {\n   *       type: \"string\",\n   *       description: \"The astronauts name.\",\n   *     },\n   *     missions: {\n   *       description: \"The number of missions.\",\n   *       type: \"integer\",\n   *       minimum: 0,\n   *     },\n   *   },\n   * }\n   *\n   * async function changeName (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, 'toy-story-characters', astronauts)\n   * }\n   * ```\n   */\n  public async updateCollection(\n    threadID: ThreadID,\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    schema: any,\n    indexes?: pb.Index.AsObject[]\n  ): Promise<void> {\n    const req = new pb.UpdateCollectionRequest()\n    const conf = new pb.CollectionConfig()\n    conf.setName(name)\n    conf.setSchema(encoder.encode(JSON.stringify(schema)))\n    const idx: pb.Index[] = []\n    for (const item of indexes ?? []) {\n      const index = new pb.Index()\n      index.setPath(item.path)\n      index.setUnique(item.unique)\n      idx.push(index)\n    }\n    conf.setIndexesList(idx)\n    req.setDbid(threadID.toBytes())\n    req.setConfig(conf)\n    await this.unary(API.UpdateCollection, req)\n    return\n  }\n\n  /**\n   * Deletes an existing collection.\n   * @param threadID the ID of the database.\n   * @param name The human-readable name for the collection.\n   * @param schema The actual json-schema.org compatible schema object.\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function deleteAstronauts (client: Client, thread: ThreadID) {\n   *   await client.deleteCollection(thread, 'astronauts')\n   *   return\n   * }\n   * ```\n   */\n  public async deleteCollection(\n    threadID: ThreadID,\n    name: string\n  ): Promise<void> {\n    const req = new pb.DeleteCollectionRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    await this.unary(API.DeleteCollection, req)\n    return\n  }\n\n  /**\n   * Returns an existing indexes for a collection.\n   * @param threadID the ID of the database.\n   * @param name The human-readable name for the collection.\n   *\n   * @example\n   * Return a set of indexes for our astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function getIndexes (client: Client, threadID: ThreadID) {\n   *   return await client.getCollectionIndexes(threadID, 'astronauts')\n   * }\n   * ```\n   */\n  public async getCollectionIndexes(\n    threadID: ThreadID,\n    name: string\n  ): Promise<pb.Index.AsObject[]> {\n    const req = new pb.GetCollectionIndexesRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    const res = (await this.unary(\n      API.GetCollectionIndexes,\n      req\n    )) as pb.GetCollectionIndexesReply.AsObject\n    return res.indexesList\n  }\n\n  public async getCollectionInfo(\n    threadID: ThreadID,\n    name: string\n  ): Promise<CollectionInfo> {\n    const req = new pb.GetCollectionInfoRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    const res = (await this.unary(\n      API.GetCollectionInfo,\n      req\n    )) as pb.GetCollectionInfoReply.AsObject\n    res.schema = JSON.parse(\n      (Buffer.from(res.schema as string, \"base64\") as unknown) as string\n    )\n    return res\n  }\n\n  /**\n   * newDBFromAddr initializes the client with the given store, connecting to the given\n   * thread address (database). It should be called before any operation on the store, and is an\n   * alternative to start, which creates a local store. newDBFromAddr should also include the\n   * read/follow key, which should be a Buffer, Uint8Array or base32-encoded string.\n   * @remarks\n   * See getDBInfo for a possible source of the address and keys. See ThreadKey for\n   * information about thread keys.\n   * @param address The address for the thread with which to connect.\n   * Should be of the form /ip4/<url/ip-address>/tcp/<port>/p2p/<peer-id>/thread/<thread-id>\n   * @param key The set of keys to use to connect to the database\n   * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.\n   */\n  public async newDBFromAddr(\n    address: string,\n    key: string | Uint8Array,\n    collections?: Array<{ name: string; schema: any }>\n  ): Promise<ThreadID> {\n    const req = new pb.NewDBFromAddrRequest()\n    const addr = new Multiaddr(address).buffer\n    req.setAddr(addr)\n    // Should always be encoded string, but might already be bytes\n    req.setKey(\n      typeof key === \"string\" ? ThreadKey.fromString(key).toBytes() : key\n    )\n    if (collections !== undefined) {\n      req.setCollectionsList(\n        collections.map((c) => {\n          const config = new pb.CollectionConfig()\n          config.setName(c.name)\n          config.setSchema(encoder.encode(JSON.stringify(c.schema)))\n          return config\n        })\n      )\n    }\n    await this.unary(API.NewDBFromAddr, req)\n    // Hacky way to extract threadid from addr that succeeded\n    // @todo: Return this directly from the gRPC API?\n    const result = new Multiaddr(Buffer.from(req.getAddr_asU8()))\n      .stringTuples()\n      .filter(([key]) => key === 406)\n    return ThreadID.fromString(result[0][1])\n  }\n\n  /**\n   * Connect client to an existing database using information in the DBInfo object\n   * This should be called before any operation on the store, and is an alternative\n   * to open, which re-opens a database already opened by the user.\n   * @remarks This is a helper method around newDBFromAddr, which takes the 'raw' output\n   * from getDBInfo. See getDBInfo for a possible source of the address and keys.\n   * @param info The output from a call to getDBInfo on a separate peer.\n   * @param includeLocal Whether to try dialing addresses that appear to be on the local host.\n   * Defaults to false, preferring to add from public ip addresses.\n   * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.\n   *\n   * @example\n   * Get DB info and use DB info to join an existing remote thread (e.g. invited)\n   * ```typescript\n   * import {Client, DBInfo, ThreadID} from '@textile/threads'\n   *\n   * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {\n   *   return await client.getDBInfo(threadID)\n   * }\n   *\n   * async function joinFromInfo (client: Client, info: DBInfo) {\n   *   return await client.joinFromInfo(info)\n   * }\n   * ```\n   */\n  public async joinFromInfo(\n    info: DBInfo,\n    includeLocal = false,\n    collections?: Array<{ name: string; schema: any }>\n  ): Promise<ThreadID> {\n    const req = new pb.NewDBFromAddrRequest()\n    const filtered = info.addrs\n      .map((addr) => new Multiaddr(addr))\n      .filter((addr) => includeLocal || !maybeLocalAddr(addr.toOptions().host))\n    for (const addr of filtered) {\n      req.setAddr(addr.buffer)\n      // Should always be encoded string, but might already be bytes\n      req.setKey(\n        typeof info.key === \"string\"\n          ? ThreadKey.fromString(info.key).toBytes()\n          : info.key\n      )\n      if (collections !== undefined) {\n        req.setCollectionsList(\n          collections.map((c) => {\n            const config = new pb.CollectionConfig()\n            config.setName(c.name)\n            config.setSchema(encoder.encode(JSON.stringify(c.schema)))\n            return config\n          })\n        )\n      }\n      // Try to add addrs one at a time, if one succeeds, we are done.\n      await this.unary(API.NewDBFromAddr, req)\n      // Hacky way to extract threadid from addr that succeeded\n      // @todo: Return this directly from the gRPC API?\n      const result = new Multiaddr(Buffer.from(req.getAddr_asU8()))\n        .stringTuples()\n        .filter(([key]) => key === 406)\n      return ThreadID.fromString(result[0][1])\n    }\n    throw new Error(\"No viable addresses for dialing\")\n  }\n\n  /**\n   * Returns a DBInfo objection containing metadata required to invite other peers to join a given thread.\n   * @param threadID the ID of the database\n   * @returns An object with an encoded thread key, and a list of multiaddrs.\n   *\n   * @example\n   * Get DB info and use DB info to join an existing remote thread (e.g. invited)\n   * ```typescript\n   * import {Client, DBInfo, ThreadID} from '@textile/threads'\n   *\n   * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {\n   *   return await client.getDBInfo(threadID)\n   * }\n   *\n   * async function joinFromInfo (client: Client, info: DBInfo) {\n   *   return await client.joinFromInfo(info)\n   * }\n   * ```\n   */\n  public async getDBInfo(threadID: ThreadID): Promise<DBInfo> {\n    const req = new pb.GetDBInfoRequest()\n    req.setDbid(threadID.toBytes())\n    const res = (await this.unary(\n      API.GetDBInfo,\n      req\n    )) as pb.GetDBInfoReply.AsObject\n    const threadKey = Buffer.from(res.key as string, \"base64\")\n    const key = ThreadKey.fromBytes(threadKey)\n    const addrs: string[] = []\n    for (const addr of res.addrsList) {\n      const a =\n        typeof addr === \"string\"\n          ? Buffer.from(addr, \"base64\")\n          : Buffer.from(addr)\n      const address = new Multiaddr(a).toString()\n      addrs.push(address)\n    }\n    return { key: key.toString(), addrs }\n  }\n\n  /**\n   * Creates a new model instance in the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   *\n   * @example\n   * Create a new entry in our collection\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function createBuzz (client: Client, threadID: ThreadID) {\n   *   const buzz: Astronaut = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *\n   *   await client.create(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public async create(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[]\n  ): Promise<string[]> {\n    const req = new pb.CreateRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = []\n    values.forEach((v) => {\n      list.push(encoder.encode(JSON.stringify(v)))\n    })\n    req.setInstancesList(list)\n    const res = (await this.unary(API.Create, req)) as pb.CreateReply.AsObject\n    return res.instanceidsList\n  }\n\n  /**\n   * Saves changes to an existing model instance in the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   * Each model instance must have a valid existing `_id` property.\n   *\n   * @example\n   * Update an existing instance\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function updateBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const buzz = result.instancesList[0]\n   *   buzz.missions += 1\n   *\n   *   return await client.save(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public async save(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[]\n  ): Promise<void> {\n    const req = new pb.SaveRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = []\n    values.forEach((v) => {\n      if (!v.hasOwnProperty(\"_id\")) {\n        v[\"_id\"] = \"\" // The server will add an ID if empty.\n      }\n      list.push(encoder.encode(JSON.stringify(v)))\n    })\n    req.setInstancesList(list)\n    await this.unary(API.Save, req)\n    return\n  }\n\n  /**\n   * Deletes an existing model instance from the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param IDs An array of instance ids to delete.\n   *\n   * @example\n   * Delete any instances that return from a query\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function deleteBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const ids = await result.instancesList.map((instance) => instance._id)\n   *   await client.delete(threadID, 'astronauts', ids)\n   * }\n   * ```\n   */\n  public async delete(\n    threadID: ThreadID,\n    collectionName: string,\n    IDs: string[]\n  ): Promise<void> {\n    const req = new pb.DeleteRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceidsList(IDs)\n    await this.unary(API.Delete, req)\n    return\n  }\n\n  /**\n   * Check if a given instance exists in the collection.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param IDs An array of instance ids to check for.\n   *\n   * @example\n   * Check if an instance exists\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * async function instanceExists (client: Client, threadID: ThreadID, id: string) {\n   *   return await client.has(threadID, 'astronauts', [id])\n   * }\n   * ```\n   */\n  public async has(\n    threadID: ThreadID,\n    collectionName: string,\n    IDs: string[]\n  ): Promise<boolean> {\n    const req = new pb.HasRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceidsList(IDs)\n    const res = (await this.unary(API.Has, req)) as pb.HasReply.AsObject\n    return res.exists\n  }\n\n  /**\n   * Queries a collection for entities matching the given query parameters.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param query The object that describes the query. User Query class or primitive QueryJSON type.\n   *\n   * @example\n   * Query with return type\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function getAstronautByName (client: Client, threadID: ThreadID, name: string) {\n   *   const query = new Where('name').eq(name)\n   *   const astronaut = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *   return astronaut\n   * }\n   * ```\n   */\n  public async find<T = any>(\n    threadID: ThreadID,\n    collectionName: string,\n    query: QueryJSON\n  ): Promise<InstanceList<T>> {\n    const req = new pb.FindRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    // @todo: Find a more isomorphic way to do this base64 round-trip\n    req.setQueryjson(encoder.encode(JSON.stringify(query)))\n    const res = (await this.unary(API.Find, req)) as pb.FindReply.AsObject\n    const ret: InstanceList<T> = {\n      instancesList: res.instancesList.map((instance) =>\n        JSON.parse(Buffer.from(instance as string, \"base64\").toString())\n      ),\n    }\n    return ret\n  }\n\n  /**\n   * Queries the collection by a known instance ID.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param ID The id of the instance to search for.\n   *\n   * @example\n   * Find and cast a known model by instance ID.\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function getAstronaut (client: Client, threadID: ThreadID, id: string) {\n   *   const astronaut = await client.findByID<Astronaut>(threadID, 'astronauts', id)\n   *   return astronaut\n   * }\n   * ```\n   *\n   * @example\n   * Simple find and return any instance\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function getInstance (client: Client, threadID: ThreadID, id: string) {\n   *   return await client.findByID(threadID, 'astronauts', id)\n   * }\n   * ```\n   */\n  public async findByID<T = any>(\n    threadID: ThreadID,\n    collectionName: string,\n    ID: string\n  ): Promise<Instance<T>> {\n    const req = new pb.FindByIDRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceid(ID)\n    const res = (await this.unary(\n      API.FindByID,\n      req\n    )) as pb.FindByIDReply.AsObject\n    const ret: Instance<T> = {\n      instance: JSON.parse(\n        Buffer.from(res.instance as string, \"base64\").toString()\n      ),\n    }\n    return ret\n  }\n\n  /**\n   * Verify checks existing instance changes.\n   * Each model instance must have a valid existing `_id` property.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   *\n   * @example\n   * Update an existing instance\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function verifyBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const buzz = result.instancesList[0]\n   *   buzz.missions += 1\n   *\n   *   // Is this going to be a valid update?\n   *   return await client.verify(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public async verify(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[]\n  ): Promise<Error | undefined> {\n    const req = new pb.VerifyRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = values.map((v) => encoder.encode(JSON.stringify(v)))\n    req.setInstancesList(list)\n    const { transactionerror } = (await this.unary(\n      API.Verify,\n      req\n    )) as pb.VerifyReply.AsObject\n    return transactionerror ? new Error(transactionerror) : undefined\n  }\n\n  /**\n   * readTransaction creates a new read-only transaction object. See ReadTransaction for details.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   */\n  public readTransaction(\n    threadID: ThreadID,\n    collectionName: string\n  ): ReadTransaction {\n    const client = grpc.client(API.ReadTransaction, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    }) as grpc.Client<pb.ReadTransactionRequest, pb.ReadTransactionReply>\n    return new ReadTransaction(this.context, client, threadID, collectionName)\n  }\n\n  /**\n   * writeTransaction creates a new writeable transaction object. See WriteTransaction for details.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   */\n  public writeTransaction(\n    threadID: ThreadID,\n    collectionName: string\n  ): WriteTransaction {\n    const client = grpc.client(API.WriteTransaction, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    }) as grpc.Client<pb.WriteTransactionRequest, pb.WriteTransactionReply>\n    return new WriteTransaction(this.context, client, threadID, collectionName)\n  }\n\n  /**\n   * listen opens a long-lived connection with a remote node, running the given callback on each new update to the given instance.\n   * The return value is a `close` function, which cleanly closes the connection with the remote node.\n   * @param threadID the ID of the database\n   * @param filters contains an array of Filters\n   * @param callback The callback to call on each update to the given instance.\n   *\n   * @example\n   * ```typescript\n   * import {Client, ThreadID, Update} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   * function setupListener (client: Client, threadID: ThreadID) {\n   *   const callback = (update?: Update<Astronaut>) => {\n   *     // Not safe if more than the Astronauts collection existed in the same DB\n   *     if (!update || !update.instance) return\n   *     console.log('New update:', update.instance.name, update.instance.missions)\n   *   }\n   *   const closer = client.listen(threadID, [], callback)\n   *   return closer\n   * }\n   * ```\n   *\n   * @example\n   * Listen to only CREATE events on a specific Collection.\n   * ```typescript\n   * import {Client, ThreadID, Update} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   * function setupListener (client: Client, threadID: ThreadID) {\n   *   const callback = (update?: Update<Astronaut>) => {\n   *     if (!update || !update.instance) return\n   *     console.log('New update:', update.instance.name, update.instance.missions)\n   *   }\n   *   const filters = [\n   *     {collectionName: 'Astronauts'},\n   *     {actionTypes: ['CREATE']}\n   *   ]\n   *   const closer = client.listen(threadID, filters, callback)\n   *   return closer\n   * }\n   * ```\n   */\n  public listen<T = any>(\n    threadID: ThreadID,\n    filters: Filter[],\n    callback: (reply?: Update<T>, err?: Error) => void\n  ): grpc.Request {\n    const req = new pb.ListenRequest()\n    req.setDbid(threadID.toBytes())\n    for (const filter of filters) {\n      const requestFilter = new pb.ListenRequest.Filter()\n      if (filter.instanceID) {\n        requestFilter.setInstanceid(filter.instanceID)\n      } else if (filter.collectionName) {\n        requestFilter.setCollectionname(filter.collectionName)\n      }\n      if (filter.actionTypes) {\n        for (const at of filter.actionTypes) {\n          switch (at) {\n            case \"ALL\": {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.ALL)\n              break\n            }\n            case \"CREATE\": {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.CREATE)\n              break\n            }\n            case \"SAVE\": {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.SAVE)\n              break\n            }\n            case \"DELETE\": {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.DELETE)\n              break\n            }\n          }\n        }\n      } else {\n        requestFilter.setAction(0)\n      }\n      req.addFilters(requestFilter)\n    }\n\n    const decoder = new TextDecoder()\n\n    const client = grpc.client<pb.ListenRequest, pb.ListenReply, APIListen>(\n      API.Listen,\n      {\n        host: this.serviceHost,\n        transport: this.rpcOptions.transport,\n        debug: this.rpcOptions.debug,\n      }\n    )\n    client.onMessage((message: pb.ListenReply) => {\n      // Pull it apart explicitly\n      const instanceString = decoder.decode(message.getInstance_asU8())\n      const actionInt = message.getAction()\n      const action = (Action[actionInt] as unknown) as Action\n      const collectionName = message.getCollectionname()\n      const instanceID = message.getInstanceid()\n\n      const ret: Update<T> = {\n        collectionName,\n        instanceID,\n        action,\n        instance: undefined,\n      }\n      if (instanceString !== \"\") {\n        ret.instance = JSON.parse(instanceString)\n      }\n      callback(ret)\n    })\n\n    client.onEnd((\n      status: grpc.Code,\n      message: string /** trailers: grpc.Metadata */\n    ) => {\n      if (status !== grpc.Code.OK) {\n        callback(undefined, new Error(message))\n      }\n      callback()\n    })\n\n    this.context.toMetadata().then((metadata) => {\n      client.start(metadata)\n      client.send(req)\n      client.finishSend()\n    })\n    return { close: () => client.close() }\n  }\n\n  private async unary<\n    TRequest extends grpc.ProtobufMessage,\n    TResponse extends grpc.ProtobufMessage,\n    M extends grpc.UnaryMethodDefinition<TRequest, TResponse>\n  >(methodDescriptor: M, req: TRequest) {\n    const metadata = await this.context.toMetadata()\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDescriptor, {\n        transport: this.rpcOptions.transport,\n        debug: this.rpcOptions.debug,\n        request: req,\n        host: this.serviceHost,\n        metadata,\n        onEnd: (res) => {\n          const { status, statusMessage, message } = res\n          if (status === grpc.Code.OK) {\n            if (message) {\n              resolve(message.toObject())\n            } else {\n              resolve()\n            }\n          } else {\n            reject(new Error(statusMessage))\n          }\n        },\n      })\n    })\n  }\n}\n\nexport default Client\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}