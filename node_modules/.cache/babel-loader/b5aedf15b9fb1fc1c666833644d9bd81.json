{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bucketsArchiveWatch = exports.bucketsArchiveInfo = exports.bucketsArchiveStatus = exports.bucketsArchive = exports.bucketsRemovePath = exports.bucketsRemove = exports.bucketsPullIpfsPath = exports.bucketsPullPath = exports.bucketsPushPath = exports.bucketsListIpfsPath = exports.bucketsListPath = exports.bucketsList = exports.bucketsLinks = exports.bucketsRoot = exports.bucketsInit = void 0;\n\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\n\nconst buckets_pb_1 = require(\"@textile/buckets-grpc/buckets_pb\");\n\nconst buckets_pb_service_1 = require(\"@textile/buckets-grpc/buckets_pb_service\");\n\nconst cids_1 = __importDefault(require(\"cids\"));\n\nconst event_iterator_1 = require(\"event-iterator\");\n\nconst next_tick_1 = __importDefault(require(\"next-tick\"));\n\nconst grpc_web_1 = require(\"@improbable-eng/grpc-web\");\n\nconst normalize_1 = require(\"./normalize\");\n\nconst logger = loglevel_1.default.getLogger('buckets-api');\n\nconst convertRootObject = root => {\n  return {\n    key: root.getKey(),\n    name: root.getName(),\n    path: root.getPath(),\n    createdAt: root.getCreatedat(),\n    updatedAt: root.getUpdatedat(),\n    thread: root.getThread()\n  };\n};\n\nconst convertRootObjectNullable = root => {\n  if (!root) return;\n  return convertRootObject(root);\n};\n\nconst convertPathItem = item => {\n  const list = item.getItemsList();\n  return {\n    cid: item.getCid(),\n    name: item.getName(),\n    path: item.getPath(),\n    size: item.getSize(),\n    isdir: item.getIsdir(),\n    itemsList: list ? list.map(convertPathItem) : []\n  };\n};\n\nconst convertPathItemNullable = item => {\n  if (!item) return;\n  return convertPathItem(item);\n};\n/**\n * Initializes a new bucket.\n * @public\n * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.\n * @param isPrivate encrypt the bucket contents (default `false`)\n * @example\n * Initialize a Bucket called \"app-name-files\"\n * ```tyepscript\n * import { Buckets } from '@textile/hub'\n *\n * const init = async (buckets: Buckets) => {\n *     return buckets.init(\"app-name-files\")\n * }\n * ```\n *\n * @internal\n */\n\n\nfunction bucketsInit(api, name, isPrivate = false, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('init request');\n    const req = new buckets_pb_1.InitRequest();\n    req.setName(name);\n    req.setPrivate(isPrivate);\n    const res = yield api.unary(buckets_pb_service_1.API.Init, req, ctx);\n    const links = res.getLinks();\n    return {\n      seed: res.getSeed_asU8(),\n      seedCid: res.getSeedcid(),\n      root: convertRootObjectNullable(res.getRoot()),\n      links: links ? links.toObject() : undefined\n    };\n  });\n}\n\nexports.bucketsInit = bucketsInit;\n/**\n * Returns the bucket root CID\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n *\n * @internal\n */\n\nfunction bucketsRoot(api, key, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('root request');\n    const req = new buckets_pb_1.RootRequest();\n    req.setKey(key);\n    const res = yield api.unary(buckets_pb_service_1.API.Root, req, ctx);\n    return convertRootObjectNullable(res.getRoot());\n  });\n}\n\nexports.bucketsRoot = bucketsRoot;\n/**\n * Returns a list of bucket links.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @example\n * Generate the HTTP, IPNS, and IPFS links for a Bucket\n * ```tyepscript\n * import { Buckets } from '@textile/hub'\n *\n * const getLinks = async (buckets: Buckets) => {\n *    const links = buckets.links(bucketKey)\n *    return links.ipfs\n * }\n *\n * const getIpfs = async (buckets: Buckets) => {\n *    const links = buckets.links(bucketKey)\n *    return links.ipfs\n * }\n * ```\n *\n * @internal\n */\n\nfunction bucketsLinks(api, key, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('link request');\n    const req = new buckets_pb_1.LinksRequest();\n    req.setKey(key);\n    const res = yield api.unary(buckets_pb_service_1.API.Links, req, ctx);\n    return res.toObject();\n  });\n}\n\nexports.bucketsLinks = bucketsLinks;\n/**\n * Returns a list of all bucket roots.\n * @example\n * Find an existing Bucket named \"app-name-files\"\n * ```typescript\n * import { Buckets } from '@textile/hub'\n *\n * const exists = async (buckets: Buckets) => {\n *     const roots = await buckets.list();\n *     return roots.find((bucket) => bucket.name ===  \"app-name-files\")\n * }\n * ```\n *\n * @internal\n */\n\nfunction bucketsList(api, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('list request');\n    const req = new buckets_pb_1.ListRequest();\n    const res = yield api.unary(buckets_pb_service_1.API.List, req, ctx);\n    const roots = res.getRootsList();\n    const map = roots ? roots.map(m => m).map(m => convertRootObject(m)) : [];\n    return map;\n  });\n}\n\nexports.bucketsList = bucketsList;\n/**\n * Returns information about a bucket path.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @param path A file/object (sub)-path within a bucket.\n *\n * @internal\n */\n\nfunction bucketsListPath(api, key, path, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('list path request');\n    const req = new buckets_pb_1.ListPathRequest();\n    req.setKey(key);\n    req.setPath(path);\n    const res = yield api.unary(buckets_pb_service_1.API.ListPath, req, ctx);\n    return {\n      item: convertPathItemNullable(res.getItem()),\n      root: convertRootObjectNullable(res.getRoot())\n    };\n  });\n}\n\nexports.bucketsListPath = bucketsListPath;\n/**\n * listIpfsPath returns items at a particular path in a UnixFS path living in the IPFS network.\n * @param path UnixFS path\n *\n * @internal\n */\n\nfunction bucketsListIpfsPath(api, path, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('list path request');\n    const req = new buckets_pb_1.ListIpfsPathRequest();\n    req.setPath(path);\n    const res = yield api.unary(buckets_pb_service_1.API.ListIpfsPath, req, ctx);\n    return convertPathItemNullable(res.getItem());\n  });\n}\n\nexports.bucketsListIpfsPath = bucketsListIpfsPath;\n/**\n * Pushes a file to a bucket path.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @param path A file/object (sub)-path within a bucket.\n * @param input The input file/stream/object.\n * @param opts Options to control response stream. Currently only supports a progress function.\n * @remarks\n * This will return the resolved path and the bucket's new root path.\n * Data must be broken into <4mb chunks. See bufToArray() for help.\n * @example\n * Push a file to the root of a bucket\n * ```tyepscript\n * import { Buckets } from '@textile/hub'\n *\n * const pushFile = async (content: string, bucketKey: string) => {\n *    const file = { path: '/index.html', content: Buffer.from(content) }\n *    return await buckets.pushPath(bucketKey!, 'index.html', file)\n * }\n * ```\n *\n * @internal\n */\n\nfunction bucketsPushPath(api, key, path, input, opts, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      var e_1, _a; // Only process the first  input if there are more than one\n\n\n      const source = (yield normalize_1.normaliseInput(input).next()).value;\n      const client = grpc_web_1.grpc.client(buckets_pb_service_1.API.PushPath, {\n        host: api.serviceHost,\n        transport: api.rpcOptions.transport,\n        debug: api.rpcOptions.debug\n      });\n      client.onMessage(message => {\n        var _a, _b, _c;\n\n        if (message.hasError()) {\n          // Reject on first error\n          reject(new Error(message.getError()));\n        } else if (message.hasEvent()) {\n          const event = (_a = message.getEvent()) === null || _a === void 0 ? void 0 : _a.toObject();\n\n          if (event === null || event === void 0 ? void 0 : event.path) {\n            // @todo: Is there an standard library/tool for this step in JS?\n            const pth = event.path.startsWith('/ipfs/') ? event.path.split('/ipfs/')[1] : event.path;\n            const cid = new cids_1.default(pth);\n            const res = {\n              path: {\n                path: `/ipfs/${cid.toString()}`,\n                cid: cid,\n                root: cid,\n                remainder: ''\n              },\n              root: (_c = (_b = event.root) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : ''\n            };\n            resolve(res);\n          } else if (opts === null || opts === void 0 ? void 0 : opts.progress) {\n            opts.progress(event === null || event === void 0 ? void 0 : event.bytes);\n          }\n        } else {\n          reject(new Error('Invalid reply'));\n        }\n      });\n      client.onEnd(code => {\n        if (code === grpc_web_1.grpc.Code.OK) {\n          resolve();\n        } else {\n          reject(new Error(code.toString()));\n        }\n      });\n\n      if (source) {\n        const head = new buckets_pb_1.PushPathRequest.Header();\n        head.setPath(source.path || path);\n        head.setKey(key);\n        const req = new buckets_pb_1.PushPathRequest();\n        req.setHeader(head);\n        const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());\n        client.start(metadata);\n        client.send(req);\n\n        if (source.content) {\n          try {\n            for (var _b = __asyncValues(source.content), _c; _c = yield _b.next(), !_c.done;) {\n              const chunk = _c.value;\n              const part = new buckets_pb_1.PushPathRequest();\n              part.setChunk(chunk);\n              client.send(part);\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n\n          client.finishSend();\n        }\n      }\n    }));\n  });\n}\n\nexports.bucketsPushPath = bucketsPushPath;\n/**\n * Pulls the bucket path, returning the bytes of the given file.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @param path A file/object (sub)-path within a bucket.\n * @param opts Options to control response stream. Currently only supports a progress function.\n *\n * @internal\n */\n\nfunction bucketsPullPath(api, key, path, opts, ctx) {\n  const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());\n  const request = new buckets_pb_1.PullPathRequest();\n  request.setKey(key);\n  request.setPath(path);\n  let written = 0;\n  const events = new event_iterator_1.EventIterator(({\n    push,\n    stop,\n    fail\n  }) => {\n    const resp = grpc_web_1.grpc.invoke(buckets_pb_service_1.API.PullPath, {\n      host: api.serviceHost,\n      transport: api.rpcOptions.transport,\n      debug: api.rpcOptions.debug,\n      request,\n      metadata,\n      onMessage: res => __awaiter(this, void 0, void 0, function* () {\n        const chunk = res.getChunk_asU8();\n        push(chunk);\n        written += chunk.byteLength;\n\n        if (opts === null || opts === void 0 ? void 0 : opts.progress) {\n          opts.progress(written);\n        }\n      }),\n      onEnd: (status, message, _trailers) => __awaiter(this, void 0, void 0, function* () {\n        if (status !== grpc_web_1.grpc.Code.OK) {\n          fail(new Error(message));\n        }\n\n        stop();\n      })\n    });\n    return () => resp.close();\n  });\n  const it = Object.assign({\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  }, events[Symbol.asyncIterator]());\n  return it;\n}\n\nexports.bucketsPullPath = bucketsPullPath;\n/**\n * pullIpfsPath pulls the path from a remote UnixFS dag, writing it to writer if it's a file.\n * @param path A file/object (sub)-path within a bucket.\n * @param opts Options to control response stream. Currently only supports a progress function.\n *\n * @internal\n */\n\nfunction bucketsPullIpfsPath(api, path, opts, ctx) {\n  const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());\n  const request = new buckets_pb_1.PullIpfsPathRequest();\n  request.setPath(path);\n  let written = 0;\n  const events = new event_iterator_1.EventIterator(({\n    push,\n    stop,\n    fail\n  }) => {\n    const resp = grpc_web_1.grpc.invoke(buckets_pb_service_1.API.PullIpfsPath, {\n      host: api.serviceHost,\n      transport: api.rpcOptions.transport,\n      debug: api.rpcOptions.debug,\n      request,\n      metadata,\n      onMessage: res => __awaiter(this, void 0, void 0, function* () {\n        const chunk = res.getChunk_asU8();\n        push(chunk);\n        written += chunk.byteLength;\n\n        if (opts === null || opts === void 0 ? void 0 : opts.progress) {\n          opts.progress(written);\n        }\n      }),\n      onEnd: (status, message, _trailers) => __awaiter(this, void 0, void 0, function* () {\n        if (status !== grpc_web_1.grpc.Code.OK) {\n          fail(new Error(message));\n        }\n\n        stop();\n      })\n    });\n    return () => resp.close();\n  });\n  const it = Object.assign({\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  }, events[Symbol.asyncIterator]());\n  return it;\n}\n\nexports.bucketsPullIpfsPath = bucketsPullIpfsPath;\n/**\n * Removes an entire bucket. Files and directories will be unpinned.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n *\n * @internal\n */\n\nfunction bucketsRemove(api, key, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('remove request');\n    const req = new buckets_pb_1.RemoveRequest();\n    req.setKey(key);\n    yield api.unary(buckets_pb_service_1.API.Remove, req, ctx);\n    return;\n  });\n}\n\nexports.bucketsRemove = bucketsRemove;\n/**\n * Returns information about a bucket path.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @param path A file/object (sub)-path within a bucket.\n * @param root optional to specify a root\n *\n * @internal\n */\n\nfunction bucketsRemovePath(api, key, path, root, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('remove path request');\n    const req = new buckets_pb_1.RemovePathRequest();\n    req.setKey(key);\n    req.setPath(path);\n    if (root) req.setRoot(root);\n    yield api.unary(buckets_pb_service_1.API.RemovePath, req, ctx);\n    return;\n  });\n}\n\nexports.bucketsRemovePath = bucketsRemovePath;\n/**\n * archive creates a Filecoin bucket archive via Powergate.\n * @internal\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n */\n\nfunction bucketsArchive(api, key, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('archive request');\n    const req = new buckets_pb_1.ArchiveRequest();\n    req.setKey(key);\n    yield api.unary(buckets_pb_service_1.API.Archive, req, ctx);\n    return;\n  });\n}\n\nexports.bucketsArchive = bucketsArchive;\n/**\n * archiveStatus returns the status of a Filecoin bucket archive.\n * @internal\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n */\n\nfunction bucketsArchiveStatus(api, key, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('archive status request');\n    const req = new buckets_pb_1.ArchiveStatusRequest();\n    req.setKey(key);\n    const res = yield api.unary(buckets_pb_service_1.API.ArchiveStatus, req, ctx);\n    return res.toObject();\n  });\n}\n\nexports.bucketsArchiveStatus = bucketsArchiveStatus;\n/**\n * archiveInfo returns info about a Filecoin bucket archive.\n * @internal\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n */\n\nfunction bucketsArchiveInfo(api, key, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('archive info request');\n    const req = new buckets_pb_1.ArchiveInfoRequest();\n    req.setKey(key);\n    const res = yield api.unary(buckets_pb_service_1.API.ArchiveInfo, req, ctx);\n    return res.toObject();\n  });\n}\n\nexports.bucketsArchiveInfo = bucketsArchiveInfo;\n/**\n * archiveWatch watches status events from a Filecoin bucket archive.\n * @internal\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n */\n\nfunction bucketsArchiveWatch(api, key, callback, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('archive watch request');\n    const req = new buckets_pb_1.ArchiveWatchRequest();\n    req.setKey(key);\n    const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());\n    const res = grpc_web_1.grpc.invoke(buckets_pb_service_1.API.ArchiveWatch, {\n      host: api.context.host,\n      request: req,\n      metadata,\n      onMessage: rec => {\n        const response = {\n          id: rec.getJsPbMessageId(),\n          msg: rec.getMsg()\n        };\n        next_tick_1.default(() => callback(response));\n      },\n      onEnd: (status, message, _trailers) => {\n        if (status !== grpc_web_1.grpc.Code.OK) {\n          return callback(undefined, new Error(message));\n        }\n\n        callback();\n      }\n    });\n    return res.close.bind(res);\n  });\n}\n\nexports.bucketsArchiveWatch = bucketsArchiveWatch;","map":{"version":3,"sources":["../../src/api/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bucketsArchiveWatch = exports.bucketsArchiveInfo = exports.bucketsArchiveStatus = exports.bucketsArchive = exports.bucketsRemovePath = exports.bucketsRemove = exports.bucketsPullIpfsPath = exports.bucketsPullPath = exports.bucketsPushPath = exports.bucketsListIpfsPath = exports.bucketsListPath = exports.bucketsList = exports.bucketsLinks = exports.bucketsRoot = exports.bucketsInit = void 0;\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\nconst buckets_pb_1 = require(\"@textile/buckets-grpc/buckets_pb\");\nconst buckets_pb_service_1 = require(\"@textile/buckets-grpc/buckets_pb_service\");\nconst cids_1 = __importDefault(require(\"cids\"));\nconst event_iterator_1 = require(\"event-iterator\");\nconst next_tick_1 = __importDefault(require(\"next-tick\"));\nconst grpc_web_1 = require(\"@improbable-eng/grpc-web\");\nconst normalize_1 = require(\"./normalize\");\nconst logger = loglevel_1.default.getLogger('buckets-api');\nconst convertRootObject = (root) => {\n    return {\n        key: root.getKey(),\n        name: root.getName(),\n        path: root.getPath(),\n        createdAt: root.getCreatedat(),\n        updatedAt: root.getUpdatedat(),\n        thread: root.getThread(),\n    };\n};\nconst convertRootObjectNullable = (root) => {\n    if (!root)\n        return;\n    return convertRootObject(root);\n};\nconst convertPathItem = (item) => {\n    const list = item.getItemsList();\n    return {\n        cid: item.getCid(),\n        name: item.getName(),\n        path: item.getPath(),\n        size: item.getSize(),\n        isdir: item.getIsdir(),\n        itemsList: list ? list.map(convertPathItem) : [],\n    };\n};\nconst convertPathItemNullable = (item) => {\n    if (!item)\n        return;\n    return convertPathItem(item);\n};\n/**\n * Initializes a new bucket.\n * @public\n * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.\n * @param isPrivate encrypt the bucket contents (default `false`)\n * @example\n * Initialize a Bucket called \"app-name-files\"\n * ```tyepscript\n * import { Buckets } from '@textile/hub'\n *\n * const init = async (buckets: Buckets) => {\n *     return buckets.init(\"app-name-files\")\n * }\n * ```\n *\n * @internal\n */\nfunction bucketsInit(api, name, isPrivate = false, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('init request');\n        const req = new buckets_pb_1.InitRequest();\n        req.setName(name);\n        req.setPrivate(isPrivate);\n        const res = yield api.unary(buckets_pb_service_1.API.Init, req, ctx);\n        const links = res.getLinks();\n        return {\n            seed: res.getSeed_asU8(),\n            seedCid: res.getSeedcid(),\n            root: convertRootObjectNullable(res.getRoot()),\n            links: links ? links.toObject() : undefined,\n        };\n    });\n}\nexports.bucketsInit = bucketsInit;\n/**\n * Returns the bucket root CID\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n *\n * @internal\n */\nfunction bucketsRoot(api, key, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('root request');\n        const req = new buckets_pb_1.RootRequest();\n        req.setKey(key);\n        const res = yield api.unary(buckets_pb_service_1.API.Root, req, ctx);\n        return convertRootObjectNullable(res.getRoot());\n    });\n}\nexports.bucketsRoot = bucketsRoot;\n/**\n * Returns a list of bucket links.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @example\n * Generate the HTTP, IPNS, and IPFS links for a Bucket\n * ```tyepscript\n * import { Buckets } from '@textile/hub'\n *\n * const getLinks = async (buckets: Buckets) => {\n *    const links = buckets.links(bucketKey)\n *    return links.ipfs\n * }\n *\n * const getIpfs = async (buckets: Buckets) => {\n *    const links = buckets.links(bucketKey)\n *    return links.ipfs\n * }\n * ```\n *\n * @internal\n */\nfunction bucketsLinks(api, key, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('link request');\n        const req = new buckets_pb_1.LinksRequest();\n        req.setKey(key);\n        const res = yield api.unary(buckets_pb_service_1.API.Links, req, ctx);\n        return res.toObject();\n    });\n}\nexports.bucketsLinks = bucketsLinks;\n/**\n * Returns a list of all bucket roots.\n * @example\n * Find an existing Bucket named \"app-name-files\"\n * ```typescript\n * import { Buckets } from '@textile/hub'\n *\n * const exists = async (buckets: Buckets) => {\n *     const roots = await buckets.list();\n *     return roots.find((bucket) => bucket.name ===  \"app-name-files\")\n * }\n * ```\n *\n * @internal\n */\nfunction bucketsList(api, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('list request');\n        const req = new buckets_pb_1.ListRequest();\n        const res = yield api.unary(buckets_pb_service_1.API.List, req, ctx);\n        const roots = res.getRootsList();\n        const map = roots ? roots.map((m) => m).map((m) => convertRootObject(m)) : [];\n        return map;\n    });\n}\nexports.bucketsList = bucketsList;\n/**\n * Returns information about a bucket path.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @param path A file/object (sub)-path within a bucket.\n *\n * @internal\n */\nfunction bucketsListPath(api, key, path, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('list path request');\n        const req = new buckets_pb_1.ListPathRequest();\n        req.setKey(key);\n        req.setPath(path);\n        const res = yield api.unary(buckets_pb_service_1.API.ListPath, req, ctx);\n        return {\n            item: convertPathItemNullable(res.getItem()),\n            root: convertRootObjectNullable(res.getRoot()),\n        };\n    });\n}\nexports.bucketsListPath = bucketsListPath;\n/**\n * listIpfsPath returns items at a particular path in a UnixFS path living in the IPFS network.\n * @param path UnixFS path\n *\n * @internal\n */\nfunction bucketsListIpfsPath(api, path, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('list path request');\n        const req = new buckets_pb_1.ListIpfsPathRequest();\n        req.setPath(path);\n        const res = yield api.unary(buckets_pb_service_1.API.ListIpfsPath, req, ctx);\n        return convertPathItemNullable(res.getItem());\n    });\n}\nexports.bucketsListIpfsPath = bucketsListIpfsPath;\n/**\n * Pushes a file to a bucket path.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @param path A file/object (sub)-path within a bucket.\n * @param input The input file/stream/object.\n * @param opts Options to control response stream. Currently only supports a progress function.\n * @remarks\n * This will return the resolved path and the bucket's new root path.\n * Data must be broken into <4mb chunks. See bufToArray() for help.\n * @example\n * Push a file to the root of a bucket\n * ```tyepscript\n * import { Buckets } from '@textile/hub'\n *\n * const pushFile = async (content: string, bucketKey: string) => {\n *    const file = { path: '/index.html', content: Buffer.from(content) }\n *    return await buckets.pushPath(bucketKey!, 'index.html', file)\n * }\n * ```\n *\n * @internal\n */\nfunction bucketsPushPath(api, key, path, input, opts, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            var e_1, _a;\n            // Only process the first  input if there are more than one\n            const source = (yield normalize_1.normaliseInput(input).next()).value;\n            const client = grpc_web_1.grpc.client(buckets_pb_service_1.API.PushPath, {\n                host: api.serviceHost,\n                transport: api.rpcOptions.transport,\n                debug: api.rpcOptions.debug,\n            });\n            client.onMessage((message) => {\n                var _a, _b, _c;\n                if (message.hasError()) {\n                    // Reject on first error\n                    reject(new Error(message.getError()));\n                }\n                else if (message.hasEvent()) {\n                    const event = (_a = message.getEvent()) === null || _a === void 0 ? void 0 : _a.toObject();\n                    if (event === null || event === void 0 ? void 0 : event.path) {\n                        // @todo: Is there an standard library/tool for this step in JS?\n                        const pth = event.path.startsWith('/ipfs/') ? event.path.split('/ipfs/')[1] : event.path;\n                        const cid = new cids_1.default(pth);\n                        const res = {\n                            path: {\n                                path: `/ipfs/${cid.toString()}`,\n                                cid: cid,\n                                root: cid,\n                                remainder: '',\n                            },\n                            root: (_c = (_b = event.root) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : '',\n                        };\n                        resolve(res);\n                    }\n                    else if (opts === null || opts === void 0 ? void 0 : opts.progress) {\n                        opts.progress(event === null || event === void 0 ? void 0 : event.bytes);\n                    }\n                }\n                else {\n                    reject(new Error('Invalid reply'));\n                }\n            });\n            client.onEnd((code) => {\n                if (code === grpc_web_1.grpc.Code.OK) {\n                    resolve();\n                }\n                else {\n                    reject(new Error(code.toString()));\n                }\n            });\n            if (source) {\n                const head = new buckets_pb_1.PushPathRequest.Header();\n                head.setPath(source.path || path);\n                head.setKey(key);\n                const req = new buckets_pb_1.PushPathRequest();\n                req.setHeader(head);\n                const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());\n                client.start(metadata);\n                client.send(req);\n                if (source.content) {\n                    try {\n                        for (var _b = __asyncValues(source.content), _c; _c = yield _b.next(), !_c.done;) {\n                            const chunk = _c.value;\n                            const part = new buckets_pb_1.PushPathRequest();\n                            part.setChunk(chunk);\n                            client.send(part);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    client.finishSend();\n                }\n            }\n        }));\n    });\n}\nexports.bucketsPushPath = bucketsPushPath;\n/**\n * Pulls the bucket path, returning the bytes of the given file.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @param path A file/object (sub)-path within a bucket.\n * @param opts Options to control response stream. Currently only supports a progress function.\n *\n * @internal\n */\nfunction bucketsPullPath(api, key, path, opts, ctx) {\n    const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());\n    const request = new buckets_pb_1.PullPathRequest();\n    request.setKey(key);\n    request.setPath(path);\n    let written = 0;\n    const events = new event_iterator_1.EventIterator(({ push, stop, fail }) => {\n        const resp = grpc_web_1.grpc.invoke(buckets_pb_service_1.API.PullPath, {\n            host: api.serviceHost,\n            transport: api.rpcOptions.transport,\n            debug: api.rpcOptions.debug,\n            request,\n            metadata,\n            onMessage: (res) => __awaiter(this, void 0, void 0, function* () {\n                const chunk = res.getChunk_asU8();\n                push(chunk);\n                written += chunk.byteLength;\n                if (opts === null || opts === void 0 ? void 0 : opts.progress) {\n                    opts.progress(written);\n                }\n            }),\n            onEnd: (status, message, _trailers) => __awaiter(this, void 0, void 0, function* () {\n                if (status !== grpc_web_1.grpc.Code.OK) {\n                    fail(new Error(message));\n                }\n                stop();\n            }),\n        });\n        return () => resp.close();\n    });\n    const it = Object.assign({ [Symbol.asyncIterator]() {\n            return this;\n        } }, events[Symbol.asyncIterator]());\n    return it;\n}\nexports.bucketsPullPath = bucketsPullPath;\n/**\n * pullIpfsPath pulls the path from a remote UnixFS dag, writing it to writer if it's a file.\n * @param path A file/object (sub)-path within a bucket.\n * @param opts Options to control response stream. Currently only supports a progress function.\n *\n * @internal\n */\nfunction bucketsPullIpfsPath(api, path, opts, ctx) {\n    const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());\n    const request = new buckets_pb_1.PullIpfsPathRequest();\n    request.setPath(path);\n    let written = 0;\n    const events = new event_iterator_1.EventIterator(({ push, stop, fail }) => {\n        const resp = grpc_web_1.grpc.invoke(buckets_pb_service_1.API.PullIpfsPath, {\n            host: api.serviceHost,\n            transport: api.rpcOptions.transport,\n            debug: api.rpcOptions.debug,\n            request,\n            metadata,\n            onMessage: (res) => __awaiter(this, void 0, void 0, function* () {\n                const chunk = res.getChunk_asU8();\n                push(chunk);\n                written += chunk.byteLength;\n                if (opts === null || opts === void 0 ? void 0 : opts.progress) {\n                    opts.progress(written);\n                }\n            }),\n            onEnd: (status, message, _trailers) => __awaiter(this, void 0, void 0, function* () {\n                if (status !== grpc_web_1.grpc.Code.OK) {\n                    fail(new Error(message));\n                }\n                stop();\n            }),\n        });\n        return () => resp.close();\n    });\n    const it = Object.assign({ [Symbol.asyncIterator]() {\n            return this;\n        } }, events[Symbol.asyncIterator]());\n    return it;\n}\nexports.bucketsPullIpfsPath = bucketsPullIpfsPath;\n/**\n * Removes an entire bucket. Files and directories will be unpinned.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n *\n * @internal\n */\nfunction bucketsRemove(api, key, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('remove request');\n        const req = new buckets_pb_1.RemoveRequest();\n        req.setKey(key);\n        yield api.unary(buckets_pb_service_1.API.Remove, req, ctx);\n        return;\n    });\n}\nexports.bucketsRemove = bucketsRemove;\n/**\n * Returns information about a bucket path.\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n * @param path A file/object (sub)-path within a bucket.\n * @param root optional to specify a root\n *\n * @internal\n */\nfunction bucketsRemovePath(api, key, path, root, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('remove path request');\n        const req = new buckets_pb_1.RemovePathRequest();\n        req.setKey(key);\n        req.setPath(path);\n        if (root)\n            req.setRoot(root);\n        yield api.unary(buckets_pb_service_1.API.RemovePath, req, ctx);\n        return;\n    });\n}\nexports.bucketsRemovePath = bucketsRemovePath;\n/**\n * archive creates a Filecoin bucket archive via Powergate.\n * @internal\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n */\nfunction bucketsArchive(api, key, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('archive request');\n        const req = new buckets_pb_1.ArchiveRequest();\n        req.setKey(key);\n        yield api.unary(buckets_pb_service_1.API.Archive, req, ctx);\n        return;\n    });\n}\nexports.bucketsArchive = bucketsArchive;\n/**\n * archiveStatus returns the status of a Filecoin bucket archive.\n * @internal\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n */\nfunction bucketsArchiveStatus(api, key, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('archive status request');\n        const req = new buckets_pb_1.ArchiveStatusRequest();\n        req.setKey(key);\n        const res = yield api.unary(buckets_pb_service_1.API.ArchiveStatus, req, ctx);\n        return res.toObject();\n    });\n}\nexports.bucketsArchiveStatus = bucketsArchiveStatus;\n/**\n * archiveInfo returns info about a Filecoin bucket archive.\n * @internal\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n */\nfunction bucketsArchiveInfo(api, key, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('archive info request');\n        const req = new buckets_pb_1.ArchiveInfoRequest();\n        req.setKey(key);\n        const res = yield api.unary(buckets_pb_service_1.API.ArchiveInfo, req, ctx);\n        return res.toObject();\n    });\n}\nexports.bucketsArchiveInfo = bucketsArchiveInfo;\n/**\n * archiveWatch watches status events from a Filecoin bucket archive.\n * @internal\n * @param key Unique (IPNS compatible) identifier key for a bucket.\n */\nfunction bucketsArchiveWatch(api, key, callback, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('archive watch request');\n        const req = new buckets_pb_1.ArchiveWatchRequest();\n        req.setKey(key);\n        const metadata = Object.assign(Object.assign({}, api.context.toJSON()), ctx === null || ctx === void 0 ? void 0 : ctx.toJSON());\n        const res = grpc_web_1.grpc.invoke(buckets_pb_service_1.API.ArchiveWatch, {\n            host: api.context.host,\n            request: req,\n            metadata,\n            onMessage: (rec) => {\n                const response = {\n                    id: rec.getJsPbMessageId(),\n                    msg: rec.getMsg(),\n                };\n                next_tick_1.default(() => callback(response));\n            },\n            onEnd: (status, message, _trailers) => {\n                if (status !== grpc_web_1.grpc.Code.OK) {\n                    return callback(undefined, new Error(message));\n                }\n                callback();\n            },\n        });\n        return res.close.bind(res);\n    });\n}\nexports.bucketsArchiveWatch = bucketsArchiveWatch;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}