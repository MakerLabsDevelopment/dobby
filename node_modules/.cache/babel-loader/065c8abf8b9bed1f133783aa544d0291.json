{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractPublicKeyBytes = exports.privateKeyFromString = exports.publicKeyBytesFromString = exports.publicKeyToString = exports.publicKeyBytesToString = exports.encrypt = exports.decrypt = void 0;\n\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\n\nconst ed2curve_1 = require(\"ed2curve\");\n\nconst multibase_1 = __importDefault(require(\"multibase\"));\n\nconst proto_keys_1 = require(\"./proto.keys\");\n\nconst nonceBytes = 24; // Length of nacl nonce\n\nconst privateKeyBytes = 32;\nconst publicKeyBytes = 32; // Length of nacl ephemeral public key\n\n/**\n * Decrypts the given `data` using a Curve25519 variant of the private key.\n *\n * Assumes ciphertext includes ephemeral public key and nonce used in original\n * encryption (e.g., via {@link encrypt} function).\n *\n * @see {@link https://github.com/dchest/ed2curve-js} for conversion details.\n * @param ciphertext Data to decrypt.\n */\n\nfunction decrypt(ciphertext, privKey, type = 'ed25519') {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (type !== 'ed25519') {\n      throw Error(`'${type}' type keys are not currently supported`);\n    }\n\n    const pk = ed2curve_1.convertSecretKey(privKey);\n\n    if (!pk) {\n      throw Error('could not convert key type');\n    }\n\n    const nonce = ciphertext.slice(0, nonceBytes);\n    const ephemeral = ciphertext.slice(nonceBytes, nonceBytes + publicKeyBytes);\n    const ct = ciphertext.slice(nonceBytes + publicKeyBytes);\n    const plaintext = tweetnacl_1.default.box.open(ct, nonce, ephemeral, pk);\n\n    if (!plaintext) {\n      throw Error('failed to decrypt curve25519');\n    }\n\n    return Uint8Array.from(plaintext);\n  });\n}\n\nexports.decrypt = decrypt;\n/**\n * Encrypts the given `data` using a Curve25519 variant of the public key.\n *\n * The encryption uses an ephemeral private key, which is prepended to the\n * ciphertext, along with a nonce of random bytes.\n *\n * @see {@link https://github.com/dchest/ed2curve-js} for conversion details.\n * @param data Data to encrypt.\n */\n\nfunction encrypt(data, pubKey, type = 'ed25519') {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (type !== 'ed25519') {\n      throw Error(`'${type}' type keys are not currently supported`);\n    } // generated ephemeral key pair\n\n\n    const ephemeral = tweetnacl_1.default.box.keyPair(); // convert recipient's key into curve25519 (assumes ed25519 keys)\n\n    const pk = ed2curve_1.convertPublicKey(pubKey);\n\n    if (!pk) {\n      throw Error('could not convert key type');\n    } // encrypt with nacl\n\n\n    const nonce = tweetnacl_1.default.randomBytes(24);\n    const ciphertext = tweetnacl_1.default.box(data, nonce, pk, ephemeral.secretKey);\n    const merged = new Uint8Array(nonceBytes + publicKeyBytes + ciphertext.byteLength); // prepend nonce\n\n    merged.set(new Uint8Array(nonce), 0); // then ephemeral public key\n\n    merged.set(new Uint8Array(ephemeral.publicKey), nonceBytes); // then cipher text\n\n    merged.set(new Uint8Array(ciphertext), nonceBytes + publicKeyBytes);\n    return Uint8Array.from(merged);\n  });\n}\n\nexports.encrypt = encrypt;\n/**\n * Encode the given PublicKey's protobuf-encoded bytes to its base-32 encoded\n * multibase representation.\n * @param bytes The protobuf-encoded bytes of a {@link Public} key.\n */\n\nfunction publicKeyBytesToString(bytes) {\n  const encoded = multibase_1.default.encode('base32', bytes);\n  return new TextDecoder().decode(encoded);\n}\n\nexports.publicKeyBytesToString = publicKeyBytesToString;\n/**\n * Encode the given PublicKey to its base-32 encoded multibase representation.\n * @param key The {@link Public} key to encode.\n */\n\nfunction publicKeyToString(key) {\n  return publicKeyBytesToString(key.bytes);\n}\n\nexports.publicKeyToString = publicKeyToString;\n/**\n * Decode the given base-32 encoded multibase string into a {@link Public} key.\n * @param str The base-32 encoded multibase string.\n */\n\nfunction publicKeyBytesFromString(str) {\n  const decoded = multibase_1.default.decode(str);\n  const obj = proto_keys_1.decodePublicKey(decoded);\n  const bytes = obj.Data;\n  return bytes.slice(0, publicKeyBytes);\n}\n\nexports.publicKeyBytesFromString = publicKeyBytesFromString;\n/**\n * Decode the given base-32 encoded multibase string into a {@link Private} key.\n * @param str The base-32 encoded multibase string.\n */\n\nfunction privateKeyFromString(str) {\n  const decoded = multibase_1.default.decode(str);\n  const obj = proto_keys_1.decodePrivateKey(decoded);\n  const bytes = obj.Data; // We might have the public key bytes appended twice, but we can ignore the\n  // extra public bytes on the end (no need to check it either)\n\n  return bytes.slice(0, privateKeyBytes);\n}\n\nexports.privateKeyFromString = privateKeyFromString;\n/**\n * Utility function to extract the raw bytes from a {@link Public} key.\n * @param key The public key from which to extract raw bytes.\n */\n\nfunction extractPublicKeyBytes(key) {\n  const obj = proto_keys_1.decodePublicKey(key.bytes);\n  const bytes = obj.Data;\n  return bytes.slice(0, publicKeyBytes);\n}\n\nexports.extractPublicKeyBytes = extractPublicKeyBytes;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractPublicKeyBytes = exports.privateKeyFromString = exports.publicKeyBytesFromString = exports.publicKeyToString = exports.publicKeyBytesToString = exports.encrypt = exports.decrypt = void 0;\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst ed2curve_1 = require(\"ed2curve\");\nconst multibase_1 = __importDefault(require(\"multibase\"));\nconst proto_keys_1 = require(\"./proto.keys\");\nconst nonceBytes = 24; // Length of nacl nonce\nconst privateKeyBytes = 32;\nconst publicKeyBytes = 32; // Length of nacl ephemeral public key\n/**\n * Decrypts the given `data` using a Curve25519 variant of the private key.\n *\n * Assumes ciphertext includes ephemeral public key and nonce used in original\n * encryption (e.g., via {@link encrypt} function).\n *\n * @see {@link https://github.com/dchest/ed2curve-js} for conversion details.\n * @param ciphertext Data to decrypt.\n */\nfunction decrypt(ciphertext, privKey, type = 'ed25519') {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (type !== 'ed25519') {\n            throw Error(`'${type}' type keys are not currently supported`);\n        }\n        const pk = ed2curve_1.convertSecretKey(privKey);\n        if (!pk) {\n            throw Error('could not convert key type');\n        }\n        const nonce = ciphertext.slice(0, nonceBytes);\n        const ephemeral = ciphertext.slice(nonceBytes, nonceBytes + publicKeyBytes);\n        const ct = ciphertext.slice(nonceBytes + publicKeyBytes);\n        const plaintext = tweetnacl_1.default.box.open(ct, nonce, ephemeral, pk);\n        if (!plaintext) {\n            throw Error('failed to decrypt curve25519');\n        }\n        return Uint8Array.from(plaintext);\n    });\n}\nexports.decrypt = decrypt;\n/**\n * Encrypts the given `data` using a Curve25519 variant of the public key.\n *\n * The encryption uses an ephemeral private key, which is prepended to the\n * ciphertext, along with a nonce of random bytes.\n *\n * @see {@link https://github.com/dchest/ed2curve-js} for conversion details.\n * @param data Data to encrypt.\n */\nfunction encrypt(data, pubKey, type = 'ed25519') {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (type !== 'ed25519') {\n            throw Error(`'${type}' type keys are not currently supported`);\n        }\n        // generated ephemeral key pair\n        const ephemeral = tweetnacl_1.default.box.keyPair();\n        // convert recipient's key into curve25519 (assumes ed25519 keys)\n        const pk = ed2curve_1.convertPublicKey(pubKey);\n        if (!pk) {\n            throw Error('could not convert key type');\n        }\n        // encrypt with nacl\n        const nonce = tweetnacl_1.default.randomBytes(24);\n        const ciphertext = tweetnacl_1.default.box(data, nonce, pk, ephemeral.secretKey);\n        const merged = new Uint8Array(nonceBytes + publicKeyBytes + ciphertext.byteLength);\n        // prepend nonce\n        merged.set(new Uint8Array(nonce), 0);\n        // then ephemeral public key\n        merged.set(new Uint8Array(ephemeral.publicKey), nonceBytes);\n        // then cipher text\n        merged.set(new Uint8Array(ciphertext), nonceBytes + publicKeyBytes);\n        return Uint8Array.from(merged);\n    });\n}\nexports.encrypt = encrypt;\n/**\n * Encode the given PublicKey's protobuf-encoded bytes to its base-32 encoded\n * multibase representation.\n * @param bytes The protobuf-encoded bytes of a {@link Public} key.\n */\nfunction publicKeyBytesToString(bytes) {\n    const encoded = multibase_1.default.encode('base32', bytes);\n    return new TextDecoder().decode(encoded);\n}\nexports.publicKeyBytesToString = publicKeyBytesToString;\n/**\n * Encode the given PublicKey to its base-32 encoded multibase representation.\n * @param key The {@link Public} key to encode.\n */\nfunction publicKeyToString(key) {\n    return publicKeyBytesToString(key.bytes);\n}\nexports.publicKeyToString = publicKeyToString;\n/**\n * Decode the given base-32 encoded multibase string into a {@link Public} key.\n * @param str The base-32 encoded multibase string.\n */\nfunction publicKeyBytesFromString(str) {\n    const decoded = multibase_1.default.decode(str);\n    const obj = proto_keys_1.decodePublicKey(decoded);\n    const bytes = obj.Data;\n    return bytes.slice(0, publicKeyBytes);\n}\nexports.publicKeyBytesFromString = publicKeyBytesFromString;\n/**\n * Decode the given base-32 encoded multibase string into a {@link Private} key.\n * @param str The base-32 encoded multibase string.\n */\nfunction privateKeyFromString(str) {\n    const decoded = multibase_1.default.decode(str);\n    const obj = proto_keys_1.decodePrivateKey(decoded);\n    const bytes = obj.Data;\n    // We might have the public key bytes appended twice, but we can ignore the\n    // extra public bytes on the end (no need to check it either)\n    return bytes.slice(0, privateKeyBytes);\n}\nexports.privateKeyFromString = privateKeyFromString;\n/**\n * Utility function to extract the raw bytes from a {@link Public} key.\n * @param key The public key from which to extract raw bytes.\n */\nfunction extractPublicKeyBytes(key) {\n    const obj = proto_keys_1.decodePublicKey(key.bytes);\n    const bytes = obj.Data;\n    return bytes.slice(0, publicKeyBytes);\n}\nexports.extractPublicKeyBytes = extractPublicKeyBytes;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}