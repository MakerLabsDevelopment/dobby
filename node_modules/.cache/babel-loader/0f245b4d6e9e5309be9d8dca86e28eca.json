{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WriteTransaction = void 0;\n\nconst threads_pb_1 = require(\"@textile/threads-client-grpc/threads_pb\");\n\nconst Transaction_1 = require(\"./Transaction\");\n/**\n * WriteTransaction performs a mutating bulk transaction on the underlying store.\n */\n\n\nclass WriteTransaction extends Transaction_1.Transaction {\n  constructor(context, client, threadID, modelName) {\n    super(client, threadID, modelName);\n    this.context = context;\n    this.client = client;\n    this.threadID = threadID;\n    this.modelName = modelName;\n  }\n  /**\n   * start begins the transaction. All operations between start and end will be applied as a single transaction upon a call to end.\n   */\n\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const startReq = new threads_pb_1.StartTransactionRequest();\n      startReq.setDbid(this.threadID.toBytes());\n      startReq.setCollectionname(this.modelName);\n      const req = new threads_pb_1.WriteTransactionRequest();\n      req.setStarttransactionrequest(startReq);\n      const metadata = JSON.parse(JSON.stringify(this.context));\n      this.client.start(metadata);\n      this.client.send(req);\n    });\n  }\n  /**\n   * create creates a new model instance in the given store.\n   * @param values An array of model instances as JSON/JS objects.\n   */\n\n\n  create(values) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const createReq = new threads_pb_1.CreateRequest();\n        const list = [];\n        values.forEach(v => {\n          list.push(Buffer.from(JSON.stringify(v)));\n        });\n        createReq.setInstancesList(list);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setCreaterequest(createReq);\n        this.client.onMessage(message => {\n          const reply = message.getCreatereply();\n\n          if (reply === undefined) {\n            resolve();\n          } else {\n            resolve(reply.toObject().instanceidsList);\n          }\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * save saves changes to an existing model instance in the given store.\n   * @param values An array of model instances as JSON/JS objects. Each model instance must have a valid existing `ID` property.\n   */\n\n\n  save(values) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const saveReq = new threads_pb_1.SaveRequest();\n        const list = [];\n        values.forEach(v => {\n          if (!v.hasOwnProperty(\"ID\")) {\n            v[\"ID\"] = \"\"; // The server will add an ID if empty.\n          }\n\n          list.push(Buffer.from(JSON.stringify(v)));\n        });\n        saveReq.setInstancesList(list);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setSaverequest(saveReq);\n        this.client.onMessage(() =>\n        /** message: WriteTransactionReply */\n        {\n          resolve();\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * delete deletes an existing model instance from the given store.\n   * @param IDs An array of instance ids to delete.\n   */\n\n\n  delete(IDs) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const deleteReq = new threads_pb_1.DeleteRequest();\n        deleteReq.setInstanceidsList(IDs);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setDeleterequest(deleteReq);\n        this.client.onMessage(() =>\n        /** message: WriteTransactionReply */\n        {\n          resolve();\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * has checks whether a given instance exists in the given store.\n   * @param IDs An array of instance ids to check for.\n   */\n\n\n  has(IDs) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const hasReq = new threads_pb_1.HasRequest();\n        hasReq.setInstanceidsList(IDs);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setHasrequest(hasReq);\n        this.client.onMessage(message => {\n          const reply = message.getHasreply();\n          resolve(reply ? reply.toObject().exists == true : false);\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * find queries the store for entities matching the given query parameters. See Query for options.\n   * @param query The object that describes the query. See Query for options. Alternatively, see QueryJSON for the basic interface.\n   */\n\n\n  find(query) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const findReq = new threads_pb_1.FindRequest();\n        findReq.setQueryjson(Buffer.from(JSON.stringify(query)));\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setFindrequest(findReq);\n        this.client.onMessage(message => {\n          const reply = message.getFindreply();\n\n          if (reply === undefined) {\n            resolve();\n          } else {\n            const ret = {\n              instancesList: reply.toObject().instancesList.map(instance => JSON.parse(Buffer.from(instance, \"base64\").toString()))\n            };\n            resolve(ret);\n          }\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * findByID queries the store for the id of an instance.\n   * @param ID The id of the instance to search for.\n   */\n\n\n  findByID(ID) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const findReq = new threads_pb_1.FindByIDRequest();\n        findReq.setInstanceid(ID);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setFindbyidrequest(findReq);\n        this.client.onMessage(message => {\n          const reply = message.getFindbyidreply();\n\n          if (reply === undefined) {\n            resolve();\n          } else {\n            const ret = {\n              instance: JSON.parse(Buffer.from(reply.toObject().instance, \"base64\").toString())\n            };\n            resolve(ret);\n          }\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n\n}\n\nexports.WriteTransaction = WriteTransaction;","map":{"version":3,"sources":["../../src/models/WriteTransaction.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module @textile/threads-client/models\n */\nimport { grpc } from \"@improbable-eng/grpc-web\"\nimport { ContextInterface } from \"@textile/context\"\nimport {\n  CreateRequest,\n  DeleteRequest,\n  FindByIDRequest,\n  FindRequest,\n  HasRequest,\n  SaveRequest,\n  StartTransactionRequest,\n  WriteTransactionReply,\n  WriteTransactionRequest,\n} from \"@textile/threads-client-grpc/threads_pb\"\nimport { ThreadID } from \"@textile/threads-id\"\nimport { Instance, InstanceList, QueryJSON } from \"./query\"\nimport { Transaction } from \"./Transaction\"\n\n/**\n * WriteTransaction performs a mutating bulk transaction on the underlying store.\n */\nexport class WriteTransaction extends Transaction<\n  WriteTransactionRequest,\n  WriteTransactionReply\n> {\n  constructor(\n    protected readonly context: ContextInterface,\n    protected readonly client: grpc.Client<\n      WriteTransactionRequest,\n      WriteTransactionReply\n    >,\n    protected readonly threadID: ThreadID,\n    protected readonly modelName: string\n  ) {\n    super(client, threadID, modelName)\n  }\n  /**\n   * start begins the transaction. All operations between start and end will be applied as a single transaction upon a call to end.\n   */\n  public async start(): Promise<void> {\n    const startReq = new StartTransactionRequest()\n    startReq.setDbid(this.threadID.toBytes())\n    startReq.setCollectionname(this.modelName)\n    const req = new WriteTransactionRequest()\n    req.setStarttransactionrequest(startReq)\n    const metadata = JSON.parse(JSON.stringify(this.context))\n    this.client.start(metadata)\n    this.client.send(req)\n  }\n  /**\n   * create creates a new model instance in the given store.\n   * @param values An array of model instances as JSON/JS objects.\n   */\n  public async create<T = any>(values: any[]): Promise<string[] | undefined> {\n    return new Promise<Array<string> | undefined>((resolve, reject) => {\n      const createReq = new CreateRequest()\n      const list: any[] = []\n      values.forEach((v) => {\n        list.push(Buffer.from(JSON.stringify(v)))\n      })\n      createReq.setInstancesList(list)\n      const req = new WriteTransactionRequest()\n      req.setCreaterequest(createReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getCreatereply()\n        if (reply === undefined) {\n          resolve()\n        } else {\n          resolve(reply.toObject().instanceidsList)\n        }\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * save saves changes to an existing model instance in the given store.\n   * @param values An array of model instances as JSON/JS objects. Each model instance must have a valid existing `ID` property.\n   */\n  public async save(values: any[]): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const saveReq = new SaveRequest()\n      const list: any[] = []\n      values.forEach((v) => {\n        if (!v.hasOwnProperty(\"ID\")) {\n          v[\"ID\"] = \"\" // The server will add an ID if empty.\n        }\n        list.push(Buffer.from(JSON.stringify(v)))\n      })\n      saveReq.setInstancesList(list)\n      const req = new WriteTransactionRequest()\n      req.setSaverequest(saveReq)\n      this.client.onMessage((/** message: WriteTransactionReply */) => {\n        resolve()\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * delete deletes an existing model instance from the given store.\n   * @param IDs An array of instance ids to delete.\n   */\n  public async delete(IDs: string[]): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const deleteReq = new DeleteRequest()\n      deleteReq.setInstanceidsList(IDs)\n      const req = new WriteTransactionRequest()\n      req.setDeleterequest(deleteReq)\n      this.client.onMessage((/** message: WriteTransactionReply */) => {\n        resolve()\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n  /**\n   * has checks whether a given instance exists in the given store.\n   * @param IDs An array of instance ids to check for.\n   */\n  public async has(IDs: string[]): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      const hasReq = new HasRequest()\n      hasReq.setInstanceidsList(IDs)\n      const req = new WriteTransactionRequest()\n      req.setHasrequest(hasReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getHasreply()\n        resolve(reply ? reply.toObject().exists == true : false)\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n  /**\n   * find queries the store for entities matching the given query parameters. See Query for options.\n   * @param query The object that describes the query. See Query for options. Alternatively, see QueryJSON for the basic interface.\n   */\n  public async find<T = any>(query: QueryJSON): Promise<InstanceList<T>> {\n    return new Promise<InstanceList<T>>((resolve, reject) => {\n      const findReq = new FindRequest()\n      findReq.setQueryjson(Buffer.from(JSON.stringify(query)))\n      const req = new WriteTransactionRequest()\n      req.setFindrequest(findReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getFindreply()\n        if (reply === undefined) {\n          resolve()\n        } else {\n          const ret: InstanceList<T> = {\n            instancesList: reply\n              .toObject()\n              .instancesList.map((instance) =>\n                JSON.parse(Buffer.from(instance as string, \"base64\").toString())\n              ),\n          }\n          resolve(ret)\n        }\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * findByID queries the store for the id of an instance.\n   * @param ID The id of the instance to search for.\n   */\n  public async findByID<T = any>(ID: string): Promise<Instance<T> | undefined> {\n    return new Promise<Instance<T> | undefined>((resolve, reject) => {\n      const findReq = new FindByIDRequest()\n      findReq.setInstanceid(ID)\n      const req = new WriteTransactionRequest()\n      req.setFindbyidrequest(findReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getFindbyidreply()\n        if (reply === undefined) {\n          resolve()\n        } else {\n          const ret: Instance<T> = {\n            instance: JSON.parse(\n              Buffer.from(\n                reply.toObject().instance as string,\n                \"base64\"\n              ).toString()\n            ),\n          }\n          resolve(ret)\n        }\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}