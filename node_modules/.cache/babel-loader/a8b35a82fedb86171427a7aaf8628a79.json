{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureKey = exports.sha256Multihash = exports.multihash = void 0;\n\nconst fast_sha256_1 = __importDefault(require(\"fast-sha256\"));\n\nconst varint_1 = require(\"varint\");\n\nfunction multihash(digest, code, length) {\n  const a = new Uint8Array(varint_1.encode(code));\n  const b = new Uint8Array(varint_1.encode(length !== null && length !== void 0 ? length : digest.length));\n  const full = new Uint8Array(a.length + b.length + digest.length);\n  full.set(a);\n  full.set(b, a.length);\n  full.set(digest, a.length + b.length);\n  return full;\n}\n\nexports.multihash = multihash;\n/**\n * Basic multihash implementation that only supports sha256.\n * @param bytes The bytes to wrap with multihash.\n */\n\nfunction sha256Multihash(bytes) {\n  const digest = fast_sha256_1.default(bytes);\n  const code = 0x12; // sha2-256\n\n  return multihash(digest, code);\n}\n\nexports.sha256Multihash = sha256Multihash;\n\nfunction ensureKey(key, length) {\n  if (!(key instanceof Uint8Array) || key.length < length) throw new Error(`Key must be a Uint8Array (or Buffer) of length >= ${length}`);\n  return key;\n}\n\nexports.ensureKey = ensureKey;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,aAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,SAAgB,SAAhB,CACE,MADF,EAEE,IAFF,EAGE,MAHF,EAGiB;AAEf,QAAM,CAAC,GAAG,IAAI,UAAJ,CAAe,QAAA,CAAA,MAAA,CAAO,IAAP,CAAf,CAAV;AACA,QAAM,CAAC,GAAG,IAAI,UAAJ,CAAe,QAAA,CAAA,MAAA,CAAO,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAA,MAAA,GAAU,MAAM,CAAC,MAAxB,CAAf,CAAV;AACA,QAAM,IAAI,GAAG,IAAI,UAAJ,CAAe,CAAC,CAAC,MAAF,GAAW,CAAC,CAAC,MAAb,GAAsB,MAAM,CAAC,MAA5C,CAAb;AACA,EAAA,IAAI,CAAC,GAAL,CAAS,CAAT;AACA,EAAA,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,CAAC,CAAC,MAAd;AACA,EAAA,IAAI,CAAC,GAAL,CAAS,MAAT,EAAiB,CAAC,CAAC,MAAF,GAAW,CAAC,CAAC,MAA9B;AACA,SAAO,IAAP;AACD;;AAZD,OAAA,CAAA,SAAA,GAAA,SAAA;AAcA;;;;;AAIA,SAAgB,eAAhB,CAAgC,KAAhC,EAAiD;AAC/C,QAAM,MAAM,GAAG,aAAA,CAAA,OAAA,CAAO,KAAP,CAAf;AACA,QAAM,IAAI,GAAG,IAAb,CAF+C,CAE7B;;AAClB,SAAO,SAAS,CAAC,MAAD,EAAS,IAAT,CAAhB;AACD;;AAJD,OAAA,CAAA,eAAA,GAAA,eAAA;;AAMA,SAAgB,SAAhB,CAA0B,GAA1B,EAA2C,MAA3C,EAAyD;AACvD,MAAI,EAAE,GAAG,YAAY,UAAjB,KAAgC,GAAG,CAAC,MAAJ,GAAa,MAAjD,EACE,MAAM,IAAI,KAAJ,CACJ,qDAAqD,MAAM,EADvD,CAAN;AAGF,SAAO,GAAP;AACD;;AAND,OAAA,CAAA,SAAA,GAAA,SAAA","sourcesContent":["import sha256 from \"fast-sha256\"\nimport { encode } from \"varint\"\n\nexport function multihash(\n  digest: Uint8Array,\n  code: number,\n  length?: number\n): Uint8Array {\n  const a = new Uint8Array(encode(code))\n  const b = new Uint8Array(encode(length ?? digest.length))\n  const full = new Uint8Array(a.length + b.length + digest.length)\n  full.set(a)\n  full.set(b, a.length)\n  full.set(digest, a.length + b.length)\n  return full\n}\n\n/**\n * Basic multihash implementation that only supports sha256.\n * @param bytes The bytes to wrap with multihash.\n */\nexport function sha256Multihash(bytes: Uint8Array): Uint8Array {\n  const digest = sha256(bytes)\n  const code = 0x12 // sha2-256\n  return multihash(digest, code)\n}\n\nexport function ensureKey(key: Uint8Array, length: number): Uint8Array {\n  if (!(key instanceof Uint8Array) || key.length < length)\n    throw new Error(\n      `Key must be a Uint8Array (or Buffer) of length >= ${length}`\n    )\n  return key\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}