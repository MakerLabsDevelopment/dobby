{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ThreadID = exports.Variant = void 0;\n\nconst sync_randombytes_1 = __importDefault(require(\"@consento/sync-randombytes\"));\n\nconst multibase_1 = __importDefault(require(\"multibase\"));\n\nconst varint_1 = require(\"varint\");\n/**\n * Variant denotes Thread variant. Currently only two variants are supported.\n * @public\n */\n\n\nvar Variant;\n\n(function (Variant) {\n  Variant[Variant[\"Raw\"] = 85] = \"Raw\";\n  Variant[Variant[\"AccessControlled\"] = 112] = \"AccessControlled\";\n})(Variant = exports.Variant || (exports.Variant = {}));\n/**\n * ThreadID represents a self-describing Thread identifier.\n *\n * It is formed by a Version, a Variant, and a random number of a given length.\n * @public\n *\n * @example\n * Create a new random ThreadID\n * ```typescript\n * import { ThreadID } from '@textile/threads'\n *\n * const id = ThreadID.fromRandom()\n *\n * console.log(id)\n * ```\n *\n * @example\n * Convert a ThreadID to/from a Base32 string\n * ```typescript\n * import { ThreadID } from '@textile/threads'\n *\n * const id = ThreadID.fromRandom()\n * const str = id.toString()\n * const restored = ThreadID.fromString(str)\n * ```\n */\n\n\nclass ThreadID {\n  constructor(buf) {\n    this.buf = Buffer.from(buf);\n  }\n  /**\n   * fromRandom creates a new random ID object.\n   * @param variant The Thread variant to use. @see Variant\n   * @param size The size of the random component to use. Defaults to 32 bytes.\n   */\n\n\n  static fromRandom(variant = ThreadID.Variant.Raw, size = 32) {\n    // two 8 bytes (max) numbers plus random bytes\n    const bytes = Buffer.concat([Buffer.from(varint_1.encode(ThreadID.V1)), Buffer.from(varint_1.encode(variant)), sync_randombytes_1.default(Buffer.alloc(size))]);\n    return new ThreadID(bytes);\n  }\n  /**\n   * fromString parses an ID-encoded string and returns an ID object.\n   * For IDV1, an ID-encoded string is primarily a multibase string:\n   *    <multibase-type-code><base-encoded-string>\n   * The base-encoded string represents a:\n   *    <version><variant><random-number>\n   * @param v The input encoded Thread ID.\n   */\n\n\n  static fromString(v) {\n    if (v.length < 2) {\n      throw new Error(\"id too short\");\n    }\n\n    const data = multibase_1.default.decode(Buffer.from(v));\n    return ThreadID.fromBytes(data);\n  }\n  /**\n   * fromBytes takes an ID data slice, parses it and returns an ID.\n   * For IDV1, the data buffer is in the form:\n   *    <version><variant><random-number>\n   * Please use fromEncoded when parsing a regular ID string, as fromBytes does not\n   * expect multibase-encoded data. fromBytes accepts the output of ID.bytes().\n   * @param data The input Thread ID bytes.\n   */\n\n\n  static fromBytes(data) {\n    let copy = Buffer.from(data);\n    const version = varint_1.decode(copy);\n\n    if (version != 1) {\n      throw new Error(`expected 1 as the id version number, got: ${version}.`);\n    }\n\n    copy = copy.slice(varint_1.decode.bytes, copy.length);\n    const variant = varint_1.decode(copy);\n\n    if (!(variant in ThreadID.Variant)) {\n      throw new Error(\"invalid variant.\");\n    }\n\n    const id = copy.slice(varint_1.decode.bytes, copy.length);\n\n    if (id.length < 16) {\n      throw new Error(\"random component too small.\");\n    }\n\n    return new ThreadID(Buffer.from(data));\n  }\n  /**\n   * getEncoding returns the multibase encoding for a multibase encoded string.\n   * Returns the name of the encoding if it is encoded, and throws an error otherwise.\n   * @param v The Thread ID to check.\n   */\n\n\n  static getEncoding(v) {\n    if (v.length < 2) {\n      throw new Error(\"Too Short\");\n    }\n\n    const encoding = multibase_1.default.isEncoded(v); // check encoding is valid\n\n    if (encoding === false) {\n      throw new Error(\"Invalid Encoding\");\n    }\n\n    return encoding;\n  }\n  /**\n   * isDefined returns true if an ID is defined.\n   * Calling any other methods on an undefined ID will result in undefined behavior.\n   */\n\n\n  isDefined() {\n    return this.buf.length > 0;\n  }\n  /**\n   * toBytes returns the byte representation of an ID.\n   * The output of bytes can be parsed back into an ID with fromBytes.\n   */\n\n\n  toBytes() {\n    return Buffer.from(this.buf);\n  }\n  /**\n   * equals checks that two IDs are the same.\n   * @param o The other Thread ID.\n   */\n\n\n  equals(o) {\n    return this.buf.equals(o.buf);\n  }\n  /**\n   * version returns the ID version.\n   */\n\n\n  version() {\n    return varint_1.decode(this.buf);\n  }\n  /**\n   * variant returns the variant of an ID.\n   */\n\n\n  variant() {\n    let copy = Buffer.from(this.buf);\n    varint_1.decode(copy);\n    copy = copy.slice(varint_1.decode.bytes);\n    return varint_1.decode(copy);\n  }\n  /**\n   * toString returns the (multibase encoded) string representation of an ID.\n   * @param base Name of the base to use for encoding. Defaults to 'base32'.\n   */\n\n\n  toString(base = \"base32\") {\n    switch (this.version()) {\n      case ThreadID.V1:\n        return multibase_1.default.encode(base, this.buf).toString();\n\n      default:\n        throw new Error(\"unknown ID version.\");\n    }\n  }\n\n}\n\nexports.ThreadID = ThreadID;\n/**\n * Versions. Currently only V1 is supported.\n */\n\nThreadID.V1 = 0x01;\nThreadID.Variant = Variant;\nexports.default = ThreadID;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import randomBytes from \"@consento/sync-randombytes\"\nimport multibase, { name as Name } from \"multibase\"\nimport { decode, encode } from \"varint\"\n\n/**\n * Variant denotes Thread variant. Currently only two variants are supported.\n * @public\n */\nexport enum Variant {\n  Raw = 0x55,\n  AccessControlled = 0x70, // Supports access control lists\n}\n\n/**\n * ThreadID represents a self-describing Thread identifier.\n *\n * It is formed by a Version, a Variant, and a random number of a given length.\n * @public\n *\n * @example\n * Create a new random ThreadID\n * ```typescript\n * import { ThreadID } from '@textile/threads'\n *\n * const id = ThreadID.fromRandom()\n *\n * console.log(id)\n * ```\n *\n * @example\n * Convert a ThreadID to/from a Base32 string\n * ```typescript\n * import { ThreadID } from '@textile/threads'\n *\n * const id = ThreadID.fromRandom()\n * const str = id.toString()\n * const restored = ThreadID.fromString(str)\n * ```\n */\nexport class ThreadID {\n  // @todo: Move Buffer -> Uint8Array where possible\n  readonly buf: Buffer\n  constructor(buf: Uint8Array) {\n    this.buf = Buffer.from(buf)\n  }\n\n  /**\n   * Versions. Currently only V1 is supported.\n   */\n  static V1 = 0x01\n\n  static Variant = Variant\n\n  /**\n   * fromRandom creates a new random ID object.\n   * @param variant The Thread variant to use. @see Variant\n   * @param size The size of the random component to use. Defaults to 32 bytes.\n   */\n  static fromRandom(\n    variant: Variant = ThreadID.Variant.Raw,\n    size = 32\n  ): ThreadID {\n    // two 8 bytes (max) numbers plus random bytes\n    const bytes = Buffer.concat([\n      Buffer.from(encode(ThreadID.V1)),\n      Buffer.from(encode(variant)),\n      randomBytes(Buffer.alloc(size)),\n    ])\n    return new ThreadID(bytes)\n  }\n\n  /**\n   * fromString parses an ID-encoded string and returns an ID object.\n   * For IDV1, an ID-encoded string is primarily a multibase string:\n   *    <multibase-type-code><base-encoded-string>\n   * The base-encoded string represents a:\n   *    <version><variant><random-number>\n   * @param v The input encoded Thread ID.\n   */\n  static fromString(v: string | Uint8Array): ThreadID {\n    if (v.length < 2) {\n      throw new Error(\"id too short\")\n    }\n    const data = multibase.decode(Buffer.from(v))\n    return ThreadID.fromBytes(data)\n  }\n\n  /**\n   * fromBytes takes an ID data slice, parses it and returns an ID.\n   * For IDV1, the data buffer is in the form:\n   *    <version><variant><random-number>\n   * Please use fromEncoded when parsing a regular ID string, as fromBytes does not\n   * expect multibase-encoded data. fromBytes accepts the output of ID.bytes().\n   * @param data The input Thread ID bytes.\n   */\n  static fromBytes(data: Uint8Array): ThreadID {\n    let copy = Buffer.from(data)\n    const version = decode(copy)\n    if (version != 1) {\n      throw new Error(`expected 1 as the id version number, got: ${version}.`)\n    }\n    copy = copy.slice(decode.bytes, copy.length)\n    const variant = decode(copy)\n    if (!(variant in ThreadID.Variant)) {\n      throw new Error(\"invalid variant.\")\n    }\n    const id = copy.slice(decode.bytes, copy.length)\n    if (id.length < 16) {\n      throw new Error(\"random component too small.\")\n    }\n    return new ThreadID(Buffer.from(data))\n  }\n\n  /**\n   * getEncoding returns the multibase encoding for a multibase encoded string.\n   * Returns the name of the encoding if it is encoded, and throws an error otherwise.\n   * @param v The Thread ID to check.\n   */\n  static getEncoding(v: string): string {\n    if (v.length < 2) {\n      throw new Error(\"Too Short\")\n    }\n    const encoding = multibase.isEncoded(v)\n    // check encoding is valid\n    if (encoding === false) {\n      throw new Error(\"Invalid Encoding\")\n    }\n    return encoding\n  }\n\n  /**\n   * isDefined returns true if an ID is defined.\n   * Calling any other methods on an undefined ID will result in undefined behavior.\n   */\n  isDefined(): boolean {\n    return this.buf.length > 0\n  }\n\n  /**\n   * toBytes returns the byte representation of an ID.\n   * The output of bytes can be parsed back into an ID with fromBytes.\n   */\n  toBytes(): Buffer {\n    return Buffer.from(this.buf)\n  }\n\n  /**\n   * equals checks that two IDs are the same.\n   * @param o The other Thread ID.\n   */\n  equals(o: ThreadID): boolean {\n    return this.buf.equals(o.buf)\n  }\n\n  /**\n   * version returns the ID version.\n   */\n  version(): number {\n    return decode(this.buf)\n  }\n\n  /**\n   * variant returns the variant of an ID.\n   */\n  variant(): number {\n    let copy = Buffer.from(this.buf)\n    decode(copy)\n    copy = copy.slice(decode.bytes)\n    return decode(copy)\n  }\n\n  /**\n   * toString returns the (multibase encoded) string representation of an ID.\n   * @param base Name of the base to use for encoding. Defaults to 'base32'.\n   */\n  toString(base: Name = \"base32\"): string {\n    switch (this.version()) {\n      case ThreadID.V1:\n        return multibase.encode(base, this.buf).toString()\n      default:\n        throw new Error(\"unknown ID version.\")\n    }\n  }\n}\n\nexport default ThreadID\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}