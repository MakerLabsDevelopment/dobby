{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebsocketTransport = void 0; // Copyright improbable-eng Apache License 2.0\n// https://github.com/improbable-eng/grpc-web/blob/master/client/grpc-web/src/transports/websocket/websocket.ts\n\nconst isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\n\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\n\nconst {\n  debug\n} = loglevel_1.default.getLogger('grpc-transport');\n\nconst isAllowedControlChars = char => char === 0x9 || char === 0xa || char === 0xd;\n\nfunction isValidHeaderAscii(val) {\n  return isAllowedControlChars(val) || val >= 0x20 && val <= 0x7e;\n}\n\nfunction encodeASCII(input) {\n  const encoded = new Uint8Array(input.length);\n\n  for (let i = 0; i !== input.length; ++i) {\n    const charCode = input.charCodeAt(i);\n\n    if (!isValidHeaderAscii(charCode)) {\n      throw new Error('Metadata contains invalid ASCII');\n    }\n\n    encoded[i] = charCode;\n  }\n\n  return encoded;\n}\n\nvar WebsocketSignal;\n\n(function (WebsocketSignal) {\n  WebsocketSignal[WebsocketSignal[\"FINISH_SEND\"] = 1] = \"FINISH_SEND\";\n})(WebsocketSignal || (WebsocketSignal = {}));\n\nconst finishSendFrame = new Uint8Array([1]);\n\nfunction constructWebSocketAddress(url) {\n  if (url.substr(0, 8) === 'https://') {\n    return `wss://${url.substr(8)}`;\n  } else if (url.substr(0, 7) === 'http://') {\n    return `ws://${url.substr(7)}`;\n  }\n\n  throw new Error('Websocket transport constructed with non-https:// or http:// host.');\n}\n\nfunction headersToBytes(headers) {\n  let asString = '';\n  headers.forEach((key, values) => {\n    asString += `${key}: ${values.join(', ')}\\r\\n`;\n  });\n  return encodeASCII(asString);\n}\n\nfunction websocketRequest(options) {\n  options.debug && debug('websocketRequest', options);\n  const webSocketAddress = constructWebSocketAddress(options.url);\n  const sendQueue = [];\n  let ws;\n\n  function sendToWebsocket(toSend) {\n    if (toSend === WebsocketSignal.FINISH_SEND) {\n      ws.send(finishSendFrame);\n    } else {\n      const byteArray = toSend;\n      const c = new Int8Array(byteArray.byteLength + 1);\n      c.set(new Uint8Array([0]));\n      c.set(byteArray, 1);\n      ws.send(c);\n    }\n  }\n\n  return {\n    sendMessage: msgBytes => {\n      if (!ws || ws.readyState === ws.CONNECTING) {\n        sendQueue.push(msgBytes);\n      } else {\n        sendToWebsocket(msgBytes);\n      }\n    },\n    finishSend: () => {\n      if (!ws || ws.readyState === ws.CONNECTING) {\n        sendQueue.push(WebsocketSignal.FINISH_SEND);\n      } else {\n        sendToWebsocket(WebsocketSignal.FINISH_SEND);\n      }\n    },\n    start: metadata => {\n      ws = new isomorphic_ws_1.default(webSocketAddress, ['grpc-websockets']);\n      ws.binaryType = 'arraybuffer';\n\n      ws.onopen = function () {\n        options.debug && debug('websocketRequest.onopen');\n        ws.send(headersToBytes(metadata)); // send any messages that were passed to sendMessage before the connection was ready\n\n        sendQueue.forEach(toSend => {\n          sendToWebsocket(toSend);\n        });\n      };\n\n      ws.onclose = function (closeEvent) {\n        options.debug && debug('websocketRequest.onclose', closeEvent);\n        options.onEnd();\n      };\n\n      ws.onerror = function (error) {\n        options.debug && debug('websocketRequest.onerror', error);\n      };\n\n      ws.onmessage = function (e) {\n        options.onChunk(new Uint8Array(e.data));\n      };\n    },\n    cancel: () => {\n      options.debug && debug('websocket.abort');\n      ws.close();\n    }\n  };\n}\n\nfunction WebsocketTransport() {\n  return opts => {\n    return websocketRequest(opts);\n  };\n}\n\nexports.WebsocketTransport = WebsocketTransport;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright improbable-eng Apache License 2.0\n// https://github.com/improbable-eng/grpc-web/blob/master/client/grpc-web/src/transports/websocket/websocket.ts\nimport WebSocket from 'isomorphic-ws'\nimport { grpc } from '@improbable-eng/grpc-web'\nimport log from 'loglevel'\n\nconst { debug } = log.getLogger('grpc-transport')\n\nconst isAllowedControlChars = (char: number) => char === 0x9 || char === 0xa || char === 0xd\n\nfunction isValidHeaderAscii(val: number): boolean {\n  return isAllowedControlChars(val) || (val >= 0x20 && val <= 0x7e)\n}\n\nfunction encodeASCII(input: string): Uint8Array {\n  const encoded = new Uint8Array(input.length)\n  for (let i = 0; i !== input.length; ++i) {\n    const charCode = input.charCodeAt(i)\n    if (!isValidHeaderAscii(charCode)) {\n      throw new Error('Metadata contains invalid ASCII')\n    }\n    encoded[i] = charCode\n  }\n  return encoded\n}\n\nenum WebsocketSignal {\n  FINISH_SEND = 1,\n}\n\nconst finishSendFrame = new Uint8Array([1])\n\nfunction constructWebSocketAddress(url: string) {\n  if (url.substr(0, 8) === 'https://') {\n    return `wss://${url.substr(8)}`\n  } else if (url.substr(0, 7) === 'http://') {\n    return `ws://${url.substr(7)}`\n  }\n  throw new Error('Websocket transport constructed with non-https:// or http:// host.')\n}\n\nfunction headersToBytes(headers: grpc.Metadata): Uint8Array {\n  let asString = ''\n  headers.forEach((key, values) => {\n    asString += `${key}: ${values.join(', ')}\\r\\n`\n  })\n  return encodeASCII(asString)\n}\n\nfunction websocketRequest(options: grpc.TransportOptions): grpc.Transport {\n  options.debug && debug('websocketRequest', options)\n\n  const webSocketAddress = constructWebSocketAddress(options.url)\n\n  const sendQueue: Array<Uint8Array | WebsocketSignal> = []\n  let ws: WebSocket\n\n  function sendToWebsocket(toSend: Uint8Array | WebsocketSignal) {\n    if (toSend === WebsocketSignal.FINISH_SEND) {\n      ws.send(finishSendFrame)\n    } else {\n      const byteArray = toSend as Uint8Array\n      const c = new Int8Array(byteArray.byteLength + 1)\n      c.set(new Uint8Array([0]))\n\n      c.set((byteArray as any) as ArrayLike<number>, 1)\n\n      ws.send(c)\n    }\n  }\n\n  return {\n    sendMessage: (msgBytes: Uint8Array) => {\n      if (!ws || ws.readyState === ws.CONNECTING) {\n        sendQueue.push(msgBytes)\n      } else {\n        sendToWebsocket(msgBytes)\n      }\n    },\n    finishSend: () => {\n      if (!ws || ws.readyState === ws.CONNECTING) {\n        sendQueue.push(WebsocketSignal.FINISH_SEND)\n      } else {\n        sendToWebsocket(WebsocketSignal.FINISH_SEND)\n      }\n    },\n    start: (metadata: grpc.Metadata) => {\n      ws = new WebSocket(webSocketAddress, ['grpc-websockets'])\n      ws.binaryType = 'arraybuffer'\n      ws.onopen = function () {\n        options.debug && debug('websocketRequest.onopen')\n        ws.send(headersToBytes(metadata))\n\n        // send any messages that were passed to sendMessage before the connection was ready\n        sendQueue.forEach((toSend) => {\n          sendToWebsocket(toSend)\n        })\n      }\n\n      ws.onclose = function (closeEvent) {\n        options.debug && debug('websocketRequest.onclose', closeEvent)\n        options.onEnd()\n      }\n\n      ws.onerror = function (error) {\n        options.debug && debug('websocketRequest.onerror', error)\n      }\n\n      ws.onmessage = function (e) {\n        options.onChunk(new Uint8Array(e.data as Iterable<number>))\n      }\n    },\n    cancel: () => {\n      options.debug && debug('websocket.abort')\n      ws.close()\n    },\n  }\n}\n\nexport function WebsocketTransport(): grpc.TransportFactory {\n  return (opts: grpc.TransportOptions) => {\n    return websocketRequest(opts)\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}