{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PrivateKey = exports.PublicKey = exports.privateKeyToString = void 0;\n\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\n\nconst multibase_1 = __importDefault(require(\"multibase\"));\n\nconst proto_keys_1 = require(\"./proto.keys\"); // eslint-disable-next-line import/no-cycle\n\n\nconst utils_1 = require(\"./utils\");\n/**\n * Encode the given PrivateKey to its base-32 encoded multibase representation.\n * @param key The input PrivateKey.\n */\n\n\nfunction privateKeyToString(key) {\n  const encoded = multibase_1.default.encode('base32', key.bytes);\n  return new TextDecoder().decode(encoded);\n}\n\nexports.privateKeyToString = privateKeyToString;\n/**\n * Default implementation of the {@link Public} interface, with encryption\n * support.\n * In theory, RSA, ed25519, and secp256k1 key types (and more) should be\n * supported, although currently only ed25519 has full verify and encrypt\n * capabilities.\n * @privateRemarks Support additional key types by default. For now, sticking to ed25519\n * keeps our bundle smaller, but if needed, additional types can be added via\n * libp2p-crypto or tweetnacl.\n * @privateRemarks Separate out the generic PublicKey interface to include signing and\n * encryption methods, and then have this class implement that interface.\n *\n * @example\n * Create a private key, extract the public key string\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * function example() {\n *   const identity = PrivateKey.fromRandom()\n *   const publicKey = identity.public.toString()\n *   return publicKey\n * }\n * ```\n *\n * @example\n * Encrypt a message using another person's public key (string)\n * ```typescript\n * import { PublicKey } from '@textile/hub'\n *\n * async function example(publicKey: string) {\n *   const recipient = PublicKey.fromString(publicKey)\n *   const msg = new TextEncoder().encode('howdy!')\n *   const ciphertext = await recipient.encrypt(msg)\n *   return ciphertext\n * }\n * ```\n *\n * @example\n * Decrypt a message sent to the local user with their private key\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey, ciphertext: Uint8Array) {\n *   const plaintext = await identity.decrypt(ciphertext)\n *   return plaintext\n * }\n * ```\n *\n * @example\n * Encrypt the local user's own message for later reading.\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey) {\n *   const msg = new TextEncoder().encode('private message!')\n *   const ciphertext = await identity.public.encrypt(msg)\n *   return ciphertext // can only be decrypted by the local user\n * }\n * ```\n */\n\nclass PublicKey {\n  constructor(pubKey, type = 'ed25519') {\n    this.pubKey = pubKey;\n    this.type = type;\n\n    if (type !== 'ed25519') {\n      throw new Error('Invalid keys type');\n    }\n\n    this.type = type || 'ed25519';\n  }\n  /**\n   * Verifies the signature for the data and returns true if verification\n   * succeeded or false if it failed.\n   * @param data The data to use for verification.\n   * @param sig The signature to verify.\n   */\n\n\n  verify(data, signature) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return tweetnacl_1.default.sign.detached.verify(data, signature, this.pubKey);\n    });\n  }\n  /**\n   * Return the base32-encoded multibase string of the `bytes` of this public\n   * key. Useful for encoding the key for sharing etc.\n   */\n\n\n  toString() {\n    return utils_1.publicKeyToString(this);\n  }\n  /**\n   * Create a PublicKey from the result of calling `toString()`.\n   */\n\n\n  static fromString(str) {\n    const bytes = utils_1.publicKeyBytesFromString(str);\n    return new PublicKey(bytes, 'ed25519');\n  }\n  /**\n   * Return the protobuf-encoded bytes of this public key.\n   */\n\n\n  get bytes() {\n    return proto_keys_1.encodePublicKey({\n      Type: \"Ed25519\"\n      /* Ed25519 */\n      ,\n      Data: this.pubKey\n    });\n  }\n  /**\n   * Encrypt the given data using this public key.\n   * @param data The input plaintext.\n   */\n\n\n  encrypt(data) {\n    return utils_1.encrypt(data, this.pubKey, this.type);\n  }\n\n}\n\nexports.PublicKey = PublicKey;\n/**\n * Default implementation of the {@link Private} interface, with decryption\n * support.\n * In theory, RSA, ed25519, and secp256k1 key types (and more) should be\n * supported, although currently only ed25519 has full sign and decrypt\n * capabilities.\n * @privateRemarks Support additional key types by default. For now, sticking to ed25519\n * keeps our bundle smaller, but if needed, additional types can be added via\n * libp2p-crypto or tweetnacl.\n * @privateRemarks Separate out the generic PrivateKey interface to include signing and\n * encryption methods, and then have this class implement that interface.\n *\n * @example\n * Create a private key, extract the public key string\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * function example() {\n *   const identity = PrivateKey.fromRandom()\n *   const publicKey = identity.public.toString()\n *   return publicKey\n * }\n * ```\n *\n * @example\n * Encrypt a message using another person's public key (string)\n * ```typescript\n * import { PublicKey } from '@textile/hub'\n *\n * async function example(publicKey: string) {\n *   const recipient = PublicKey.fromString(publicKey)\n *   const msg = new TextEncoder().encode('howdy!')\n *   const ciphertext = await recipient.encrypt(msg)\n *   return ciphertext\n * }\n * ```\n *\n * @example\n * Decrypt a message sent to the local user with their private key\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey, ciphertext: Uint8Array) {\n *   const plaintext = await identity.decrypt(ciphertext)\n *   return plaintext\n * }\n * ```\n *\n * @example\n * Encrypt the local user's own message for later reading.\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey) {\n *   const msg = new TextEncoder().encode('private message!')\n *   const ciphertext = await identity.public.encrypt(msg)\n *   return ciphertext // can only be decrypted by the local user\n * }\n * ```\n */\n\nclass PrivateKey {\n  /**\n   * Constructor\n   * @param secretKey Raw secret key (32-byte secret seed in ed25519)\n   * @param type Public-key signature system name. (currently only `ed25519` keys are supported)\n   */\n  constructor(secretKey, type = 'ed25519') {\n    this.type = type;\n\n    if (type !== 'ed25519') {\n      throw new Error('Invalid keys type');\n    }\n\n    this.type = type || 'ed25519';\n    const secret = Uint8Array.from(secretKey);\n\n    if (secret.length !== 32) {\n      throw new Error('secretKey length is invalid');\n    }\n\n    const naclKeys = tweetnacl_1.default.sign.keyPair.fromSeed(secret);\n    this.seed = secret;\n    this.privKey = naclKeys.secretKey;\n    this.pubKey = naclKeys.publicKey;\n  }\n  /**\n   * Returns `true` if this key contains a secret key and can sign.\n   */\n\n\n  canSign() {\n    return !!this.privKey;\n  }\n  /**\n   * Sign the message using this private key and return the signature.\n   * @param data The data (raw bytes) to sign.\n   */\n\n\n  sign(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.canSign()) {\n        throw new Error('cannot sign: no secret key available');\n      }\n\n      return tweetnacl_1.default.sign.detached(data, this.privKey);\n    });\n  }\n  /**\n   * Get the public key associated with this identity.\n   */\n\n\n  get public() {\n    return new PublicKey(this.pubKey);\n  }\n  /**\n   * Return the protobuf-encoded bytes of this private key.\n   */\n\n\n  get bytes() {\n    return proto_keys_1.encodePrivateKey({\n      Type: \"Ed25519\"\n      /* Ed25519 */\n      ,\n      Data: this.privKey\n    });\n  }\n  /**\n   * Creates a new PrivateKey from ed25519 secret key seed raw bytes.\n   *\n   * @param rawSeed Raw 32-byte ed25519 secret key seed.\n   */\n\n\n  static fromRawEd25519Seed(rawSeed) {\n    return new this(rawSeed, 'ed25519');\n  }\n  /**\n   * Create a random PrivateKey.\n   */\n\n\n  static fromRandom() {\n    const secret = tweetnacl_1.default.randomBytes(32);\n    return this.fromRawEd25519Seed(secret);\n  }\n  /**\n   * Return the base32-encoded multibase string of the `bytes` of this private\n   * key. Useful for encoding the key for sharing etc.\n   */\n\n\n  toString() {\n    return privateKeyToString(this);\n  }\n  /**\n   * Create a PrivateKey from the result of calling `toString()`.\n   */\n\n\n  static fromString(str) {\n    return new PrivateKey(utils_1.privateKeyFromString(str), 'ed25519');\n  }\n  /**\n   * Decrypt the given ciphertext using this private key.\n   * @param ciphertext The input ciphertext (encrypted data)\n   */\n\n\n  decrypt(ciphertext) {\n    return utils_1.decrypt(ciphertext, this.privKey, this.type);\n  }\n\n}\n\nexports.PrivateKey = PrivateKey;","map":{"version":3,"sources":["../src/keypair.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PrivateKey = exports.PublicKey = exports.privateKeyToString = void 0;\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst multibase_1 = __importDefault(require(\"multibase\"));\nconst proto_keys_1 = require(\"./proto.keys\");\n// eslint-disable-next-line import/no-cycle\nconst utils_1 = require(\"./utils\");\n/**\n * Encode the given PrivateKey to its base-32 encoded multibase representation.\n * @param key The input PrivateKey.\n */\nfunction privateKeyToString(key) {\n    const encoded = multibase_1.default.encode('base32', key.bytes);\n    return new TextDecoder().decode(encoded);\n}\nexports.privateKeyToString = privateKeyToString;\n/**\n * Default implementation of the {@link Public} interface, with encryption\n * support.\n * In theory, RSA, ed25519, and secp256k1 key types (and more) should be\n * supported, although currently only ed25519 has full verify and encrypt\n * capabilities.\n * @privateRemarks Support additional key types by default. For now, sticking to ed25519\n * keeps our bundle smaller, but if needed, additional types can be added via\n * libp2p-crypto or tweetnacl.\n * @privateRemarks Separate out the generic PublicKey interface to include signing and\n * encryption methods, and then have this class implement that interface.\n *\n * @example\n * Create a private key, extract the public key string\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * function example() {\n *   const identity = PrivateKey.fromRandom()\n *   const publicKey = identity.public.toString()\n *   return publicKey\n * }\n * ```\n *\n * @example\n * Encrypt a message using another person's public key (string)\n * ```typescript\n * import { PublicKey } from '@textile/hub'\n *\n * async function example(publicKey: string) {\n *   const recipient = PublicKey.fromString(publicKey)\n *   const msg = new TextEncoder().encode('howdy!')\n *   const ciphertext = await recipient.encrypt(msg)\n *   return ciphertext\n * }\n * ```\n *\n * @example\n * Decrypt a message sent to the local user with their private key\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey, ciphertext: Uint8Array) {\n *   const plaintext = await identity.decrypt(ciphertext)\n *   return plaintext\n * }\n * ```\n *\n * @example\n * Encrypt the local user's own message for later reading.\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey) {\n *   const msg = new TextEncoder().encode('private message!')\n *   const ciphertext = await identity.public.encrypt(msg)\n *   return ciphertext // can only be decrypted by the local user\n * }\n * ```\n */\nclass PublicKey {\n    constructor(pubKey, type = 'ed25519') {\n        this.pubKey = pubKey;\n        this.type = type;\n        if (type !== 'ed25519') {\n            throw new Error('Invalid keys type');\n        }\n        this.type = type || 'ed25519';\n    }\n    /**\n     * Verifies the signature for the data and returns true if verification\n     * succeeded or false if it failed.\n     * @param data The data to use for verification.\n     * @param sig The signature to verify.\n     */\n    verify(data, signature) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return tweetnacl_1.default.sign.detached.verify(data, signature, this.pubKey);\n        });\n    }\n    /**\n     * Return the base32-encoded multibase string of the `bytes` of this public\n     * key. Useful for encoding the key for sharing etc.\n     */\n    toString() {\n        return utils_1.publicKeyToString(this);\n    }\n    /**\n     * Create a PublicKey from the result of calling `toString()`.\n     */\n    static fromString(str) {\n        const bytes = utils_1.publicKeyBytesFromString(str);\n        return new PublicKey(bytes, 'ed25519');\n    }\n    /**\n     * Return the protobuf-encoded bytes of this public key.\n     */\n    get bytes() {\n        return proto_keys_1.encodePublicKey({\n            Type: \"Ed25519\" /* Ed25519 */,\n            Data: this.pubKey,\n        });\n    }\n    /**\n     * Encrypt the given data using this public key.\n     * @param data The input plaintext.\n     */\n    encrypt(data) {\n        return utils_1.encrypt(data, this.pubKey, this.type);\n    }\n}\nexports.PublicKey = PublicKey;\n/**\n * Default implementation of the {@link Private} interface, with decryption\n * support.\n * In theory, RSA, ed25519, and secp256k1 key types (and more) should be\n * supported, although currently only ed25519 has full sign and decrypt\n * capabilities.\n * @privateRemarks Support additional key types by default. For now, sticking to ed25519\n * keeps our bundle smaller, but if needed, additional types can be added via\n * libp2p-crypto or tweetnacl.\n * @privateRemarks Separate out the generic PrivateKey interface to include signing and\n * encryption methods, and then have this class implement that interface.\n *\n * @example\n * Create a private key, extract the public key string\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * function example() {\n *   const identity = PrivateKey.fromRandom()\n *   const publicKey = identity.public.toString()\n *   return publicKey\n * }\n * ```\n *\n * @example\n * Encrypt a message using another person's public key (string)\n * ```typescript\n * import { PublicKey } from '@textile/hub'\n *\n * async function example(publicKey: string) {\n *   const recipient = PublicKey.fromString(publicKey)\n *   const msg = new TextEncoder().encode('howdy!')\n *   const ciphertext = await recipient.encrypt(msg)\n *   return ciphertext\n * }\n * ```\n *\n * @example\n * Decrypt a message sent to the local user with their private key\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey, ciphertext: Uint8Array) {\n *   const plaintext = await identity.decrypt(ciphertext)\n *   return plaintext\n * }\n * ```\n *\n * @example\n * Encrypt the local user's own message for later reading.\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey) {\n *   const msg = new TextEncoder().encode('private message!')\n *   const ciphertext = await identity.public.encrypt(msg)\n *   return ciphertext // can only be decrypted by the local user\n * }\n * ```\n */\nclass PrivateKey {\n    /**\n     * Constructor\n     * @param secretKey Raw secret key (32-byte secret seed in ed25519)\n     * @param type Public-key signature system name. (currently only `ed25519` keys are supported)\n     */\n    constructor(secretKey, type = 'ed25519') {\n        this.type = type;\n        if (type !== 'ed25519') {\n            throw new Error('Invalid keys type');\n        }\n        this.type = type || 'ed25519';\n        const secret = Uint8Array.from(secretKey);\n        if (secret.length !== 32) {\n            throw new Error('secretKey length is invalid');\n        }\n        const naclKeys = tweetnacl_1.default.sign.keyPair.fromSeed(secret);\n        this.seed = secret;\n        this.privKey = naclKeys.secretKey;\n        this.pubKey = naclKeys.publicKey;\n    }\n    /**\n     * Returns `true` if this key contains a secret key and can sign.\n     */\n    canSign() {\n        return !!this.privKey;\n    }\n    /**\n     * Sign the message using this private key and return the signature.\n     * @param data The data (raw bytes) to sign.\n     */\n    sign(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.canSign()) {\n                throw new Error('cannot sign: no secret key available');\n            }\n            return tweetnacl_1.default.sign.detached(data, this.privKey);\n        });\n    }\n    /**\n     * Get the public key associated with this identity.\n     */\n    get public() {\n        return new PublicKey(this.pubKey);\n    }\n    /**\n     * Return the protobuf-encoded bytes of this private key.\n     */\n    get bytes() {\n        return proto_keys_1.encodePrivateKey({\n            Type: \"Ed25519\" /* Ed25519 */,\n            Data: this.privKey,\n        });\n    }\n    /**\n     * Creates a new PrivateKey from ed25519 secret key seed raw bytes.\n     *\n     * @param rawSeed Raw 32-byte ed25519 secret key seed.\n     */\n    static fromRawEd25519Seed(rawSeed) {\n        return new this(rawSeed, 'ed25519');\n    }\n    /**\n     * Create a random PrivateKey.\n     */\n    static fromRandom() {\n        const secret = tweetnacl_1.default.randomBytes(32);\n        return this.fromRawEd25519Seed(secret);\n    }\n    /**\n     * Return the base32-encoded multibase string of the `bytes` of this private\n     * key. Useful for encoding the key for sharing etc.\n     */\n    toString() {\n        return privateKeyToString(this);\n    }\n    /**\n     * Create a PrivateKey from the result of calling `toString()`.\n     */\n    static fromString(str) {\n        return new PrivateKey(utils_1.privateKeyFromString(str), 'ed25519');\n    }\n    /**\n     * Decrypt the given ciphertext using this private key.\n     * @param ciphertext The input ciphertext (encrypted data)\n     */\n    decrypt(ciphertext) {\n        return utils_1.decrypt(ciphertext, this.privKey, this.type);\n    }\n}\nexports.PrivateKey = PrivateKey;\n//# sourceMappingURL=keypair.js.map"]},"metadata":{},"sourceType":"script"}