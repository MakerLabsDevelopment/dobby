{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\n\nconst users_pb_1 = require(\"@textile/users-grpc/users_pb\");\n\nconst users_pb_service_1 = require(\"@textile/users-grpc/users_pb_service\");\n\nconst threads_client_1 = require(\"@textile/threads-client\");\n\nObject.defineProperty(exports, \"Client\", {\n  enumerable: true,\n  get: function () {\n    return threads_client_1.Client;\n  }\n});\n\nconst threads_id_1 = require(\"@textile/threads-id\");\n\nconst logger = loglevel_1.default.getLogger('users');\n\nthreads_client_1.Client.prototype.getThread = function (name, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('get thread request');\n    const client = new users_pb_service_1.APIClient(this.serviceHost, {\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug\n    });\n    return new Promise((resolve, reject) => {\n      const req = new users_pb_1.GetThreadRequest();\n      req.setName(name);\n      this.context.toMetadata(ctx).then(meta => {\n        client.getThread(req, meta, (err, message) => {\n          if (err) reject(err);\n          const msg = message === null || message === void 0 ? void 0 : message.toObject();\n\n          if (msg) {\n            msg.id = threads_id_1.ThreadID.fromBytes(Buffer.from(msg.id, 'base64')).toString();\n          }\n\n          resolve(msg);\n        });\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  });\n};\n/**\n * Returns a list of available Threads.\n * @param ctx Context containing gRPC headers and settings.\n * These will be merged with any internal credentials.\n * @note Threads can be created using the threads or threads network clients.\n */\n\n\nthreads_client_1.Client.prototype.listThreads = function (ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger.debug('list threads request');\n    const client = new users_pb_service_1.APIClient(this.serviceHost, {\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug\n    });\n    return new Promise((resolve, reject) => {\n      const req = new users_pb_1.ListThreadsRequest();\n      this.context.toMetadata(ctx).then(meta => {\n        client.listThreads(req, meta, (err, message) => {\n          if (err) reject(err);\n          const msg = message === null || message === void 0 ? void 0 : message.toObject();\n\n          if (msg) {\n            msg.listList.forEach(thread => {\n              thread.id = threads_id_1.ThreadID.fromBytes(Buffer.from(thread.id, 'base64')).toString();\n            });\n          }\n\n          resolve(msg);\n        });\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  });\n};","map":{"version":3,"sources":["../src/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = void 0;\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\nconst users_pb_1 = require(\"@textile/users-grpc/users_pb\");\nconst users_pb_service_1 = require(\"@textile/users-grpc/users_pb_service\");\nconst threads_client_1 = require(\"@textile/threads-client\");\nObject.defineProperty(exports, \"Client\", { enumerable: true, get: function () { return threads_client_1.Client; } });\nconst threads_id_1 = require(\"@textile/threads-id\");\nconst logger = loglevel_1.default.getLogger('users');\nthreads_client_1.Client.prototype.getThread = function (name, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('get thread request');\n        const client = new users_pb_service_1.APIClient(this.serviceHost, {\n            transport: this.rpcOptions.transport,\n            debug: this.rpcOptions.debug,\n        });\n        return new Promise((resolve, reject) => {\n            const req = new users_pb_1.GetThreadRequest();\n            req.setName(name);\n            this.context\n                .toMetadata(ctx)\n                .then((meta) => {\n                client.getThread(req, meta, (err, message) => {\n                    if (err)\n                        reject(err);\n                    const msg = message === null || message === void 0 ? void 0 : message.toObject();\n                    if (msg) {\n                        msg.id = threads_id_1.ThreadID.fromBytes(Buffer.from(msg.id, 'base64')).toString();\n                    }\n                    resolve(msg);\n                });\n            })\n                .catch((err) => {\n                reject(err);\n            });\n        });\n    });\n};\n/**\n * Returns a list of available Threads.\n * @param ctx Context containing gRPC headers and settings.\n * These will be merged with any internal credentials.\n * @note Threads can be created using the threads or threads network clients.\n */\nthreads_client_1.Client.prototype.listThreads = function (ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        logger.debug('list threads request');\n        const client = new users_pb_service_1.APIClient(this.serviceHost, {\n            transport: this.rpcOptions.transport,\n            debug: this.rpcOptions.debug,\n        });\n        return new Promise((resolve, reject) => {\n            const req = new users_pb_1.ListThreadsRequest();\n            this.context\n                .toMetadata(ctx)\n                .then((meta) => {\n                client.listThreads(req, meta, (err, message) => {\n                    if (err)\n                        reject(err);\n                    const msg = message === null || message === void 0 ? void 0 : message.toObject();\n                    if (msg) {\n                        msg.listList.forEach((thread) => {\n                            thread.id = threads_id_1.ThreadID.fromBytes(Buffer.from(thread.id, 'base64')).toString();\n                        });\n                    }\n                    resolve(msg);\n                });\n            })\n                .catch((err) => {\n                reject(err);\n            });\n        });\n    });\n};\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}