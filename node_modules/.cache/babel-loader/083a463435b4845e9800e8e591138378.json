{"ast":null,"code":"'use strict';\n\nconst multibase = require('multibase');\n\nconst sha = require('multihashing-async/src/sha');\n\nconst errcode = require('err-code');\n\nconst exporter = require('./exporter');\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')(randomBytes);\n\n  class Secp256k1PublicKey {\n    constructor(key) {\n      crypto.validatePublicKey(key);\n      this._key = key;\n    }\n\n    verify(data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data);\n    }\n\n    marshal() {\n      return crypto.compressPublicKey(this._key);\n    }\n\n    get bytes() {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      });\n    }\n\n    equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n\n    hash() {\n      return sha.multihashing(this.bytes, 'sha2-256');\n    }\n\n  }\n\n  class Secp256k1PrivateKey {\n    constructor(key, publicKey) {\n      this._key = key;\n      this._publicKey = publicKey || crypto.computePublicKey(key);\n      crypto.validatePrivateKey(this._key);\n      crypto.validatePublicKey(this._publicKey);\n    }\n\n    sign(message) {\n      return crypto.hashAndSign(this._key, message);\n    }\n\n    get public() {\n      return new Secp256k1PublicKey(this._publicKey);\n    }\n\n    marshal() {\n      return this._key;\n    }\n\n    get bytes() {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      });\n    }\n\n    equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n\n    hash() {\n      return sha.multihashing(this.bytes, 'sha2-256');\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n\n\n    async id() {\n      const hash = await this.public.hash();\n      return multibase.encode('base58btc', hash).toString().slice(1);\n    }\n    /**\n     * Exports the key into a password protected `format`\n     *\n     * @param {string} password - The password to encrypt the key\n     * @param {string} [format=libp2p-key] - The format in which to export as\n     * @returns {Promise<string>} The encrypted private key\n     */\n\n\n    async export(password, format = 'libp2p-key') {\n      // eslint-disable-line require-await\n      if (format === 'libp2p-key') {\n        return exporter.export(this.bytes, password);\n      } else {\n        throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n      }\n    }\n\n  }\n\n  function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n  }\n\n  function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  async function generateKeyPair() {\n    const privateKeyBytes = await crypto.generateKey();\n    return new Secp256k1PrivateKey(privateKeyBytes);\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  };\n};","map":{"version":3,"sources":["/Users/nassarhayat/apps/textiletable/dobby/node_modules/libp2p-crypto/src/keys/secp256k1-class.js"],"names":["multibase","require","sha","errcode","exporter","module","exports","keysProtobuf","randomBytes","crypto","Secp256k1PublicKey","constructor","key","validatePublicKey","_key","verify","data","sig","hashAndVerify","marshal","compressPublicKey","bytes","PublicKey","encode","Type","KeyType","Secp256k1","Data","equals","hash","multihashing","Secp256k1PrivateKey","publicKey","_publicKey","computePublicKey","validatePrivateKey","sign","message","hashAndSign","public","PrivateKey","id","toString","slice","export","password","format","Error","unmarshalSecp256k1PrivateKey","unmarshalSecp256k1PublicKey","generateKeyPair","privateKeyBytes","generateKey"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multibase = require('multibase')\nconst sha = require('multihashing-async/src/sha')\nconst errcode = require('err-code')\n\nconst exporter = require('./exporter')\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')(randomBytes)\n\n  class Secp256k1PublicKey {\n    constructor (key) {\n      crypto.validatePublicKey(key)\n      this._key = key\n    }\n\n    verify (data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data)\n    }\n\n    marshal () {\n      return crypto.compressPublicKey(this._key)\n    }\n\n    get bytes () {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      })\n    }\n\n    equals (key) {\n      return this.bytes.equals(key.bytes)\n    }\n\n    hash () {\n      return sha.multihashing(this.bytes, 'sha2-256')\n    }\n  }\n\n  class Secp256k1PrivateKey {\n    constructor (key, publicKey) {\n      this._key = key\n      this._publicKey = publicKey || crypto.computePublicKey(key)\n      crypto.validatePrivateKey(this._key)\n      crypto.validatePublicKey(this._publicKey)\n    }\n\n    sign (message) {\n      return crypto.hashAndSign(this._key, message)\n    }\n\n    get public () {\n      return new Secp256k1PublicKey(this._publicKey)\n    }\n\n    marshal () {\n      return this._key\n    }\n\n    get bytes () {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      })\n    }\n\n    equals (key) {\n      return this.bytes.equals(key.bytes)\n    }\n\n    hash () {\n      return sha.multihashing(this.bytes, 'sha2-256')\n    }\n\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n    async id () {\n      const hash = await this.public.hash()\n      return multibase.encode('base58btc', hash).toString().slice(1)\n    }\n\n    /**\n     * Exports the key into a password protected `format`\n     *\n     * @param {string} password - The password to encrypt the key\n     * @param {string} [format=libp2p-key] - The format in which to export as\n     * @returns {Promise<string>} The encrypted private key\n     */\n    async export (password, format = 'libp2p-key') { // eslint-disable-line require-await\n      if (format === 'libp2p-key') {\n        return exporter.export(this.bytes, password)\n      } else {\n        throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n      }\n    }\n  }\n\n  function unmarshalSecp256k1PrivateKey (bytes) {\n    return new Secp256k1PrivateKey(bytes)\n  }\n\n  function unmarshalSecp256k1PublicKey (bytes) {\n    return new Secp256k1PublicKey(bytes)\n  }\n\n  async function generateKeyPair () {\n    const privateKeyBytes = await crypto.generateKey()\n    return new Secp256k1PrivateKey(privateKeyBytes)\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  }\n}\n"]},"metadata":{},"sourceType":"script"}