{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GrpcAuthentication = void 0;\n\nconst context_1 = require(\"@textile/context\");\n\nconst grpc_connection_1 = require(\"@textile/grpc-connection\");\n\nconst hub_threads_client_1 = require(\"@textile/hub-threads-client\");\n/**\n * Not for external use. Defines the authorization, authentication, and\n * API scoping methods used by gRPC API client classes such as Users and Buckets.\n *\n * @internal\n */\n\n\nclass GrpcAuthentication extends grpc_connection_1.GrpcConnection {\n  /**\n   * Copies the full scope and authentication from one API instance to this one.\n   * This will copy any existing authentication and authorization info, including:\n   *\n   *   - Information created withKeyInfo and withUserAuth.\n   *\n   *   - Any token generated from getToken or getTokenChallenge.\n   *\n   *   - If you scoped the instance to a specific thread using withThread\n   *\n   * @param auth any authenticated API class such as Users or Buckets.\n   *\n   * @example\n   * Copy an authenticated Users api instance to Buckets.\n   * ```typescript\n   * import { Buckets, Users } from '@textile/hub'\n   *\n   * const usersToBuckets = async (user: Users) => {\n   *   const buckets = Buckets.copyAuth(user)\n   *   return buckets\n   * }\n   * ```\n   *\n   * @example\n   * Copy an authenticated Buckets api instance to Users.\n   * ```typescript\n   * import { Buckets, Users } from '@textile/hub'\n   *\n   * const bucketsToUsers = async (buckets: Buckets) => {\n   *   const user = Users.copyAuth(buckets)\n   *   return user\n   * }\n   * ```\n   */\n  static copyAuth(auth, options = {}) {\n    return new GrpcAuthentication(auth.context, options.debug);\n  }\n  /**\n   * Creates a new API client instance for accessing the gRPC API\n   * using User Group key authentication. This method is recommended for\n   * public apps where API secrets need to remain hidden from end users.\n   * @param auth The UserAuth object.\n   *\n   * @example\n   * ```@typescript\n   * import { Client, UserAuth } from '@textile/hub'\n   *\n   * async function example (userAuth: UserAuth) {\n   *   const client = await Client.withUserAuth(userAuth)\n   * }\n   * ```\n   */\n\n\n  static withUserAuth(auth, options = {}) {\n    const context = typeof auth === 'object' ? context_1.Context.fromUserAuth(auth, options.host) : context_1.Context.fromUserAuthCallback(auth, options.host);\n    return new GrpcAuthentication(context, options.debug);\n  }\n  /**\n   * Creates a new API client instance for accessing the gRPC API\n   * using key & secret based authentication. This method is recommended\n   * for admin or insecure implementations where the non-signing keys or\n   * key with secret can be embedded directly in an app.\n   * @param key The KeyInfo object containing {key: string, secret: string}\n   *\n   * @example\n   * ```@typescript\n   * import { Client, KeyInfo } from '@textile/hub'\n   *\n   * async function start () {\n   *   const keyInfo: KeyInfo = {\n   *     key: '<api key>',\n   *     secret: '<api secret>'\n   *   }\n   *   const client = await Client.withKeyInfo(keyInfo)\n   * }\n   * ```\n   */\n\n\n  static withKeyInfo(key, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const context = new context_1.Context(options.host);\n      yield context.withKeyInfo(key, options.date);\n      return new GrpcAuthentication(context, options.debug);\n    });\n  }\n  /**\n   * Scope future API calls to a specific thread.\n   * For both Buckets and Threads, many API calls require knowledge\n   * about which thread you are making requests against. Use `withThread`\n   * to declare your target thread before making those API calls.\n   * @param threadId the ID of the thread\n   *\n   * @example\n   * ```@typescript\n   * import { Client, ThreadID } from '@textile/hub'\n   *\n   * async function example (threadID: ThreadID) {\n   *   const client = await Client.withThread(threadID)\n   * }\n   * ```\n   */\n\n\n  withThread(threadID) {\n    if (threadID === undefined) return;\n    this.context.withThread(threadID);\n  }\n  /**\n   * Obtain a token for interacting with the remote API.\n   * When your app is creating new private-key based users to interact with\n   * the API using User Group keys, you must first create a new token for\n   * each new user. Tokens do not change after you create them.\n   * @param identity A user identity to use for interacting with APIs.\n   *\n   * @example\n   * ```@typescript\n   * import { Client, PrivateKey } from '@textile/hub'\n   *\n   * async function example (client: Client, identity: PrivateKey) {\n   *   const token = await client.getToken(identity)\n   *   return token\n   * }\n   * ```\n   */\n\n\n  getToken(identity) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = new hub_threads_client_1.Client(this.context);\n      const token = yield client.getToken(identity);\n      this.context.withToken(token);\n      return token;\n    });\n  }\n  /**\n   * Obtain a token for interacting with the remote API.\n   * When your app is creating new private-key based users to interact with\n   * the API using User Group keys, you must first create a new token for\n   * each new user. Tokens do not change after you create them. This callback\n   * method will require you to handle challenge signing.\n   * @param identity A user identity to use for interacting with buckets.\n   * @param callback A callback function that takes a `challenge` argument and returns a signed\n   * message using the input challenge and the private key associated with `publicKey`.\n   * @note `publicKey` must be the corresponding public key of the private key used in `callback`.\n   *\n   * @example\n   * ```typescript\n   * import { Client, PrivateKey } from '@textile/hub'\n   *\n   * async function example (client: Client, identity: PrivateKey) {\n   *   const token = await client.getTokenChallenge(\n   *     identity.pubKey,\n   *     (challenge: Uint8Array) => {\n   *       return new Promise((resolve, reject) => {\n   *         // This is where you should program PrivateKey to respond to challenge\n   *         // Read more here: https://docs.textile.io/tutorials/hub/production-auth/\n   *       }\n   *     }\n   *   )\n   *   return token\n   * }\n   * ```\n   */\n\n\n  getTokenChallenge(publicKey, callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = new hub_threads_client_1.Client(this.context);\n      return client.getTokenChallenge(publicKey, callback);\n    });\n  }\n\n}\n\nexports.GrpcAuthentication = GrpcAuthentication;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAGA,MAAA,oBAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;AA4CA;;;;;;;;AAMA,MAAa,kBAAb,SAAwC,iBAAA,CAAA,cAAxC,CAAsD;AACpD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,SAAO,QAAP,CAAgB,IAAhB,EAA0C,OAAA,GAA2B,EAArE,EAAuE;AACrE,WAAO,IAAI,kBAAJ,CAAuB,IAAI,CAAC,OAA5B,EAAqC,OAAO,CAAC,KAA7C,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;AAeA,SAAO,YAAP,CAAoB,IAApB,EAAgE,OAAA,GAA+B,EAA/F,EAAiG;AAC/F,UAAM,OAAO,GACX,OAAO,IAAP,KAAgB,QAAhB,GACI,SAAA,CAAA,OAAA,CAAQ,YAAR,CAAqB,IAArB,EAA2B,OAAO,CAAC,IAAnC,CADJ,GAEI,SAAA,CAAA,OAAA,CAAQ,oBAAR,CAA6B,IAA7B,EAAmC,OAAO,CAAC,IAA3C,CAHN;AAIA,WAAO,IAAI,kBAAJ,CAAuB,OAAvB,EAAgC,OAAO,CAAC,KAAxC,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;AAoBA,SAAa,WAAb,CAAyB,GAAzB,EAAuC,OAAA,GAA8B,EAArE,EAAuE;;AACrE,YAAM,OAAO,GAAG,IAAI,SAAA,CAAA,OAAJ,CAAY,OAAO,CAAC,IAApB,CAAhB;AACA,YAAM,OAAO,CAAC,WAAR,CAAoB,GAApB,EAAyB,OAAO,CAAC,IAAjC,CAAN;AACA,aAAO,IAAI,kBAAJ,CAAuB,OAAvB,EAAgC,OAAO,CAAC,KAAxC,CAAP;AACD,K;AAAA;AAED;;;;;;;;;;;;;;;;;;AAgBA,EAAA,UAAU,CAAC,QAAD,EAAkB;AAC1B,QAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC5B,SAAK,OAAL,CAAa,UAAb,CAAwB,QAAxB;AACD;AAED;;;;;;;;;;;;;;;;;;;AAiBM,EAAA,QAAQ,CAAC,QAAD,EAAmB;;AAC/B,YAAM,MAAM,GAAG,IAAI,oBAAA,CAAA,MAAJ,CAAW,KAAK,OAAhB,CAAf;AACA,YAAM,KAAK,GAAG,MAAM,MAAM,CAAC,QAAP,CAAgB,QAAhB,CAApB;AACA,WAAK,OAAL,CAAa,SAAb,CAAuB,KAAvB;AACA,aAAO,KAAP;AACD,K;AAAA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BM,EAAA,iBAAiB,CACrB,SADqB,EAErB,QAFqB,EAEgD;;AAErE,YAAM,MAAM,GAAG,IAAI,oBAAA,CAAA,MAAJ,CAAW,KAAK,OAAhB,CAAf;AACA,aAAO,MAAM,CAAC,iBAAP,CAAyB,SAAzB,EAAoC,QAApC,CAAP;AACD,K;AAAA;;AAzKmD;;AAAtD,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GrpcAuthentication = void 0;\nconst context_1 = require(\"@textile/context\");\nconst grpc_connection_1 = require(\"@textile/grpc-connection\");\nconst hub_threads_client_1 = require(\"@textile/hub-threads-client\");\n/**\n * Not for external use. Defines the authorization, authentication, and\n * API scoping methods used by gRPC API client classes such as Users and Buckets.\n *\n * @internal\n */\nclass GrpcAuthentication extends grpc_connection_1.GrpcConnection {\n    /**\n     * Copies the full scope and authentication from one API instance to this one.\n     * This will copy any existing authentication and authorization info, including:\n     *\n     *   - Information created withKeyInfo and withUserAuth.\n     *\n     *   - Any token generated from getToken or getTokenChallenge.\n     *\n     *   - If you scoped the instance to a specific thread using withThread\n     *\n     * @param auth any authenticated API class such as Users or Buckets.\n     *\n     * @example\n     * Copy an authenticated Users api instance to Buckets.\n     * ```typescript\n     * import { Buckets, Users } from '@textile/hub'\n     *\n     * const usersToBuckets = async (user: Users) => {\n     *   const buckets = Buckets.copyAuth(user)\n     *   return buckets\n     * }\n     * ```\n     *\n     * @example\n     * Copy an authenticated Buckets api instance to Users.\n     * ```typescript\n     * import { Buckets, Users } from '@textile/hub'\n     *\n     * const bucketsToUsers = async (buckets: Buckets) => {\n     *   const user = Users.copyAuth(buckets)\n     *   return user\n     * }\n     * ```\n     */\n    static copyAuth(auth, options = {}) {\n        return new GrpcAuthentication(auth.context, options.debug);\n    }\n    /**\n     * Creates a new API client instance for accessing the gRPC API\n     * using User Group key authentication. This method is recommended for\n     * public apps where API secrets need to remain hidden from end users.\n     * @param auth The UserAuth object.\n     *\n     * @example\n     * ```@typescript\n     * import { Client, UserAuth } from '@textile/hub'\n     *\n     * async function example (userAuth: UserAuth) {\n     *   const client = await Client.withUserAuth(userAuth)\n     * }\n     * ```\n     */\n    static withUserAuth(auth, options = {}) {\n        const context = typeof auth === 'object'\n            ? context_1.Context.fromUserAuth(auth, options.host)\n            : context_1.Context.fromUserAuthCallback(auth, options.host);\n        return new GrpcAuthentication(context, options.debug);\n    }\n    /**\n     * Creates a new API client instance for accessing the gRPC API\n     * using key & secret based authentication. This method is recommended\n     * for admin or insecure implementations where the non-signing keys or\n     * key with secret can be embedded directly in an app.\n     * @param key The KeyInfo object containing {key: string, secret: string}\n     *\n     * @example\n     * ```@typescript\n     * import { Client, KeyInfo } from '@textile/hub'\n     *\n     * async function start () {\n     *   const keyInfo: KeyInfo = {\n     *     key: '<api key>',\n     *     secret: '<api secret>'\n     *   }\n     *   const client = await Client.withKeyInfo(keyInfo)\n     * }\n     * ```\n     */\n    static withKeyInfo(key, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const context = new context_1.Context(options.host);\n            yield context.withKeyInfo(key, options.date);\n            return new GrpcAuthentication(context, options.debug);\n        });\n    }\n    /**\n     * Scope future API calls to a specific thread.\n     * For both Buckets and Threads, many API calls require knowledge\n     * about which thread you are making requests against. Use `withThread`\n     * to declare your target thread before making those API calls.\n     * @param threadId the ID of the thread\n     *\n     * @example\n     * ```@typescript\n     * import { Client, ThreadID } from '@textile/hub'\n     *\n     * async function example (threadID: ThreadID) {\n     *   const client = await Client.withThread(threadID)\n     * }\n     * ```\n     */\n    withThread(threadID) {\n        if (threadID === undefined)\n            return;\n        this.context.withThread(threadID);\n    }\n    /**\n     * Obtain a token for interacting with the remote API.\n     * When your app is creating new private-key based users to interact with\n     * the API using User Group keys, you must first create a new token for\n     * each new user. Tokens do not change after you create them.\n     * @param identity A user identity to use for interacting with APIs.\n     *\n     * @example\n     * ```@typescript\n     * import { Client, PrivateKey } from '@textile/hub'\n     *\n     * async function example (client: Client, identity: PrivateKey) {\n     *   const token = await client.getToken(identity)\n     *   return token\n     * }\n     * ```\n     */\n    getToken(identity) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = new hub_threads_client_1.Client(this.context);\n            const token = yield client.getToken(identity);\n            this.context.withToken(token);\n            return token;\n        });\n    }\n    /**\n     * Obtain a token for interacting with the remote API.\n     * When your app is creating new private-key based users to interact with\n     * the API using User Group keys, you must first create a new token for\n     * each new user. Tokens do not change after you create them. This callback\n     * method will require you to handle challenge signing.\n     * @param identity A user identity to use for interacting with buckets.\n     * @param callback A callback function that takes a `challenge` argument and returns a signed\n     * message using the input challenge and the private key associated with `publicKey`.\n     * @note `publicKey` must be the corresponding public key of the private key used in `callback`.\n     *\n     * @example\n     * ```typescript\n     * import { Client, PrivateKey } from '@textile/hub'\n     *\n     * async function example (client: Client, identity: PrivateKey) {\n     *   const token = await client.getTokenChallenge(\n     *     identity.pubKey,\n     *     (challenge: Uint8Array) => {\n     *       return new Promise((resolve, reject) => {\n     *         // This is where you should program PrivateKey to respond to challenge\n     *         // Read more here: https://docs.textile.io/tutorials/hub/production-auth/\n     *       }\n     *     }\n     *   )\n     *   return token\n     * }\n     * ```\n     */\n    getTokenChallenge(publicKey, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = new hub_threads_client_1.Client(this.context);\n            return client.getTokenChallenge(publicKey, callback);\n        });\n    }\n}\nexports.GrpcAuthentication = GrpcAuthentication;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}