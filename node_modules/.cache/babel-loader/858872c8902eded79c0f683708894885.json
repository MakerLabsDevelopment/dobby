{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.listPathFlat = exports.listPathRecursive = exports.bytesToArray = void 0;\n\nconst api_1 = require(\"./api\");\n/**\n * bytesToArray converts a buffer into <4mb chunks for use with grpc API\n * @param chunk an input Buffer or Uint8Array\n */\n\n\nfunction bytesToArray(chunk, size = 1024 * 1024 * 3) {\n  const result = [];\n  const len = chunk.length;\n  let i = 0;\n\n  while (i < len) {\n    result.push(chunk.slice(i, i += size));\n  }\n\n  return result;\n}\n\nexports.bytesToArray = bytesToArray;\n/**\n * listPathRecursive returns a nested object of all paths (and info) in a bucket\n */\n\nfunction listPathRecursive(grpc, bucketKey, path, depth, currentDepth = 0) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const rootPath = path === '' || path === '.' || path === '/' ? '' : `${path}/`;\n    const tree = yield api_1.bucketsListPath(grpc, bucketKey, path);\n\n    if (tree.item && (currentDepth + 1 <= depth || depth === -1)) {\n      for (let i = 0; i < tree.item.itemsList.length; i++) {\n        const obj = tree.item.itemsList[i];\n        if (!obj.isdir) continue;\n        const dirPath = `${rootPath}${obj.name}`;\n        const {\n          item\n        } = yield listPathRecursive(grpc, bucketKey, dirPath, depth, currentDepth + 1);\n\n        if (item) {\n          tree.item.itemsList[i] = item;\n        }\n      }\n    }\n\n    return tree;\n  });\n}\n\nexports.listPathRecursive = listPathRecursive;\n\nfunction treeToPaths(tree, path, dirs = true, depth = 5, currentDepth = 0) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const result = [];\n\n    for (const item of tree) {\n      const newPath = path === '' ? `${item.name}` : `${path}/${item.name}`;\n      if (dirs || !item.isdir) result.push(newPath);\n\n      if (item.isdir && (currentDepth < depth || depth === -1)) {\n        const downtree = yield treeToPaths(item.itemsList, newPath, dirs, depth, currentDepth + 1);\n        result.push(...downtree);\n      }\n    }\n\n    return result;\n  });\n}\n/**\n * listPathFlat returns a string array of all paths in a bucket\n */\n\n\nfunction listPathFlat(grpc, bucketKey, path, dirs, depth) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tree = yield listPathRecursive(grpc, bucketKey, path, depth);\n    if (!tree.item) return [];\n    return treeToPaths(tree.item.itemsList, path, dirs);\n  });\n}\n\nexports.listPathFlat = listPathFlat;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.listPathFlat = exports.listPathRecursive = exports.bytesToArray = void 0;\nconst api_1 = require(\"./api\");\n/**\n * bytesToArray converts a buffer into <4mb chunks for use with grpc API\n * @param chunk an input Buffer or Uint8Array\n */\nfunction bytesToArray(chunk, size = 1024 * 1024 * 3) {\n    const result = [];\n    const len = chunk.length;\n    let i = 0;\n    while (i < len) {\n        result.push(chunk.slice(i, (i += size)));\n    }\n    return result;\n}\nexports.bytesToArray = bytesToArray;\n/**\n * listPathRecursive returns a nested object of all paths (and info) in a bucket\n */\nfunction listPathRecursive(grpc, bucketKey, path, depth, currentDepth = 0) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const rootPath = path === '' || path === '.' || path === '/' ? '' : `${path}/`;\n        const tree = yield api_1.bucketsListPath(grpc, bucketKey, path);\n        if (tree.item && (currentDepth + 1 <= depth || depth === -1)) {\n            for (let i = 0; i < tree.item.itemsList.length; i++) {\n                const obj = tree.item.itemsList[i];\n                if (!obj.isdir)\n                    continue;\n                const dirPath = `${rootPath}${obj.name}`;\n                const { item } = yield listPathRecursive(grpc, bucketKey, dirPath, depth, currentDepth + 1);\n                if (item) {\n                    tree.item.itemsList[i] = item;\n                }\n            }\n        }\n        return tree;\n    });\n}\nexports.listPathRecursive = listPathRecursive;\nfunction treeToPaths(tree, path, dirs = true, depth = 5, currentDepth = 0) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = [];\n        for (const item of tree) {\n            const newPath = path === '' ? `${item.name}` : `${path}/${item.name}`;\n            if (dirs || !item.isdir)\n                result.push(newPath);\n            if (item.isdir && (currentDepth < depth || depth === -1)) {\n                const downtree = yield treeToPaths(item.itemsList, newPath, dirs, depth, currentDepth + 1);\n                result.push(...downtree);\n            }\n        }\n        return result;\n    });\n}\n/**\n * listPathFlat returns a string array of all paths in a bucket\n */\nfunction listPathFlat(grpc, bucketKey, path, dirs, depth) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const tree = yield listPathRecursive(grpc, bucketKey, path, depth);\n        if (!tree.item)\n            return [];\n        return treeToPaths(tree.item.itemsList, path, dirs);\n    });\n}\nexports.listPathFlat = listPathFlat;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}