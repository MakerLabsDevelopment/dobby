{"ast":null,"code":"import { set, updateAll } from 'shades';\nimport { createSelector } from 'redux-bundler';\nimport { ThreadID } from '@textile/hub';\nexport default {\n  name: 'threads',\n  getReducer: () => {\n    const initialData = {\n      active: {\n        collections: null,\n        threadId: null\n      },\n      loading: false,\n      data: null\n    };\n    return (state = initialData, {\n      type,\n      payload,\n      err\n    }) => {\n      if (type.startsWith('THREADS') && type.endsWith('_START')) {\n        return set('loading')(true)(state);\n      }\n\n      if (type === 'THREADS_RESET') {\n        return initialData;\n      }\n\n      if (type === 'THREADS_FETCH_SUCCESS') {\n        return updateAll(set('data')(payload.listList), set('loading')(false))(state);\n      }\n\n      if (type === 'THREADS_FETCH_FAILED') {\n        return updateAll(set('data')(null), set('loading')(false))(state);\n      }\n\n      if (type === 'THREADS_SET_ACTIVE') {\n        return updateAll(set('active', 'collections')(payload.collections), set('active', 'threadId')(payload.id))(state);\n      }\n\n      return state;\n    };\n  },\n  doThreadsFetch: client => {\n    return ({\n      dispatch,\n      store\n    }) => {\n      dispatch({\n        type: 'THREADS_FETCH_START'\n      });\n      return client.listThreads().then(payload => {\n        return dispatch({\n          type: 'THREADS_FETCH_SUCCESS',\n          payload\n        });\n      }).catch(err => {\n        return dispatch({\n          type: 'THREADS_FETCH_FAILED',\n          err\n        });\n      });\n    };\n  },\n  doThreadsCreate: () => {\n    return async ({\n      dispatch,\n      store\n    }) => {\n      dispatch({\n        type: 'THREADS_ADD_START'\n      });\n      const client = await store.selectAuthClient();\n      const threadId = client.newDB();\n      return threadId.then(payload => {\n        return dispatch({\n          type: 'THREADS_ADD_SUCCESS',\n          payload\n        });\n      }).catch(err => {\n        return dispatch({\n          type: 'THREADS_ADD_FAILED',\n          err\n        });\n      });\n    };\n  },\n  doThreadsSetActive: threadId => {\n    return async ({\n      dispatch,\n      store\n    }) => {\n      const {\n        authClient\n      } = store.select(['selectAuthClient']);\n      const id = ThreadID.fromString(threadId);\n      const collections = await authClient.listCollections(id);\n      const result = await dispatch({\n        type: 'THREADS_SET_ACTIVE',\n        payload: {\n          collections,\n          id\n        }\n      });\n      return result;\n    };\n  },\n  reactThreadsPath: createSelector('selectThreadsActive', 'selectAuthClient', 'selectThreadsData', 'selectThreadsLoading', 'selectPathname', 'selectRouteParams', (active, client, data, loading, pathname, {\n    threadId\n  }) => {\n    if (client && active && pathname.match(/\\/threads/) && !loading && !threadId) {\n      return {\n        actionCreator: 'doThreadsSetActive',\n        args: [null]\n      };\n    }\n\n    if (client && data && !loading && threadId && !active) {\n      return {\n        actionCreator: 'doThreadsSetActive',\n        args: [threadId]\n      };\n    }\n  }),\n  reactThreadsShouldFetch: createSelector('selectAuthClient', 'selectThreadsData', 'selectThreadsLoading', (authClient, threadsData, loading) => {\n    if (authClient && !threadsData && !loading) {\n      return {\n        actionCreator: 'doThreadsFetch',\n        args: [authClient]\n      };\n    }\n  }),\n  selectThreadsLoading: state => state.threads.loading,\n  selectThreadsData: state => state.threads.data,\n  selectThreadsActive: state => state.threads.active\n};","map":{"version":3,"sources":["/Users/nassarhayat/apps/textiletable/dobby/src/bundles/threads.js"],"names":["set","updateAll","createSelector","ThreadID","name","getReducer","initialData","active","collections","threadId","loading","data","state","type","payload","err","startsWith","endsWith","listList","id","doThreadsFetch","client","dispatch","store","listThreads","then","catch","doThreadsCreate","selectAuthClient","newDB","doThreadsSetActive","authClient","select","fromString","listCollections","result","reactThreadsPath","pathname","match","actionCreator","args","reactThreadsShouldFetch","threadsData","selectThreadsLoading","threads","selectThreadsData","selectThreadsActive"],"mappings":"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","sourcesContent":["import { set, updateAll } from 'shades'\nimport { createSelector } from 'redux-bundler'\nimport { ThreadID } from '@textile/hub'\n\nexport default {\n  name: 'threads',\n  getReducer: () => {\n    const initialData = {\n      active: {\n        collections: null,\n        threadId: null\n      },\n      loading: false,\n      data: null,\n\n    }\n    return (state = initialData, { type, payload, err }) => {\n      if (type.startsWith('THREADS') && type.endsWith('_START')) {\n        return set('loading')(true)(state)\n      }\n\n      if (type === 'THREADS_RESET') {\n        return initialData\n      }\n\n      if (type === 'THREADS_FETCH_SUCCESS') {\n        return updateAll(\n          set('data')(payload.listList),\n          set('loading')(false)\n        )(state)\n      }\n\n      if (type === 'THREADS_FETCH_FAILED') {\n        return updateAll(\n          set('data')(null),\n          set('loading')(false)\n        )(state)\n      }\n\n      if (type === 'THREADS_SET_ACTIVE') {\n        return updateAll(\n          set('active', 'collections')(payload.collections),\n          set('active', 'threadId')(payload.id)\n        )(state)\n      }\n\n      return state\n    }\n  },\n  doThreadsFetch: (client) => {\n    return ({ dispatch, store }) => {\n      dispatch({ type: 'THREADS_FETCH_START' })\n      return client.listThreads().then((payload) => {\n        return dispatch({ type: 'THREADS_FETCH_SUCCESS', payload })\n      }).catch((err) => {\n        return dispatch({ type: 'THREADS_FETCH_FAILED', err })\n      })\n    }\n  },\n  doThreadsCreate: () => {\n    return async ({ dispatch, store }) => {\n      dispatch({ type: 'THREADS_ADD_START' })\n      const client = await store.selectAuthClient()\n      const threadId = client.newDB()\n      return threadId.then((payload) => {\n        return dispatch({ type: 'THREADS_ADD_SUCCESS', payload })\n      }).catch((err) => {\n        return dispatch({ type: 'THREADS_ADD_FAILED', err })\n      })\n    }\n  },\n  doThreadsSetActive: (threadId) => {\n    return async ({ dispatch, store }) => {\n      const { authClient } = store.select(['selectAuthClient'])\n      const id = ThreadID.fromString(threadId)\n      const collections = await authClient.listCollections(id)\n      const result = await dispatch({ type: 'THREADS_SET_ACTIVE', payload: { collections, id } })\n      return result\n    }\n  },\n  reactThreadsPath: createSelector(\n    'selectThreadsActive',\n    'selectAuthClient',\n    'selectThreadsData',\n    'selectThreadsLoading',\n    'selectPathname',\n    'selectRouteParams',\n    (active, client, data, loading, pathname, { threadId }) => {\n      if (client && active && pathname.match(/\\/threads/) && !loading && !threadId) {\n        return { actionCreator: 'doThreadsSetActive', args: [null] }\n      }\n      if (client && data && !loading && threadId && !active) {\n        return { actionCreator: 'doThreadsSetActive', args: [threadId] }\n      }\n    },\n  ),\n  reactThreadsShouldFetch: createSelector(\n    'selectAuthClient',\n    'selectThreadsData',\n    'selectThreadsLoading',\n    (authClient, threadsData, loading) => {\n      if (authClient && !threadsData && !loading) {\n        return { actionCreator: 'doThreadsFetch', args: [authClient] }\n      }\n    },\n  ),\n  selectThreadsLoading: state => state.threads.loading,\n  selectThreadsData: state => state.threads.data,\n  selectThreadsActive: state => state.threads.active,\n}\n"]},"metadata":{},"sourceType":"module"}