{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WriteTransaction = void 0;\n\nconst threads_pb_1 = require(\"@textile/threads-client-grpc/threads_pb\");\n\nconst Transaction_1 = require(\"./Transaction\");\n\nconst decoder = new TextDecoder();\n/**\n * WriteTransaction performs a mutating bulk transaction on the underlying store.\n * {@inheritDoc @textile/threads-client#Transaction}\n * @example\n * Create a new entry in our collection\n * ```typescript\n * import {Client, ThreadID} from '@textile/threads'\n *\n * interface Astronaut {\n *   name: string\n *   missions: number\n *   _id: string\n * }\n *\n * async function createBuzz (client: Client, threadID: ThreadID) {\n *   const buzz: Astronaut = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *\n *   const t = client.writeTransaction(threadID, 'astronauts')\n *   await t.start()\n *   await t.create([buzz])\n *   await t.end() // Commit\n * }\n * ```\n *\n * @example\n * Abort an in-flight transaction\n * ```typescript\n * import {Client, ThreadID} from '@textile/threads'\n *\n * interface Astronaut {\n *   name: string\n *   missions: number\n *   _id: string\n * }\n *\n * async function createBuzz (client: Client, threadID: ThreadID) {\n *   const buzz: Astronaut = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *\n *   const t = client.writeTransaction(threadID, 'astronauts')\n *   await t.start()\n *   await t.create([buzz])\n *   await t.discard() // Abort\n *   await t.end()\n * }\n * ```\n */\n\nclass WriteTransaction extends Transaction_1.Transaction {\n  constructor(context, client, threadID, modelName) {\n    super(client, threadID, modelName);\n    this.context = context;\n    this.client = client;\n    this.threadID = threadID;\n    this.modelName = modelName;\n  }\n  /**\n   * start begins the transaction. All operations between start and end will be applied as a single transaction upon a call to end.\n   */\n\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const startReq = new threads_pb_1.StartTransactionRequest();\n      startReq.setDbid(this.threadID.toBytes());\n      startReq.setCollectionname(this.modelName);\n      const req = new threads_pb_1.WriteTransactionRequest();\n      req.setStarttransactionrequest(startReq);\n      const metadata = JSON.parse(JSON.stringify(this.context));\n      this.client.start(metadata);\n      this.client.send(req);\n    });\n  }\n  /**\n   * create creates a new model instance in the given store.\n   * @param values An array of model instances as JSON/JS objects.\n   */\n\n\n  create(values) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const createReq = new threads_pb_1.CreateRequest();\n        const list = [];\n        values.forEach(v => {\n          list.push(Buffer.from(JSON.stringify(v)));\n        });\n        createReq.setInstancesList(list);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setCreaterequest(createReq);\n        this.client.onMessage(message => {\n          const reply = message.getCreatereply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          if (reply === undefined) {\n            resolve();\n          } else {\n            resolve(reply.toObject().instanceidsList);\n          }\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * save saves changes to an existing model instance in the given store.\n   * @param values An array of model instances as JSON/JS objects. Each model instance must have a valid existing `ID` property.\n   */\n\n\n  save(values) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const saveReq = new threads_pb_1.SaveRequest();\n        const list = [];\n        values.forEach(v => {\n          if (!v.hasOwnProperty(\"_id\")) {\n            v[\"_id\"] = \"\"; // The server will add an _id if empty.\n          }\n\n          list.push(Buffer.from(JSON.stringify(v)));\n        });\n        saveReq.setInstancesList(list);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setSaverequest(saveReq);\n        this.client.onMessage(message => {\n          const reply = message.getSavereply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          resolve();\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * delete deletes an existing model instance from the given store.\n   * @param IDs An array of instance ids to delete.\n   */\n\n\n  delete(IDs) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const deleteReq = new threads_pb_1.DeleteRequest();\n        deleteReq.setInstanceidsList(IDs);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setDeleterequest(deleteReq);\n        this.client.onMessage(message => {\n          const reply = message.getSavereply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          resolve();\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * has checks whether a given instance exists in the given store.\n   * @param IDs An array of instance ids to check for.\n   */\n\n\n  has(IDs) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const hasReq = new threads_pb_1.HasRequest();\n        hasReq.setInstanceidsList(IDs);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setHasrequest(hasReq);\n        this.client.onMessage(message => {\n          const reply = message.getHasreply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          resolve(reply && reply.getExists());\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * find queries the store for entities matching the given query parameters. See Query for options.\n   * @param query The object that describes the query. See Query for options. Alternatively, see QueryJSON for the basic interface.\n   */\n\n\n  find(query) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const findReq = new threads_pb_1.FindRequest();\n        findReq.setQueryjson(Buffer.from(JSON.stringify(query)));\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setFindrequest(findReq);\n        this.client.onMessage(message => {\n          const reply = message.getFindreply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          if (reply === undefined) {\n            resolve();\n          } else {\n            // TODO: Clean this up to avoid using Buffer\n            const ret = {\n              instancesList: reply.toObject().instancesList.map(instance => JSON.parse(Buffer.from(instance, \"base64\").toString()))\n            };\n            resolve(ret);\n          }\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * findByID queries the store for the id of an instance.\n   * @param ID The id of the instance to search for.\n   */\n\n\n  findByID(ID) {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const findReq = new threads_pb_1.FindByIDRequest();\n        findReq.setInstanceid(ID);\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setFindbyidrequest(findReq);\n        this.client.onMessage(message => {\n          const reply = message.getFindbyidreply();\n          const err = reply === null || reply === void 0 ? void 0 : reply.getTransactionerror();\n\n          if (err) {\n            reject(new Error(err));\n          }\n\n          if (reply === undefined) {\n            resolve();\n          } else {\n            const ret = {\n              instance: JSON.parse(decoder.decode(reply.getInstance_asU8()))\n            };\n            resolve(ret);\n          }\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n  /**\n   * Discard drops all active transaction changes.\n   * It also invalidates the transaction, so it will fail upon calling end.\n   * @example\n   * Abort an in-flight transaction\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function example (client: Client, threadID: ThreadID) {\n   *   const buzz: Astronaut = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *\n   *   const t = client.writeTransaction(threadID, 'astronauts')\n   *   await t.start()\n   *   await t.create([buzz])\n   *   await t.discard() // Abort\n   *   await t.end()\n   * }\n   * ```\n   */\n\n\n  discard() {\n    const _super = Object.create(null, {\n      setReject: {\n        get: () => super.setReject\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        const req = new threads_pb_1.WriteTransactionRequest();\n        req.setDiscardrequest(new threads_pb_1.DiscardRequest());\n        this.client.onMessage(message => {\n          const reply = message.getDiscardreply();\n\n          if (reply) {\n            resolve();\n          } else {\n            reject(new Error(\"unexpected response type\"));\n          }\n        });\n\n        _super.setReject.call(this, reject);\n\n        this.client.send(req);\n      });\n    });\n  }\n\n}\n\nexports.WriteTransaction = WriteTransaction;","map":{"version":3,"sources":["../../src/models/WriteTransaction.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module @textile/threads-client/models\n */\nimport { grpc } from \"@improbable-eng/grpc-web\"\nimport { ContextInterface } from \"@textile/context\"\nimport {\n  CreateRequest,\n  DeleteRequest,\n  DiscardRequest,\n  FindByIDRequest,\n  FindRequest,\n  HasRequest,\n  SaveRequest,\n  StartTransactionRequest,\n  WriteTransactionReply,\n  WriteTransactionRequest,\n} from \"@textile/threads-client-grpc/threads_pb\"\nimport { ThreadID } from \"@textile/threads-id\"\nimport { Instance, InstanceList, QueryJSON } from \"./query\"\nimport { Transaction } from \"./Transaction\"\n\nconst decoder = new TextDecoder()\n\n/**\n * WriteTransaction performs a mutating bulk transaction on the underlying store.\n * {@inheritDoc @textile/threads-client#Transaction}\n * @example\n * Create a new entry in our collection\n * ```typescript\n * import {Client, ThreadID} from '@textile/threads'\n *\n * interface Astronaut {\n *   name: string\n *   missions: number\n *   _id: string\n * }\n *\n * async function createBuzz (client: Client, threadID: ThreadID) {\n *   const buzz: Astronaut = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *\n *   const t = client.writeTransaction(threadID, 'astronauts')\n *   await t.start()\n *   await t.create([buzz])\n *   await t.end() // Commit\n * }\n * ```\n *\n * @example\n * Abort an in-flight transaction\n * ```typescript\n * import {Client, ThreadID} from '@textile/threads'\n *\n * interface Astronaut {\n *   name: string\n *   missions: number\n *   _id: string\n * }\n *\n * async function createBuzz (client: Client, threadID: ThreadID) {\n *   const buzz: Astronaut = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *\n *   const t = client.writeTransaction(threadID, 'astronauts')\n *   await t.start()\n *   await t.create([buzz])\n *   await t.discard() // Abort\n *   await t.end()\n * }\n * ```\n */\nexport class WriteTransaction extends Transaction<\n  WriteTransactionRequest,\n  WriteTransactionReply\n> {\n  constructor(\n    protected readonly context: ContextInterface,\n    protected readonly client: grpc.Client<\n      WriteTransactionRequest,\n      WriteTransactionReply\n    >,\n    protected readonly threadID: ThreadID,\n    protected readonly modelName: string\n  ) {\n    super(client, threadID, modelName)\n  }\n  /**\n   * start begins the transaction. All operations between start and end will be applied as a single transaction upon a call to end.\n   */\n  public async start(): Promise<void> {\n    const startReq = new StartTransactionRequest()\n    startReq.setDbid(this.threadID.toBytes())\n    startReq.setCollectionname(this.modelName)\n    const req = new WriteTransactionRequest()\n    req.setStarttransactionrequest(startReq)\n    const metadata = JSON.parse(JSON.stringify(this.context))\n    this.client.start(metadata)\n    this.client.send(req)\n  }\n  /**\n   * create creates a new model instance in the given store.\n   * @param values An array of model instances as JSON/JS objects.\n   */\n  public async create<T = any>(values: any[]): Promise<string[] | undefined> {\n    return new Promise<Array<string> | undefined>((resolve, reject) => {\n      const createReq = new CreateRequest()\n      const list: any[] = []\n      values.forEach((v) => {\n        list.push(Buffer.from(JSON.stringify(v)))\n      })\n      createReq.setInstancesList(list)\n      const req = new WriteTransactionRequest()\n      req.setCreaterequest(createReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getCreatereply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        if (reply === undefined) {\n          resolve()\n        } else {\n          resolve(reply.toObject().instanceidsList)\n        }\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * save saves changes to an existing model instance in the given store.\n   * @param values An array of model instances as JSON/JS objects. Each model instance must have a valid existing `ID` property.\n   */\n  public async save(values: any[]): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const saveReq = new SaveRequest()\n      const list: any[] = []\n      values.forEach((v) => {\n        if (!v.hasOwnProperty(\"_id\")) {\n          v[\"_id\"] = \"\" // The server will add an _id if empty.\n        }\n        list.push(Buffer.from(JSON.stringify(v)))\n      })\n      saveReq.setInstancesList(list)\n      const req = new WriteTransactionRequest()\n      req.setSaverequest(saveReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getSavereply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        resolve()\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * delete deletes an existing model instance from the given store.\n   * @param IDs An array of instance ids to delete.\n   */\n  public async delete(IDs: string[]): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const deleteReq = new DeleteRequest()\n      deleteReq.setInstanceidsList(IDs)\n      const req = new WriteTransactionRequest()\n      req.setDeleterequest(deleteReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getSavereply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        resolve()\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n  /**\n   * has checks whether a given instance exists in the given store.\n   * @param IDs An array of instance ids to check for.\n   */\n  public async has(IDs: string[]): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      const hasReq = new HasRequest()\n      hasReq.setInstanceidsList(IDs)\n      const req = new WriteTransactionRequest()\n      req.setHasrequest(hasReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getHasreply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        resolve(reply && reply.getExists())\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n  /**\n   * find queries the store for entities matching the given query parameters. See Query for options.\n   * @param query The object that describes the query. See Query for options. Alternatively, see QueryJSON for the basic interface.\n   */\n  public async find<T = any>(query: QueryJSON): Promise<InstanceList<T>> {\n    return new Promise<InstanceList<T>>((resolve, reject) => {\n      const findReq = new FindRequest()\n      findReq.setQueryjson(Buffer.from(JSON.stringify(query)))\n      const req = new WriteTransactionRequest()\n      req.setFindrequest(findReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getFindreply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        if (reply === undefined) {\n          resolve()\n        } else {\n          // TODO: Clean this up to avoid using Buffer\n          const ret: InstanceList<T> = {\n            instancesList: reply\n              .toObject()\n              .instancesList.map((instance) =>\n                JSON.parse(Buffer.from(instance as string, \"base64\").toString())\n              ),\n          }\n          resolve(ret)\n        }\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * findByID queries the store for the id of an instance.\n   * @param ID The id of the instance to search for.\n   */\n  public async findByID<T = any>(ID: string): Promise<Instance<T> | undefined> {\n    return new Promise<Instance<T> | undefined>((resolve, reject) => {\n      const findReq = new FindByIDRequest()\n      findReq.setInstanceid(ID)\n      const req = new WriteTransactionRequest()\n      req.setFindbyidrequest(findReq)\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getFindbyidreply()\n        const err = reply?.getTransactionerror()\n        if (err) {\n          reject(new Error(err))\n        }\n        if (reply === undefined) {\n          resolve()\n        } else {\n          const ret: Instance<T> = {\n            instance: JSON.parse(decoder.decode(reply.getInstance_asU8())),\n          }\n          resolve(ret)\n        }\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n\n  /**\n   * Discard drops all active transaction changes.\n   * It also invalidates the transaction, so it will fail upon calling end.\n   * @example\n   * Abort an in-flight transaction\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function example (client: Client, threadID: ThreadID) {\n   *   const buzz: Astronaut = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *\n   *   const t = client.writeTransaction(threadID, 'astronauts')\n   *   await t.start()\n   *   await t.create([buzz])\n   *   await t.discard() // Abort\n   *   await t.end()\n   * }\n   * ```\n   */\n  public async discard(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const req = new WriteTransactionRequest()\n      req.setDiscardrequest(new DiscardRequest())\n      this.client.onMessage((message: WriteTransactionReply) => {\n        const reply = message.getDiscardreply()\n        if (reply) {\n          resolve()\n        } else {\n          reject(new Error(\"unexpected response type\"))\n        }\n      })\n      super.setReject(reject)\n      this.client.send(req)\n    })\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}