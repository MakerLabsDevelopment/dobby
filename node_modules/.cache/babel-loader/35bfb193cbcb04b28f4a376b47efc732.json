{"ast":null,"code":"var _jsxFileName = \"/Users/nassarhayat/apps/textiletable/js-examples/bucket-photo-gallery/src/App.tsx\";\nimport React from 'react';\nimport Avatar from './Avatar';\nimport Photos from './Photos';\nimport \"semantic-ui-css/semantic.min.css\";\nimport Dropzone from 'react-dropzone'; // @ts-ignore\n\nimport browserImageSize from 'browser-image-size'; // @ts-ignore\n\nimport { readAndCompressImage } from 'browser-image-resizer';\nimport { Buckets, PrivateKey } from '@textile/hub';\nimport { Button, Header, Segment } from \"semantic-ui-react\";\nimport './App.css';\n\nclass App extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.keyInfo = {\n      key: 'AKLSlskdjfsoi23lkjf23o9f'\n    };\n    this.state = {\n      metadata: [],\n      photos: [],\n      isLoading: true,\n      isDragActive: false,\n      index: {\n        author: '',\n        date: 0,\n        paths: []\n      }\n    };\n\n    this.getIdentity = async () => {\n      try {\n        var storedIdent = localStorage.getItem(\"identity\");\n\n        if (storedIdent === null) {\n          throw new Error('No identity');\n        }\n\n        const restored = PrivateKey.fromString(storedIdent);\n        return restored;\n      } catch (e) {\n        /**\n         * If any error, create a new identity.\n         */\n        try {\n          const identity = await PrivateKey.fromRandom();\n          const identityString = identity.toString();\n          localStorage.setItem(\"identity\", identityString);\n          return identity;\n        } catch (err) {\n          return err.message;\n        }\n      }\n    };\n\n    this.getBucketKey = async () => {\n      if (!this.state.identity) {\n        throw new Error('Identity not set');\n      }\n\n      const buckets = await Buckets.withKeyInfo(this.keyInfo); // Authorize the user and your insecure keys with getToken\n\n      await buckets.getToken(this.state.identity);\n      const buck = await buckets.getOrInit('io.textile.dropzone');\n\n      if (!buck.root) {\n        throw new Error('Failed to open bucket');\n      }\n\n      return {\n        buckets: buckets,\n        bucketKey: buck.root.key\n      };\n    };\n\n    this.getBucketLinks = async () => {\n      if (!this.state.buckets || !this.state.bucketKey) {\n        console.error('No bucket client or root key');\n        return;\n      }\n\n      const links = await this.state.buckets.links(this.state.bucketKey);\n      this.setState({ ...links\n      });\n    };\n\n    this.storeIndex = async index => {\n      if (!this.state.buckets || !this.state.bucketKey) {\n        console.error('No bucket client or root key');\n        return;\n      }\n\n      const buf = Buffer.from(JSON.stringify(index, null, 2));\n      const path = `index.json`;\n      await this.state.buckets.pushPath(this.state.bucketKey, path, buf);\n    };\n\n    this.initIndex = async () => {\n      if (!this.state.identity) {\n        console.error('Identity not set');\n        return;\n      }\n\n      const index = {\n        author: this.state.identity.public.toString(),\n        date: new Date().getTime(),\n        paths: []\n      };\n      await this.storeIndex(index);\n      return index;\n    };\n\n    this.initPublicGallery = async () => {\n      if (!this.state.buckets || !this.state.bucketKey) {\n        console.error('No bucket client or root key');\n        return;\n      }\n\n      const buf = Buffer.from(publicGallery);\n      await this.state.buckets.pushPath(this.state.bucketKey, 'index.html', buf);\n    };\n\n    this.galleryFromIndex = async index => {\n      if (!this.state.buckets || !this.state.bucketKey) {\n        console.error('No bucket client or root key');\n        return;\n      }\n\n      for (let path of index.paths) {\n        const metadata = await this.state.buckets.pullPath(this.state.bucketKey, path);\n        console.log(await this.state.buckets.links(this.state.bucketKey));\n        const {\n          value\n        } = await metadata.next();\n        let str = \"\";\n\n        for (var i = 0; i < value.length; i++) {\n          str += String.fromCharCode(parseInt(value[i]));\n        }\n\n        const json = JSON.parse(str);\n        const photo = index.paths.length > 1 ? json.preview : json.original;\n        this.setState({\n          photos: [...this.state.photos, {\n            src: `https://${photo.cid}.ipfs.hub.textile.io`,\n            width: photo.width,\n            height: photo.height,\n            key: photo.name\n          }]\n        });\n      }\n    };\n\n    this.getPhotoIndex = async () => {\n      if (!this.state.buckets || !this.state.bucketKey) {\n        console.error('No bucket client or root key');\n        return;\n      }\n\n      try {\n        const metadata = this.state.buckets.pullPath(this.state.bucketKey, 'index.json');\n        const {\n          value\n        } = await metadata.next();\n        let str = \"\";\n\n        for (var i = 0; i < value.length; i++) {\n          str += String.fromCharCode(parseInt(value[i]));\n        }\n\n        const index = JSON.parse(str);\n        return index;\n      } catch (error) {\n        const index = await this.initIndex();\n        await this.initPublicGallery();\n        return index;\n      }\n    };\n\n    this.insertFile = async (file, path) => {\n      if (!this.state.buckets || !this.state.bucketKey) {\n        throw new Error('No bucket client or root key');\n      }\n\n      const buckets = this.state.buckets;\n      return await buckets.pushPath(this.state.bucketKey, path, file.stream());\n    };\n\n    this.processAndStore = async (image, path, name, limits) => {\n      const finalImage = limits ? await readAndCompressImage(image, limits) : image;\n      const size = await browserImageSize(finalImage);\n      const location = `${path}${name}`;\n      const raw = await this.insertFile(finalImage, location);\n      const metadata = {\n        cid: raw.path.cid.toString(),\n        name: name,\n        path: location,\n        ...size\n      };\n      return metadata;\n    };\n\n    this.handleNewFile = async file => {\n      const preview = {\n        maxWidth: 800,\n        maxHeight: 800\n      };\n      const thumb = {\n        maxWidth: 200,\n        maxHeight: 200\n      };\n\n      if (!this.state.buckets || !this.state.bucketKey) {\n        console.error('No bucket client or root key');\n        return;\n      }\n\n      const imageSchema = {};\n      const now = new Date().getTime();\n      imageSchema['date'] = now;\n      imageSchema['name'] = `${file.name}`;\n      const filename = `${now}_${file.name}`;\n      imageSchema['original'] = await this.processAndStore(file, 'originals/', filename);\n      imageSchema['preview'] = await this.processAndStore(file, 'previews/', filename, preview);\n      imageSchema['thumb'] = await this.processAndStore(file, 'thumbs/', filename, thumb);\n      const metadata = Buffer.from(JSON.stringify(imageSchema, null, 2));\n      const metaname = `${now}_${file.name}.json`;\n      const path = `metadata/${metaname}`;\n      await this.state.buckets.pushPath(this.state.bucketKey, path, metadata);\n      const photo = this.state.photos.length > 1 ? imageSchema['preview'] : imageSchema['original'];\n      this.setState({\n        index: { ...this.state.index,\n          paths: [...this.state.index.paths, path]\n        },\n        photos: [...this.state.photos, {\n          src: `https://${photo.cid}.ipfs.hub.textile.io`,\n          width: photo.width,\n          height: photo.height,\n          key: photo.name\n        }]\n      });\n    };\n\n    this.onDrop = async acceptedFiles => {\n      if (this.state.photos.length > 50) {\n        throw new Error('Gallery at maximum size');\n      }\n\n      if (acceptedFiles.length > 5) {\n        throw new Error('Max 5 images at a time');\n      }\n\n      for (const accepted of acceptedFiles) {\n        await this.handleNewFile(accepted);\n      }\n\n      this.storeIndex(this.state.index);\n    };\n\n    this.renderDropzone = () => {\n      return /*#__PURE__*/React.createElement(Dropzone, {\n        onDrop: this.onDrop,\n        accept: 'image/jpeg, image/png, image/gif',\n        maxSize: 20000000,\n        multiple: true,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 327,\n          columnNumber: 7\n        }\n      }, ({\n        getRootProps,\n        getInputProps\n      }) => /*#__PURE__*/React.createElement(\"div\", Object.assign({\n        className: \"dropzone\"\n      }, getRootProps(), {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 334,\n          columnNumber: 11\n        }\n      }), /*#__PURE__*/React.createElement(\"input\", Object.assign({}, getInputProps(), {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 335,\n          columnNumber: 13\n        }\n      })), /*#__PURE__*/React.createElement(Button, {\n        className: \"icon\",\n        icon: \"images\",\n        title: \"add\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 336,\n          columnNumber: 13\n        }\n      }), /*#__PURE__*/React.createElement(\"span\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 341,\n          columnNumber: 13\n        }\n      }, \"DRAG & DROP\")));\n    };\n  }\n\n  async componentDidMount() {\n    // Clear your user during development\n    // await localStorage.clear()\n    const identity = await this.getIdentity(); // you might want to do the I18N setup here\n\n    this.setState({\n      identity: identity\n    }); // get their photo bucket\n\n    const {\n      bucketKey,\n      buckets\n    } = await this.getBucketKey();\n    this.setState({\n      buckets: buckets,\n      bucketKey: bucketKey\n    });\n    await this.getBucketLinks();\n    const index = await this.getPhotoIndex();\n\n    if (index) {\n      await this.galleryFromIndex(index);\n      this.setState({\n        index,\n        isLoading: false\n      });\n    }\n  }\n  /**\n   * getIdentity uses a basic private key identity.\n   * The user's identity will be cached client side. This is long\n   * but ephemeral storage not sufficient for production apps.\n   * \n   * Read more here:\n   * https://docs.textile.io/tutorials/hub/libp2p-identities/\n   */\n\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"App\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 349,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(Segment.Group, {\n      style: {\n        height: \"100%\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 350,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Segment, {\n      clearing: true,\n      className: \"nav\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 351,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(Header, {\n      className: \"avatar\",\n      as: \"h2\",\n      floated: \"left\",\n      title: this.state.identity ? this.state.identity.toString() : 'identity',\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 352,\n        columnNumber: 13\n      }\n    }, this.state.identity && /*#__PURE__*/React.createElement(Avatar, {\n      identity: this.state.identity.toString(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 353,\n        columnNumber: 39\n      }\n    })), /*#__PURE__*/React.createElement(Header, {\n      className: \"dropzone-container\",\n      as: \"h2\",\n      floated: \"right\",\n      title: 'add photo',\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 355,\n        columnNumber: 13\n      }\n    }, !this.state.isLoading && this.renderDropzone()), this.state.url && /*#__PURE__*/React.createElement(\"a\", {\n      href: this.state.url,\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 359,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(Button, {\n      className: \"link\",\n      floated: \"right\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 360,\n        columnNumber: 17\n      }\n    }, \"BUCKET\")), this.state.www && /*#__PURE__*/React.createElement(\"a\", {\n      href: this.state.www,\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 367,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(Button, {\n      className: \"link\",\n      floated: \"right\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 368,\n        columnNumber: 17\n      }\n    }, \"WWW\")), this.state.ipns && /*#__PURE__*/React.createElement(\"a\", {\n      href: this.state.ipns,\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 375,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(Button, {\n      className: \"link\",\n      floated: \"right\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 376,\n        columnNumber: 17\n      }\n    }, \"IPNS\"))), /*#__PURE__*/React.createElement(Segment, {\n      className: this.state.isLoading ? 'rendering' : 'complete',\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 383,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(Photos, {\n      photos: this.state.photos,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 384,\n        columnNumber: 13\n      }\n    }))));\n  }\n\n}\n\nconst publicGallery = '<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content=\"width=device-width,initial-scale=1\"><meta http-equiv=x-ua-compatible content=\"ie=edge\"><meta property=\"twitter:description\" content=\"built with textile.io. uses textile buckets and ipns to serve photo galleries over ipns\"><title>Public Gallery</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/glightbox/dist/css/glightbox.min.css><script src=https://cdn.jsdelivr.net/gh/mcstudios/glightbox/dist/js/glightbox.min.js></script><div class=wrapper><div class=grid></div></div><script>const loadIndex=async()=>{const elements=[]\\n' + 'const index=await fetch(\"index.json\")\\n' + 'const json=await index.json()\\n' + 'for(let path of json.paths){try{const meta=await fetchMetadata(path)\\n' + 'elements.push({href:meta.path,type:\"image\"})}catch(err){console.log(err)}}\\n' + 'const lightbox=GLightbox({selector:\".grid\",touchNavigation:true,closeButton:false,loop:true,elements:elements,});lightbox.open();}\\n' + 'const fetchMetadata=async(path)=>{const index=await fetch(path)\\n' + 'const json=await index.json()\\n' + 'return json.original}\\n' + 'window.addEventListener(\"DOMContentLoaded\",function(){loadIndex()});</script>';\nexport default App;","map":{"version":3,"sources":["/Users/nassarhayat/apps/textiletable/js-examples/bucket-photo-gallery/src/App.tsx"],"names":["React","Avatar","Photos","Dropzone","browserImageSize","readAndCompressImage","Buckets","PrivateKey","Button","Header","Segment","App","Component","keyInfo","key","state","metadata","photos","isLoading","isDragActive","index","author","date","paths","getIdentity","storedIdent","localStorage","getItem","Error","restored","fromString","e","identity","fromRandom","identityString","toString","setItem","err","message","getBucketKey","buckets","withKeyInfo","getToken","buck","getOrInit","root","bucketKey","getBucketLinks","console","error","links","setState","storeIndex","buf","Buffer","from","JSON","stringify","path","pushPath","initIndex","public","Date","getTime","initPublicGallery","publicGallery","galleryFromIndex","pullPath","log","value","next","str","i","length","String","fromCharCode","parseInt","json","parse","photo","preview","original","src","cid","width","height","name","getPhotoIndex","insertFile","file","stream","processAndStore","image","limits","finalImage","size","location","raw","handleNewFile","maxWidth","maxHeight","thumb","imageSchema","now","filename","metaname","onDrop","acceptedFiles","accepted","renderDropzone","getRootProps","getInputProps","componentDidMount","render","url","www","ipns"],"mappings":"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","sourcesContent":["import React from 'react';\nimport Avatar from './Avatar';\nimport Photos from './Photos';\n\nimport \"semantic-ui-css/semantic.min.css\";\nimport Dropzone from 'react-dropzone'\n// @ts-ignore\nimport browserImageSize from 'browser-image-size'\n// @ts-ignore\nimport { readAndCompressImage } from 'browser-image-resizer'\nimport { Buckets, PushPathResult, KeyInfo, PrivateKey } from '@textile/hub'\nimport { Button, Header, Segment } from \"semantic-ui-react\";\n\nimport {PhotoSample, Photo, GalleryIndex, AppState} from './Types'\nimport './App.css';\n\nclass App extends React.Component {\n  keyInfo: KeyInfo = {\n    key: 'AKLSlskdjfsoi23lkjf23o9f',\n  }\n  state: AppState = {\n    metadata: [],\n    photos: [],\n    isLoading: true,\n    isDragActive: false,\n    index: {\n      author: '',\n      date: 0,\n      paths: []\n    }\n  }\n  async componentDidMount() {\n    // Clear your user during development\n    // await localStorage.clear()\n    const identity = await this.getIdentity()\n    // you might want to do the I18N setup here\n    this.setState({ \n      identity: identity\n    })\n\n    // get their photo bucket\n    const {bucketKey, buckets} = await this.getBucketKey()\n    this.setState({ \n      buckets: buckets,\n      bucketKey: bucketKey\n    })\n\n    await this.getBucketLinks()\n\n    const index = await this.getPhotoIndex()\n    if (index) {\n      await this.galleryFromIndex(index)\n      this.setState({ \n        index,\n        isLoading: false\n      })\n    }\n  }\n\n  /**\n   * getIdentity uses a basic private key identity.\n   * The user's identity will be cached client side. This is long\n   * but ephemeral storage not sufficient for production apps.\n   * \n   * Read more here:\n   * https://docs.textile.io/tutorials/hub/libp2p-identities/\n   */\n  getIdentity = async (): Promise<PrivateKey> => {\n    try {\n      var storedIdent = localStorage.getItem(\"identity\")\n      if (storedIdent === null) {\n        throw new Error('No identity')\n      }\n      const restored = PrivateKey.fromString(storedIdent)\n      return restored\n    }\n    catch (e) {\n      /**\n       * If any error, create a new identity.\n       */\n      try {\n        const identity = await PrivateKey.fromRandom()\n        const identityString = identity.toString()\n        localStorage.setItem(\"identity\", identityString)\n        return identity\n      } catch (err) {\n        return err.message\n      }\n    }\n  }\n\n  /**\n   * getBucketKey will create a new Buckets client with the UserAuth\n   * and then open our custom bucket named, 'io.textile.dropzone'\n   */\n  getBucketKey = async () => {\n    if (!this.state.identity) {\n      throw new Error('Identity not set')\n    }\n    const buckets = await Buckets.withKeyInfo(this.keyInfo)\n    // Authorize the user and your insecure keys with getToken\n    await buckets.getToken(this.state.identity)\n\n    const buck = await buckets.getOrInit('io.textile.dropzone')\n    if (!buck.root) {\n      throw new Error('Failed to open bucket')\n    }\n    return {buckets: buckets, bucketKey: buck.root.key};\n  }\n\n  /**\n   * getBucketLinks returns all the protocol endpoints for the bucket.\n   * Read more:\n   * https://docs.textile.io/hub/buckets/#bucket-protocols \n   */\n  getBucketLinks = async () => {\n    if (!this.state.buckets || !this.state.bucketKey) {\n      console.error('No bucket client or root key')\n      return\n    }\n    const links = await this.state.buckets.links(this.state.bucketKey)\n    this.setState({\n      ...links\n    })\n  }\n\n  /**\n   * storeIndex stores the updated index of all images in the Bucket\n   * This could easily be designed to write directly to the thread\n   * instead of json files. \n   * @param index \n   */\n  storeIndex = async (index: GalleryIndex) => {\n    if (!this.state.buckets || !this.state.bucketKey) {\n      console.error('No bucket client or root key')\n      return\n    }\n    const buf = Buffer.from(JSON.stringify(index, null, 2))\n    const path = `index.json`\n    await this.state.buckets.pushPath(this.state.bucketKey, path, buf)\n  }\n\n  initIndex = async () => {\n    if (!this.state.identity) {\n      console.error('Identity not set')\n      return\n    }\n    const index = {\n      author: this.state.identity.public.toString(),\n      date: (new Date()).getTime(),\n      paths: []\n    }\n    await this.storeIndex(index)\n    return index\n  }\n\n  /**\n   * initPublicGallery will write a basic HTML file to the root of the bucket\n   * that knows how to read the index.json and load all the images. This will\n   * allow the bucket to be rendered over any gateway or ipns endpoint.\n   */\n  initPublicGallery = async () => {\n    if (!this.state.buckets || !this.state.bucketKey) {\n      console.error('No bucket client or root key')\n      return\n    }\n    const buf = Buffer.from(publicGallery)\n    await this.state.buckets.pushPath(this.state.bucketKey, 'index.html', buf)\n  }\n\n  /**\n   * galleryFromIndex parses the index.json and pulls the metadata for each image\n   * @param index \n   */\n  galleryFromIndex = async (index: GalleryIndex) => {\n    if (!this.state.buckets || !this.state.bucketKey) {\n      console.error('No bucket client or root key')\n      return\n    }\n    for (let path of index.paths) {\n      const metadata = await this.state.buckets.pullPath(this.state.bucketKey, path)\n      console.log(await this.state.buckets.links(this.state.bucketKey))\n      const { value } = await metadata.next();\n      let str = \"\";\n      for (var i = 0; i < value.length; i++) {\n        str += String.fromCharCode(parseInt(value[i]));\n      }\n      const json: Photo = JSON.parse(str)\n      const photo = index.paths.length > 1 ? json.preview : json.original\n      this.setState({ \n        photos: [\n          ...this.state.photos,\n          {\n            src:`https://${photo.cid}.ipfs.hub.textile.io`,\n            width: photo.width,\n            height: photo.height,\n            key: photo.name,\n          }\n        ]\n      })\n    }\n  }\n\n  /**\n   * getPhotoIndex pulls the index.json from the root of the bucket (or creates it\n   * if it doesn't exist yet)\n   */\n  getPhotoIndex = async () => {\n    if (!this.state.buckets || !this.state.bucketKey) {\n      console.error('No bucket client or root key')\n      return\n    }\n    try {\n      const metadata = this.state.buckets.pullPath(this.state.bucketKey, 'index.json')\n      const { value } = await metadata.next();\n      let str = \"\";\n      for (var i = 0; i < value.length; i++) {\n        str += String.fromCharCode(parseInt(value[i]));\n      }\n      const index: GalleryIndex = JSON.parse(str)\n      return index\n    } catch (error) {\n      const index = await this.initIndex()\n      await this.initPublicGallery()\n      return index\n    }\n  }\n\n  /**\n   * Pushes files to the bucket\n   * @param file \n   * @param path \n   */\n  insertFile = async (file: File, path: string): Promise<PushPathResult> => {\n    if (!this.state.buckets || !this.state.bucketKey) {\n      throw new Error('No bucket client or root key')\n    }\n    const buckets: Buckets = this.state.buckets\n    return await buckets.pushPath(this.state.bucketKey, path, file.stream())\n  }\n\n  /**\n   * processAndStore resamples the image and extracts the metadata. Next, it\n   * calls insertFile to store each of the samples plus the metadata in the bucket.\n   * @param image \n   * @param path \n   * @param name \n   * @param limits \n   */\n  processAndStore = async (image: File, path: string, name: string, limits?: {maxWidth: number, maxHeight: number}): Promise<PhotoSample> => {\n    const finalImage = limits ? await readAndCompressImage(image, limits) : image\n    const size = await browserImageSize(finalImage)\n    const location = `${path}${name}`\n    const raw = await this.insertFile(finalImage, location)\n    const metadata = {\n      cid: raw.path.cid.toString(),\n      name: name,\n      path: location,\n      ...size\n    }\n    return metadata\n  }\n\n  handleNewFile = async (file: File) => {\n    const preview = {\n      maxWidth: 800,\n      maxHeight: 800\n    }\n    const thumb = {\n      maxWidth: 200,\n      maxHeight: 200\n    }\n    if (!this.state.buckets || !this.state.bucketKey) {\n      console.error('No bucket client or root key')\n      return\n    }\n    const imageSchema: {[key: string]: any} = {}\n    const now = new Date().getTime()\n    imageSchema['date'] = now\n    imageSchema['name'] = `${file.name}`\n    const filename = `${now}_${file.name}`\n    \n    imageSchema['original'] = await this.processAndStore(file, 'originals/', filename)\n    \n    imageSchema['preview'] = await this.processAndStore(file, 'previews/', filename, preview)\n\n    imageSchema['thumb'] = await this.processAndStore(file, 'thumbs/', filename, thumb)\n\n    const metadata = Buffer.from(JSON.stringify(imageSchema, null, 2))\n    const metaname = `${now}_${file.name}.json`\n    const path = `metadata/${metaname}`\n    await this.state.buckets.pushPath(this.state.bucketKey, path, metadata)\n\n    const photo = this.state.photos.length > 1 ? imageSchema['preview'] : imageSchema['original']\n\n    this.setState({ \n      index: {\n        ...this.state.index,\n        paths: [...this.state.index.paths, path]\n      },\n      photos: [\n        ...this.state.photos,\n        {\n          src:`https://${photo.cid}.ipfs.hub.textile.io`,\n          width: photo.width,\n          height: photo.height,\n          key: photo.name,\n        }\n      ]\n    })\n  }\n  onDrop = async (acceptedFiles: File[]) => {\n    if (this.state.photos.length > 50) {\n      throw new Error('Gallery at maximum size')\n    }\n    if (acceptedFiles.length > 5) {\n      throw new Error('Max 5 images at a time')\n    }\n    for (const accepted of acceptedFiles) {\n      await this.handleNewFile(accepted)\n    }\n    this.storeIndex(this.state.index)\n  }\n\n  renderDropzone = () => {\n    return (\n      <Dropzone \n        onDrop={this.onDrop}\n        accept={'image/jpeg, image/png, image/gif'}\n        maxSize={20000000}\n        multiple={true}\n        >\n        {({getRootProps, getInputProps}) => (\n          <div className=\"dropzone\" {...getRootProps()}>\n            <input {...getInputProps()} />\n            <Button\n              className=\"icon\"\n              icon=\"images\"\n              title=\"add\"\n            />\n            <span>DRAG & DROP</span>\n          </div>\n        )}\n      </Dropzone>\n    )\n  }\n  render () {\n    return (\n      <div className=\"App\">\n        <Segment.Group style={{ height: \"100%\" }}>\n          <Segment clearing className=\"nav\">\n            <Header className=\"avatar\" as=\"h2\" floated=\"left\" title={this.state.identity ? this.state.identity.toString() : 'identity'}>\n              {this.state.identity && <Avatar identity={this.state.identity.toString()}/>}\n            </Header>\n            <Header className=\"dropzone-container\" as=\"h2\" floated=\"right\" title={'add photo'}>\n              {!this.state.isLoading && this.renderDropzone()}\n            </Header>\n            {this.state.url &&\n              <a href={this.state.url} target=\"_blank\" rel=\"noopener noreferrer\">\n                <Button\n                  className=\"link\"\n                  floated=\"right\"\n                >BUCKET</Button>\n              </a>\n            }\n            {this.state.www &&\n              <a href={this.state.www} target=\"_blank\" rel=\"noopener noreferrer\">\n                <Button\n                  className=\"link\"\n                  floated=\"right\"\n                >WWW</Button>\n              </a>\n            }\n            {this.state.ipns &&\n              <a href={this.state.ipns} target=\"_blank\" rel=\"noopener noreferrer\">\n                <Button\n                  className=\"link\"\n                  floated=\"right\"\n                >IPNS</Button>\n              </a>\n            }\n          </Segment>\n          <Segment className={ this.state.isLoading ? 'rendering' : 'complete'}>\n            <Photos photos={this.state.photos}/>\n          </Segment>\n        </Segment.Group>\n      </div>\n    )\n  }\n}\n\nconst publicGallery = '<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content=\"width=device-width,initial-scale=1\"><meta http-equiv=x-ua-compatible content=\"ie=edge\"><meta property=\"twitter:description\" content=\"built with textile.io. uses textile buckets and ipns to serve photo galleries over ipns\"><title>Public Gallery</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/glightbox/dist/css/glightbox.min.css><script src=https://cdn.jsdelivr.net/gh/mcstudios/glightbox/dist/js/glightbox.min.js></script><div class=wrapper><div class=grid></div></div><script>const loadIndex=async()=>{const elements=[]\\n' +\n'const index=await fetch(\"index.json\")\\n' +\n'const json=await index.json()\\n' +\n'for(let path of json.paths){try{const meta=await fetchMetadata(path)\\n' +\n'elements.push({href:meta.path,type:\"image\"})}catch(err){console.log(err)}}\\n' +\n'const lightbox=GLightbox({selector:\".grid\",touchNavigation:true,closeButton:false,loop:true,elements:elements,});lightbox.open();}\\n' +\n'const fetchMetadata=async(path)=>{const index=await fetch(path)\\n' +\n'const json=await index.json()\\n' +\n'return json.original}\\n' +\n'window.addEventListener(\"DOMContentLoaded\",function(){loadIndex()});</script>';\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}