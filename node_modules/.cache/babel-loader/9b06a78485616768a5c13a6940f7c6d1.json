{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.expirationError = exports.createUserAuth = exports.createAPISig = void 0;\n/**\n * Common types/methods for Textile security including authentication and authorization.\n *\n * All methods here should be imported directly from the @textile/hub library.\n *\n * @packageDocumentation\n */\n\nconst fast_sha256_1 = require(\"fast-sha256\");\n\nconst multibase_1 = __importDefault(require(\"multibase\"));\n/**\n * createAPISig generates an authorization signature and message only.\n *\n * This function should NOT be used client-side, as it requires a key secret.\n * @public\n * @example\n * Basic usage\n * ```typescript\n * import {createAPISig, APISig} from '@textile/threads'\n *\n * async function sign (key: string) {\n *   const sig: APISig = await createAPISig(key)\n *   return sig\n * }\n * ```\n * @param {string} secret - The key secret to generate the signature. See KeyInfo for details.\n * @param {Date} date - An optional future Date to use as signature message. Once `date` has passed, this\n * authorization signature and message will expire. Defaults to one minute from `Date.now`.\n */\n\n\nfunction createAPISig(secret, date = new Date(Date.now() + 1000 * 60 * 30) // Default to 30 minutes\n) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const sec = multibase_1.default.decode(secret);\n    const msg = date.toISOString();\n    const hash = new fast_sha256_1.HMAC(sec);\n    const mac = hash.update(Buffer.from(msg)).digest();\n    const sig = multibase_1.default.encode(\"base32\", Buffer.from(mac)).toString();\n    return {\n      sig,\n      msg\n    };\n  });\n}\n\nexports.createAPISig = createAPISig;\n/**\n * Generate a UserAuth containing API key, signature, and message.\n *\n * The gRPC APIs will throw (or return an authorization error) if the message date has passed.\n * This function should NOT be used client-side, as it requires a key secret. The result does\n * not contain the secret and therefor CAN be used client side.\n * @public\n * @example\n * Create a new UserAuth\n * ```typescript\n * import {createUserAuth, KeyInfo, UserAuth} from '@textile/threads';\n *\n * async function auth (keyInfo: KeyInfo) {\n *   // Create an expiration and create a signature. 60s or less is recommended.\n *   const expiration = new Date(Date.now() + 60 * 1000)\n *   // Generate a new UserAuth\n *   const userAuth: UserAuth = await createUserAuth(keyInfo.key, keyInfo.secret ?? '', expiration)\n *   return userAuth\n * }\n * ```\n *\n * @param {string} key - The API key secret to generate the signature. See KeyInfo for details.\n * @param {string} secret - The API key secret to generate the signature. See KeyInfo for details.\n * @param {Date} date - An optional future Date to use as signature message. Default 1 minute from now.\n * @param {string} token - An optional user API token.\n */\n\nfunction createUserAuth(key, secret, date, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const partial = yield createAPISig(secret, date);\n    return Object.assign(Object.assign({}, partial), {\n      key,\n      token\n    });\n  });\n}\n\nexports.createUserAuth = createUserAuth;\n/**\n * expirationError is an error your app will receive anytime your credentials have expired.\n * @public\n */\n\nexports.expirationError = new Error(\"Auth expired. Consider calling withKeyInfo or withAPISig to refresh.\");","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AAOA,MAAA,aAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;AA8DA;;;;;;;;;;;;;;;;;;;;;AAmBA,SAAsB,YAAtB,CACE,MADF,EAEE,IAAA,GAAa,IAAI,IAAJ,CAAS,IAAI,CAAC,GAAL,KAAa,OAAO,EAAP,GAAY,EAAlC,CAFf,CAEqD;AAFrD,E;;AAIE,UAAM,GAAG,GAAG,WAAA,CAAA,OAAA,CAAU,MAAV,CAAiB,MAAjB,CAAZ;AACA,UAAM,GAAG,GAAG,IAAI,CAAC,WAAL,EAAZ;AACA,UAAM,IAAI,GAAG,IAAI,aAAA,CAAA,IAAJ,CAAS,GAAT,CAAb;AACA,UAAM,GAAG,GAAG,IAAI,CAAC,MAAL,CAAY,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAZ,EAA8B,MAA9B,EAAZ;AACA,UAAM,GAAG,GAAG,WAAA,CAAA,OAAA,CAAU,MAAV,CAAiB,QAAjB,EAA2B,MAAM,CAAC,IAAP,CAAY,GAAZ,CAA3B,EAA6C,QAA7C,EAAZ;AACA,WAAO;AAAE,MAAA,GAAF;AAAO,MAAA;AAAP,KAAP;AACD,G;AAAA;;AAVD,OAAA,CAAA,YAAA,GAAA,YAAA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,SAAsB,cAAtB,CACE,GADF,EAEE,MAFF,EAGE,IAHF,EAIE,KAJF,EAIgB;;AAEd,UAAM,OAAO,GAAG,MAAM,YAAY,CAAC,MAAD,EAAS,IAAT,CAAlC;AACA,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,OADL,CAAA,EACY;AACV,MAAA,GADU;AAEV,MAAA;AAFU,KADZ,CAAA;AAKD,G;AAAA;;AAZD,OAAA,CAAA,cAAA,GAAA,cAAA;AAcA;;;;;AAIa,OAAA,CAAA,eAAA,GAAkB,IAAI,KAAJ,CAC7B,sEAD6B,CAAlB","sourcesContent":["/**\n * Common types/methods for Textile security including authentication and authorization.\n *\n * All methods here should be imported directly from the @textile/hub library.\n *\n * @packageDocumentation\n */\nimport { HMAC } from \"fast-sha256\"\nimport multibase from \"multibase\"\n\n/**\n * UserAuth is a type describing the minimal requirements create a session from a user group key. Generate with {@link createUserAuth}.\n *\n * Optional token generated by {@link https://textileio.github.io/js-threads/classes/_textile_threads_client.client.html#gettoken | Client.getToken} or {@link https://textileio.github.io/js-threads/classes/_textile_threads_client.client.html#gettoken | Client.getTokenChallenge}.\n * @public\n * @example\n * Import\n * ```typescript\n * import {UserAuth} from '@textile/threads';\n * ```\n * @param {string} key - API key. Can be embedded/shared within an app.\n * @param {string} sig - The signature of the authentication message.\n * @param {string} msg - The authentication message.\n * @param {string} token - User verification token generated by {@link https://textileio.github.io/js-threads/classes/_textile_threads_client.client.html#gettoken | Client.getToken} or {@link https://textileio.github.io/js-threads/classes/_textile_threads_client.client.html#gettoken | Client.getTokenChallenge}.\n */\nexport type UserAuth = {\n  key: string\n  sig: string\n  msg: string\n  token?: string\n}\n\n/**\n * KeyInfo is a type that contains the API Secret. It should never be shared in insecure environments.\n * @public\n * @example\n * Import\n * ```typescript\n * import {KeyInfo} from '@textile/threads';\n * ```\n * @param {string} key - API key. Can be embedded/shared within an app.\n * @param {string} secret - User group/account secret. Should not be embedded/shared publicly.\n */\nexport type KeyInfo = {\n  /**\n   * API key. Can be embedded/shared within an app.\n   */\n  key: string\n  /**\n   * User group/account secret. Should not be embedded/shared publicly.\n   */\n  secret?: string\n}\n\n/**\n * Create an API signature for use in authenticated systems. Generate with {@link createAPISig}.\n * @public\n * @example\n * Import\n * ```typescript\n * import {APISig} from '@textile/threads';\n * ```\n * @param {string} sig - The signature of the authentication message.\n * @param {string} msg - The authentication message.\n */\nexport type APISig = {\n  sig: string\n  msg: string\n}\n\n/**\n * createAPISig generates an authorization signature and message only.\n *\n * This function should NOT be used client-side, as it requires a key secret.\n * @public\n * @example\n * Basic usage\n * ```typescript\n * import {createAPISig, APISig} from '@textile/threads'\n *\n * async function sign (key: string) {\n *   const sig: APISig = await createAPISig(key)\n *   return sig\n * }\n * ```\n * @param {string} secret - The key secret to generate the signature. See KeyInfo for details.\n * @param {Date} date - An optional future Date to use as signature message. Once `date` has passed, this\n * authorization signature and message will expire. Defaults to one minute from `Date.now`.\n */\nexport async function createAPISig(\n  secret: string,\n  date: Date = new Date(Date.now() + 1000 * 60 * 30) // Default to 30 minutes\n): Promise<APISig> {\n  const sec = multibase.decode(secret)\n  const msg = date.toISOString()\n  const hash = new HMAC(sec)\n  const mac = hash.update(Buffer.from(msg)).digest()\n  const sig = multibase.encode(\"base32\", Buffer.from(mac)).toString()\n  return { sig, msg }\n}\n\n/**\n * Generate a UserAuth containing API key, signature, and message.\n *\n * The gRPC APIs will throw (or return an authorization error) if the message date has passed.\n * This function should NOT be used client-side, as it requires a key secret. The result does\n * not contain the secret and therefor CAN be used client side.\n * @public\n * @example\n * Create a new UserAuth\n * ```typescript\n * import {createUserAuth, KeyInfo, UserAuth} from '@textile/threads';\n *\n * async function auth (keyInfo: KeyInfo) {\n *   // Create an expiration and create a signature. 60s or less is recommended.\n *   const expiration = new Date(Date.now() + 60 * 1000)\n *   // Generate a new UserAuth\n *   const userAuth: UserAuth = await createUserAuth(keyInfo.key, keyInfo.secret ?? '', expiration)\n *   return userAuth\n * }\n * ```\n *\n * @param {string} key - The API key secret to generate the signature. See KeyInfo for details.\n * @param {string} secret - The API key secret to generate the signature. See KeyInfo for details.\n * @param {Date} date - An optional future Date to use as signature message. Default 1 minute from now.\n * @param {string} token - An optional user API token.\n */\nexport async function createUserAuth(\n  key: string,\n  secret: string,\n  date?: Date,\n  token?: string\n): Promise<UserAuth> {\n  const partial = await createAPISig(secret, date)\n  return {\n    ...partial,\n    key,\n    token,\n  }\n}\n\n/**\n * expirationError is an error your app will receive anytime your credentials have expired.\n * @public\n */\nexport const expirationError = new Error(\n  \"Auth expired. Consider calling withKeyInfo or withAPISig to refresh.\"\n)\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}