{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Multiaddr = void 0;\n\nconst bs58_1 = __importDefault(require(\"bs58\"));\n\nconst cids_1 = __importDefault(require(\"cids\"));\n\nconst varint_1 = __importDefault(require(\"varint\"));\n\nconst codec = __importStar(require(\"./codec\"));\n\nconst protocols_1 = require(\"./protocols\");\n/**\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\n * a Buffer, String or another Multiaddr instance\n * public key.\n * @class Multiaddr\n * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\n\n\nclass Multiaddr {\n  constructor(addr) {\n    this.buffer = Buffer.alloc(0);\n    /**\n     * Returns Multiaddr as a JSON encoded object\n     *\n     * @example\n     * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // '/ip4/127.0.0.1/tcp/4001'\n     */\n\n    this.toJSON = this.toString;\n\n    if (!(this instanceof Multiaddr)) {\n      return new Multiaddr(addr);\n    } // default\n\n\n    if (addr == null) {\n      addr = \"\";\n    }\n\n    if (addr instanceof Buffer) {\n      /**\n       * @type {Buffer} - The raw bytes representing this multiaddress\n       */\n      this.buffer = codec.fromBuffer(addr);\n    } else if (typeof addr === \"string\" || addr instanceof String) {\n      if (addr.length > 0 && addr.charAt(0) !== \"/\") {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n      }\n\n      this.buffer = codec.fromString(addr);\n    } else if (addr.buffer && addr.protos && addr.protoCodes) {\n      // Multiaddr\n      this.buffer = codec.fromBuffer(addr.buffer); // validate + copy buffer\n    } else {\n      throw new Error(\"addr must be a string, Buffer, or another Multiaddr\");\n    }\n  }\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   */\n\n\n  toString() {\n    return codec.bufferToString(this.buffer);\n  }\n  /**\n   * Returns Multiaddr as a convenient options object to be used with network.createConnection\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   */\n\n\n  toOptions() {\n    const opts = {};\n    const parsed = this.toString().split(\"/\");\n    opts.family = parsed[1] === \"ip4\" ? \"ipv4\" : \"ipv6\";\n    opts.host = parsed[2];\n    opts.transport = parsed[3];\n    opts.port = parseInt(parsed[4]);\n    return opts;\n  }\n  /**\n   * Returns Multiaddr as a human-readable string\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\n   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n   */\n\n\n  inspect() {\n    return \"<Multiaddr \" + this.buffer.toString(\"hex\") + \" - \" + codec.bufferToString(this.buffer) + \">\";\n  }\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   */\n\n\n  protos() {\n    return this.protoCodes().map(code => Object.assign({}, protocols_1.protocols(code)));\n  }\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   */\n\n\n  protoCodes() {\n    const codes = [];\n    const buf = this.buffer;\n    let i = 0;\n\n    while (i < buf.length) {\n      const code = varint_1.default.decode(buf, i);\n      const n = varint_1.default.decode.bytes;\n      const p = protocols_1.protocols(code);\n      const size = codec.sizeForAddr(p, buf.slice(i + n));\n      i += size + n;\n      codes.push(code);\n    }\n\n    return codes;\n  }\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   */\n\n\n  protoNames() {\n    return this.protos().map(proto => proto.name);\n  }\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   */\n\n\n  tuples() {\n    return codec.bufferToTuples(this.buffer);\n  }\n  /**\n   * Returns a tuple of string/number parts\n   *\n   * @example\n   * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\n   */\n\n\n  stringTuples() {\n    const t = codec.bufferToTuples(this.buffer);\n    return codec.tuplesToStringTuples(t);\n  }\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   */\n\n\n  encapsulate(addr) {\n    addr = new Multiaddr(addr);\n    return new Multiaddr(this.toString() + addr.toString());\n  }\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   */\n\n\n  decapsulate(addr) {\n    const str = addr.toString();\n    const s = this.toString();\n    const i = s.lastIndexOf(str);\n\n    if (i < 0) {\n      throw new Error(\"Address \" + this + \" does not contain subaddress: \" + addr);\n    }\n\n    return new Multiaddr(s.slice(0, i));\n  }\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * const addr = Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   */\n\n\n  decapsulateCode(code) {\n    const tuples = this.tuples();\n\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(codec.tuplesToBuffer(tuples.slice(0, i)));\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   */\n\n\n  getPeerId() {\n    let b58str;\n\n    try {\n      const tuples = this.stringTuples().filter(tuple => {\n        if (tuple[0] === protocols_1.protocols.names.ipfs.code) {\n          return true;\n        }\n      }); // Get the last id\n\n      b58str = (tuples.pop() || [])[1]; // Get multihash, unwrap from CID if needed\n\n      b58str = bs58_1.default.encode(new cids_1.default(b58str || \"\").multihash);\n    } catch (e) {\n      b58str = undefined;\n    }\n\n    return b58str;\n  }\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   */\n\n\n  getPath() {\n    let path = null;\n\n    try {\n      path = this.stringTuples().filter(tuple => {\n        const proto = protocols_1.protocols(tuple[0]);\n\n        if (proto.path) {\n          return true;\n        }\n      })[0][1];\n    } catch (e) {\n      path = null;\n    }\n\n    return path;\n  }\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   */\n\n\n  equals(addr) {\n    return this.buffer.equals(addr.buffer);\n  }\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\n   */\n\n\n  nodeAddress() {\n    const codes = this.protoCodes();\n    const names = this.protoNames();\n    const parts = this.toString().split(\"/\").slice(1);\n\n    if (parts.length < 4) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".');\n    } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\n      throw new Error(`no protocol with name: \"'${names[0]}'\". Must have a valid family name: \"{ip4, ip6, dns4, dns6}\".`);\n    } else if (parts[2] !== \"tcp\" && parts[2] !== \"udp\") {\n      throw new Error(`no protocol with name: \"'${names[1]}'\". Must have a valid transport protocol: \"{tcp, udp}\".`);\n    }\n\n    return {\n      family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,\n      address: parts[1],\n      port: parseInt(parts[3])\n    };\n  }\n  /**\n   * Creates a Multiaddr from a node-friendly address object\n   *\n   * @example\n   * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   */\n\n\n  static fromNodeAddress(addr, transport) {\n    if (!addr) throw new Error(\"requires node address object\");\n    if (!transport) throw new Error(\"requires transport protocol\");\n    const ip = addr.family === \"IPv6\" ? \"ip6\" : \"ip4\";\n    return new Multiaddr(\"/\" + [ip, addr.address, transport, addr.port].join(\"/\"));\n  }\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   */\n\n\n  static isThinWaistAddress(addr) {\n    const protos = (addr || this).protos();\n\n    if (protos.length !== 2) {\n      return false;\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false;\n    }\n\n    return !(protos[1].code !== 6 && protos[1].code !== 273);\n  }\n  /**\n   * Returns if something is a Multiaddr that is a name\n   */\n\n\n  static isName(addr) {\n    if (!Multiaddr.isMultiaddr(addr)) {\n      return false;\n    } // if a part of the multiaddr is resolvable, then return true\n\n\n    return addr.protos().some(proto => proto.resolvable);\n  }\n  /**\n   * Returns an array of multiaddrs, by resolving the multiaddr that is a name\n   */\n\n\n  static resolve(addr) {\n    if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n      return Promise.reject(Error(\"not a valid name\"));\n    }\n    /*\n     * Needs more consideration from spec design:\n     *   - what to return\n     *   - how to achieve it in the browser?\n     */\n\n\n    return Promise.reject(new Error(\"not implemented yet\"));\n  }\n\n  static isMultiaddr(other) {\n    return other;\n  }\n\n}\n\nexports.Multiaddr = Multiaddr;\n/**\n * Object containing table, names and codes of all supported protocols.\n * To get the protocol values from a Multiaddr, you can use\n * [`.protos()`](#multiaddrprotos),\n * [`.protoCodes()`](#multiaddrprotocodes) or\n * [`.protoNames()`](#multiaddrprotonames)\n */\n\nMultiaddr.protocols = protocols_1.protocols;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import bs58 from \"bs58\"\nimport CID from \"cids\"\nimport varint from \"varint\"\nimport * as codec from \"./codec\"\nimport { Protocol, protocols } from \"./protocols\"\n\n/**\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\n * a Buffer, String or another Multiaddr instance\n * public key.\n * @class Multiaddr\n * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\nclass Multiaddr {\n  public buffer: Buffer = Buffer.alloc(0)\n  constructor(addr: string | Multiaddr | Buffer) {\n    if (!(this instanceof Multiaddr)) {\n      return new Multiaddr(addr)\n    }\n\n    // default\n    if (addr == null) {\n      addr = \"\"\n    }\n\n    if (addr instanceof Buffer) {\n      /**\n       * @type {Buffer} - The raw bytes representing this multiaddress\n       */\n      this.buffer = codec.fromBuffer(addr)\n    } else if (typeof addr === \"string\" || addr instanceof String) {\n      if (addr.length > 0 && addr.charAt(0) !== \"/\") {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n      }\n      this.buffer = codec.fromString(addr as string)\n    } else if (addr.buffer && addr.protos && addr.protoCodes) {\n      // Multiaddr\n      this.buffer = codec.fromBuffer(addr.buffer) // validate + copy buffer\n    } else {\n      throw new Error(\"addr must be a string, Buffer, or another Multiaddr\")\n    }\n  }\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   */\n  toString(): string {\n    return codec.bufferToString(this.buffer)\n  }\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   */\n  toJSON = this.toString\n\n  /**\n   * Returns Multiaddr as a convenient options object to be used with network.createConnection\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   */\n  toOptions(): any {\n    const opts: any = {}\n    const parsed = this.toString().split(\"/\")\n    opts.family = parsed[1] === \"ip4\" ? \"ipv4\" : \"ipv6\"\n    opts.host = parsed[2]\n    opts.transport = parsed[3]\n    opts.port = parseInt(parsed[4])\n    return opts\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\n   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n   */\n  inspect(): string {\n    return (\n      \"<Multiaddr \" +\n      this.buffer.toString(\"hex\") +\n      \" - \" +\n      codec.bufferToString(this.buffer) +\n      \">\"\n    )\n  }\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   */\n  protos(): Protocol[] {\n    return this.protoCodes().map((code) => Object.assign({}, protocols(code)))\n  }\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   */\n  protoCodes(): number[] {\n    const codes = []\n    const buf = this.buffer\n    let i = 0\n    while (i < buf.length) {\n      const code = varint.decode(buf, i)\n      const n = varint.decode.bytes\n\n      const p = protocols(code)\n      const size = codec.sizeForAddr(p, buf.slice(i + n))\n\n      i += size + n\n      codes.push(code)\n    }\n\n    return codes\n  }\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   */\n  protoNames(): (string | number)[] {\n    return this.protos().map((proto) => proto.name)\n  }\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   */\n  tuples(): (number | Buffer)[][] {\n    return codec.bufferToTuples(this.buffer)\n  }\n\n  /**\n   * Returns a tuple of string/number parts\n   *\n   * @example\n   * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\n   */\n  stringTuples(): any[][] {\n    const t = codec.bufferToTuples(this.buffer)\n    return codec.tuplesToStringTuples(t)\n  }\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   */\n  encapsulate(addr: Multiaddr): Multiaddr {\n    addr = new Multiaddr(addr)\n    return new Multiaddr(this.toString() + addr.toString())\n  }\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   */\n  decapsulate(addr: Multiaddr): Multiaddr {\n    const str = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(str)\n    if (i < 0) {\n      throw new Error(\n        \"Address \" + this + \" does not contain subaddress: \" + addr\n      )\n    }\n    return new Multiaddr(s.slice(0, i))\n  }\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * const addr = Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   */\n  decapsulateCode(code: number): Multiaddr {\n    const tuples = this.tuples()\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(codec.tuplesToBuffer(tuples.slice(0, i)))\n      }\n    }\n    return this\n  }\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   */\n  getPeerId(): string | undefined {\n    let b58str: string | undefined\n    try {\n      const tuples = this.stringTuples().filter((tuple: any) => {\n        if (tuple[0] === protocols.names.ipfs.code) {\n          return true\n        }\n      })\n\n      // Get the last id\n      b58str = (tuples.pop() || [])[1]\n      // Get multihash, unwrap from CID if needed\n      b58str = bs58.encode(new CID(b58str || \"\").multihash)\n    } catch (e) {\n      b58str = undefined\n    }\n\n    return b58str\n  }\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   */\n  getPath(): string | null {\n    let path = null\n    try {\n      path = this.stringTuples().filter((tuple: any) => {\n        const proto = protocols(tuple[0])\n        if (proto.path) {\n          return true\n        }\n      })[0][1]\n    } catch (e) {\n      path = null\n    }\n\n    return path\n  }\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   */\n  equals(addr: Multiaddr): boolean {\n    return this.buffer.equals(addr.buffer)\n  }\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\n   */\n  nodeAddress(): {\n    family: string | number\n    address: string\n    port: string | number\n  } {\n    const codes = this.protoCodes()\n    const names = this.protoNames()\n    const parts = this.toString().split(\"/\").slice(1)\n\n    if (parts.length < 4) {\n      throw new Error(\n        'multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".'\n      )\n    } else if (\n      codes[0] !== 4 &&\n      codes[0] !== 41 &&\n      codes[0] !== 54 &&\n      codes[0] !== 55\n    ) {\n      throw new Error(\n        `no protocol with name: \"'${names[0]}'\". Must have a valid family name: \"{ip4, ip6, dns4, dns6}\".`\n      )\n    } else if (parts[2] !== \"tcp\" && parts[2] !== \"udp\") {\n      throw new Error(\n        `no protocol with name: \"'${names[1]}'\". Must have a valid transport protocol: \"{tcp, udp}\".`\n      )\n    }\n\n    return {\n      family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,\n      address: parts[1], // ip addr\n      port: parseInt(parts[3]), // tcp or udp port\n    }\n  }\n\n  /**\n   * Creates a Multiaddr from a node-friendly address object\n   *\n   * @example\n   * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   */\n  static fromNodeAddress(\n    addr: {\n      family: string | number\n      address: string\n      port: string | number\n    },\n    transport: string\n  ): Multiaddr {\n    if (!addr) throw new Error(\"requires node address object\")\n    if (!transport) throw new Error(\"requires transport protocol\")\n    const ip = addr.family === \"IPv6\" ? \"ip6\" : \"ip4\"\n    return new Multiaddr(\n      \"/\" + [ip, addr.address, transport, addr.port].join(\"/\")\n    )\n  }\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   */\n  static isThinWaistAddress(addr: Multiaddr): boolean {\n    const protos = (addr || this).protos()\n\n    if (protos.length !== 2) {\n      return false\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false\n    }\n    return !(protos[1].code !== 6 && protos[1].code !== 273)\n  }\n\n  /**\n   * Object containing table, names and codes of all supported protocols.\n   * To get the protocol values from a Multiaddr, you can use\n   * [`.protos()`](#multiaddrprotos),\n   * [`.protoCodes()`](#multiaddrprotocodes) or\n   * [`.protoNames()`](#multiaddrprotonames)\n   */\n  static protocols = protocols\n\n  /**\n   * Returns if something is a Multiaddr that is a name\n   */\n  static isName(addr: Multiaddr): boolean {\n    if (!Multiaddr.isMultiaddr(addr)) {\n      return false\n    }\n\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable)\n  }\n\n  /**\n   * Returns an array of multiaddrs, by resolving the multiaddr that is a name\n   */\n  static resolve(addr: Multiaddr): Promise<never> {\n    if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n      return Promise.reject(Error(\"not a valid name\"))\n    }\n\n    /*\n     * Needs more consideration from spec design:\n     *   - what to return\n     *   - how to achieve it in the browser?\n     */\n    return Promise.reject(new Error(\"not implemented yet\"))\n  }\n\n  static isMultiaddr(other: any): any {\n    return other\n  }\n}\n\nexport { Multiaddr }\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}