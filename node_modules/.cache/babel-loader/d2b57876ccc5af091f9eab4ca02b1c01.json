{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transaction = void 0;\n/**\n * @packageDocumentation\n * @module @textile/threads-client\n */\n\nconst grpc_web_1 = require(\"@improbable-eng/grpc-web\");\n/**\n * Transaction represents a bulk transaction on a store.\n * @hidden\n */\n\n\nclass Transaction {\n  /**\n   * Transaction creates a new transaction for the given store using the given model.\n   * @param client The gRPC client to use for the transaction.\n   * @param threadID the ID of the database\n   * @param modelName The human-readable name for the model.\n   */\n  constructor(client, threadID, modelName) {\n    this.client = client;\n    this.threadID = threadID;\n    this.modelName = modelName;\n  }\n  /**\n   * end completes (flushes) the transaction. All operations between start and end will be applied as a single transaction upon a call to end.\n   */\n\n\n  end() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.client.close();\n    });\n  }\n  /**\n   * setReject rejects the current transaction, rather than flushing the results to the remote store via end.\n   * @param reject The optional reason for rejecting the transaction.\n   */\n\n\n  setReject(reject) {\n    this.client.onEnd((status, message) => {\n      if (status !== grpc_web_1.grpc.Code.OK) {\n        reject(new Error(message));\n      }\n    });\n  }\n\n}\n\nexports.Transaction = Transaction;","map":{"version":3,"sources":["../../src/models/Transaction.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAIA,MAAA,UAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;AAGA;;;;;;AAIA,MAAa,WAAb,CAAwB;AAItB;;;;;;AAMA,EAAA,WAAA,CACqB,MADrB,EAEqB,QAFrB,EAGqB,SAHrB,EAGsC;AAFjB,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,QAAA,GAAA,QAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACjB;AAEJ;;;;;AAGa,EAAA,GAAG,GAAA;;AACd,WAAK,MAAL,CAAY,KAAZ;AACD,K;AAAA;AAED;;;;;;AAIU,EAAA,SAAS,CAAC,MAAD,EAA+B;AAChD,SAAK,MAAL,CAAY,KAAZ,CAAkB,CAAC,MAAD,EAAoB,OAApB,KAAuC;AACvD,UAAI,MAAM,KAAK,UAAA,CAAA,IAAA,CAAK,IAAL,CAAU,EAAzB,EAA6B;AAC3B,QAAA,MAAM,CAAC,IAAI,KAAJ,CAAU,OAAV,CAAD,CAAN;AACD;AACF,KAJD;AAKD;;AAjCqB;;AAAxB,OAAA,CAAA,WAAA,GAAA,WAAA","sourcesContent":["/**\n * @packageDocumentation\n * @module @textile/threads-client\n */\nimport { grpc } from \"@improbable-eng/grpc-web\"\nimport { ThreadID } from \"@textile/threads-id\"\n\n/**\n * Transaction represents a bulk transaction on a store.\n * @hidden\n */\nexport class Transaction<\n  TRequest extends grpc.ProtobufMessage,\n  TResponse extends grpc.ProtobufMessage\n> {\n  /**\n   * Transaction creates a new transaction for the given store using the given model.\n   * @param client The gRPC client to use for the transaction.\n   * @param threadID the ID of the database\n   * @param modelName The human-readable name for the model.\n   */\n  constructor(\n    protected readonly client: grpc.Client<TRequest, TResponse>,\n    protected readonly threadID: ThreadID,\n    protected readonly modelName: string\n  ) {}\n\n  /**\n   * end completes (flushes) the transaction. All operations between start and end will be applied as a single transaction upon a call to end.\n   */\n  public async end(): Promise<void> {\n    this.client.close()\n  }\n\n  /**\n   * setReject rejects the current transaction, rather than flushing the results to the remote store via end.\n   * @param reject The optional reason for rejecting the transaction.\n   */\n  protected setReject(reject: (reason?: any) => void): void {\n    this.client.onEnd((status: grpc.Code, message: string) => {\n      if (status !== grpc.Code.OK) {\n        reject(new Error(message))\n      }\n    })\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}