{"ast":null,"code":"'use strict';\n\nvar isEqual = require('lodash.isequal');\n\nvar xor = require('lodash.xor');\n\nvar keys = require('lodash.keys');\n\nvar _require = require('./jsonSchemaHelpers'),\n    types = _require.types,\n    FORMAT_REGEXPS = _require.FORMAT_REGEXPS,\n    isFormat = _require.isFormat;\n\nvar helpers = {\n  stringFormats: keys(FORMAT_REGEXPS),\n  isFormat: isFormat,\n  typeNames: ['integer', 'number', // make sure number is after integer (for proper type detection)\n  'string', 'array', 'object', 'boolean', 'null', 'date'],\n  getType: function getType(val) {\n    return helpers.typeNames.find(function (typeName) {\n      return types[typeName](val);\n    });\n  },\n\n  /**\n   * Tries to find the least common schema from two supplied JSON schemas. If it is unable to find\n   * such a schema, it returns null. Incompatibility in structure/types leads to returning null,\n   * except when the difference is only integer/number. Than the 'number' is used instead 'int'.\n   * Types/Structure incompatibility in array items only leads to schema that doesn't specify\n   * items structure/type.\n   * @param {object} schema1 - JSON schema\n   * @param {object} schema2 - JSON schema\n   * @returns {object|null}\n   */\n  mergeSchemaObjs: function mergeSchemaObjs(schema1, schema2) {\n    var schema1Keys = keys(schema1);\n    var schema2Keys = keys(schema2);\n\n    if (!isEqual(schema1Keys, schema2Keys)) {\n      if (schema1.type === 'array' && schema2.type === 'array') {\n        // TODO optimize???\n        if (isEqual(xor(schema1Keys, schema2Keys), ['items'])) {\n          var schemaWithoutItems = schema1Keys.length > schema2Keys.length ? schema2 : schema1;\n          var schemaWithItems = schema1Keys.length > schema2Keys.length ? schema1 : schema2;\n          var isSame = keys(schemaWithoutItems).reduce(function (acc, current) {\n            return isEqual(schemaWithoutItems[current], schemaWithItems[current]) && acc;\n          }, true);\n\n          if (isSame) {\n            return schemaWithoutItems;\n          }\n        }\n      }\n\n      if (schema1.type !== 'object' || schema2.type !== 'object') {\n        return null;\n      }\n    }\n\n    var retObj = {};\n\n    for (var i = 0, length = schema1Keys.length; i < length; i++) {\n      var key = schema1Keys[i];\n\n      if (helpers.getType(schema1[key]) === 'object') {\n        var x = helpers.mergeSchemaObjs(schema1[key], schema2[key]);\n\n        if (!x) {\n          if (schema1.type === 'object' || schema2.type === 'object') {\n            return {\n              type: 'object'\n            };\n          } // special treatment for array items. If not mergeable, we can do without them\n\n\n          if (key !== 'items' || schema1.type !== 'array' || schema2.type !== 'array') {\n            return null;\n          }\n        } else {\n          retObj[key] = x;\n        }\n      } else {\n        // simple value schema properties (not defined by object)\n        if (key === 'type') {\n          // eslint-disable-line no-lonely-if\n          if (schema1[key] !== schema2[key]) {\n            if (schema1[key] === 'integer' && schema2[key] === 'number' || schema1[key] === 'number' && schema2[key] === 'integer') {\n              retObj[key] = 'number';\n            } else {\n              return null;\n            }\n          } else {\n            retObj[key] = schema1[key];\n          }\n        } else {\n          if (!isEqual(schema1[key], schema2[key])) {\n            // TODO Is it even possible to take this path?\n            return null;\n          }\n\n          retObj[key] = schema1[key];\n        }\n      }\n    }\n\n    return retObj;\n  }\n};\nmodule.exports = helpers;","map":{"version":3,"sources":["/Users/nassarhayat/apps/textiletable/dobby/node_modules/to-json-schema/lib/helpers.js"],"names":["isEqual","require","xor","keys","_require","types","FORMAT_REGEXPS","isFormat","helpers","stringFormats","typeNames","getType","val","find","typeName","mergeSchemaObjs","schema1","schema2","schema1Keys","schema2Keys","type","schemaWithoutItems","length","schemaWithItems","isSame","reduce","acc","current","retObj","i","key","x","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isEqual = require('lodash.isequal');\n\nvar xor = require('lodash.xor');\n\nvar keys = require('lodash.keys');\n\nvar _require = require('./jsonSchemaHelpers'),\n    types = _require.types,\n    FORMAT_REGEXPS = _require.FORMAT_REGEXPS,\n    isFormat = _require.isFormat;\n\nvar helpers = {\n  stringFormats: keys(FORMAT_REGEXPS),\n  isFormat: isFormat,\n  typeNames: ['integer', 'number', // make sure number is after integer (for proper type detection)\n  'string', 'array', 'object', 'boolean', 'null', 'date'],\n  getType: function getType(val) {\n    return helpers.typeNames.find(function (typeName) {\n      return types[typeName](val);\n    });\n  },\n\n  /**\n   * Tries to find the least common schema from two supplied JSON schemas. If it is unable to find\n   * such a schema, it returns null. Incompatibility in structure/types leads to returning null,\n   * except when the difference is only integer/number. Than the 'number' is used instead 'int'.\n   * Types/Structure incompatibility in array items only leads to schema that doesn't specify\n   * items structure/type.\n   * @param {object} schema1 - JSON schema\n   * @param {object} schema2 - JSON schema\n   * @returns {object|null}\n   */\n  mergeSchemaObjs: function mergeSchemaObjs(schema1, schema2) {\n    var schema1Keys = keys(schema1);\n    var schema2Keys = keys(schema2);\n\n    if (!isEqual(schema1Keys, schema2Keys)) {\n      if (schema1.type === 'array' && schema2.type === 'array') {\n        // TODO optimize???\n        if (isEqual(xor(schema1Keys, schema2Keys), ['items'])) {\n          var schemaWithoutItems = schema1Keys.length > schema2Keys.length ? schema2 : schema1;\n          var schemaWithItems = schema1Keys.length > schema2Keys.length ? schema1 : schema2;\n          var isSame = keys(schemaWithoutItems).reduce(function (acc, current) {\n            return isEqual(schemaWithoutItems[current], schemaWithItems[current]) && acc;\n          }, true);\n\n          if (isSame) {\n            return schemaWithoutItems;\n          }\n        }\n      }\n\n      if (schema1.type !== 'object' || schema2.type !== 'object') {\n        return null;\n      }\n    }\n\n    var retObj = {};\n\n    for (var i = 0, length = schema1Keys.length; i < length; i++) {\n      var key = schema1Keys[i];\n\n      if (helpers.getType(schema1[key]) === 'object') {\n        var x = helpers.mergeSchemaObjs(schema1[key], schema2[key]);\n\n        if (!x) {\n          if (schema1.type === 'object' || schema2.type === 'object') {\n            return {\n              type: 'object'\n            };\n          } // special treatment for array items. If not mergeable, we can do without them\n\n\n          if (key !== 'items' || schema1.type !== 'array' || schema2.type !== 'array') {\n            return null;\n          }\n        } else {\n          retObj[key] = x;\n        }\n      } else {\n        // simple value schema properties (not defined by object)\n        if (key === 'type') {\n          // eslint-disable-line no-lonely-if\n          if (schema1[key] !== schema2[key]) {\n            if (schema1[key] === 'integer' && schema2[key] === 'number' || schema1[key] === 'number' && schema2[key] === 'integer') {\n              retObj[key] = 'number';\n            } else {\n              return null;\n            }\n          } else {\n            retObj[key] = schema1[key];\n          }\n        } else {\n          if (!isEqual(schema1[key], schema2[key])) {\n            // TODO Is it even possible to take this path?\n            return null;\n          }\n\n          retObj[key] = schema1[key];\n        }\n      }\n    }\n\n    return retObj;\n  }\n};\nmodule.exports = helpers;"]},"metadata":{},"sourceType":"script"}