{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Buckets = void 0;\n\nconst grpc_authentication_1 = require(\"@textile/grpc-authentication\");\n\nconst hub_threads_client_1 = require(\"@textile/hub-threads-client\");\n\nconst threads_id_1 = require(\"@textile/threads-id\");\n\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\n\nconst api_1 = require(\"./api\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger = loglevel_1.default.getLogger('buckets');\n/**\n * Buckets a client wrapper for interacting with the Textile Buckets API.\n * @example\n * Initialize the Bucket API and open an existing bucket (or create if new).\n * ```typescript\n * import { Buckets, UserAuth } from '@textile/hub'\n *\n * const getOrCreate = async (auth: UserAuth, bucketName: string) => {\n *   const buckets = Buckets.withUserAuth(auth)\n *   // Automatically scopes future calls on `buckets` to the Thread containing the bucket\n *   const { root, threadID } = await buckets.getOrCreate(bucketName)\n *   if (!root) throw new Error('bucket not created')\n *   const bucketKey = root.key\n *   return { buckets, bucketKey }\n * }\n * ```\n *\n * @example\n * Print the links for the bucket\n * ```typescript\n * import { Buckets } from '@textile/hub'\n *\n * // This method requires that you run \"getOrCreate\" or have specified \"withThread\"\n * async function logLinks (buckets: Buckets, bucketKey: string) {\n *   const links = await buckets.links(bucketKey)\n *   console.log(links)\n * }\n * ```\n *\n * @example\n * Find an existing Bucket\n * ```typescript\n * import { Buckets } from '@textile/hub'\n *\n * // This method requires that you already specify the Thread containing\n * // the bucket with buckets.withThread(<thread name>).\n * const exists = async (buckets: Buckets, bucketName: string) => {\n *     const roots = await buckets.list();\n *     return roots.find((bucket) => bucket.name === bucketName)\n * }\n * ```\n *\n * @example\n * Push an folder in node.js\n * ```typescript\n * import fs from 'fs'\n * import util from 'util'\n * import glob from 'glob'\n * import { Buckets } from '@textile/hub'\n *\n * const globDir = util.promisify(glob)\n *\n * // expects an already setup buckets session using getOrCreate or withThread\n * const exists = async (buckets: Buckets, bucketKey: string, dir: string) => {\n *   const files = await globDir('<dir glob options>')\n *   return await Promise.all(files.map(async (file) => {\n *     const filePath = dir + '/' + file\n *     var content = fs.createReadStream(filePath, { highWaterMark: 1024 * 1024 * 3 });\n *     const upload = {\n *       path: file,\n *       content\n *     }\n *     return await buckets.pushPath(bucketKey, file, upload)\n *   }))\n * }\n * ```\n */\n\nclass Buckets extends grpc_authentication_1.GrpcAuthentication {\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.copyAuth}\n   *\n   * @example\n   * Copy an authenticated Users api instance to Buckets.\n   * ```typescript\n   * import { Buckets, Users } from '@textile/hub'\n   *\n   * const usersToBuckets = async (user: Users) => {\n   *   const buckets = Buckets.copyAuth(user)\n   *   return buckets\n   * }\n   * ```\n   *\n   * @example\n   * Copy an authenticated Buckets api instance to Users.\n   * ```typescript\n   * import { Buckets, Users } from '@textile/hub'\n   *\n   * const bucketsToUsers = async (buckets: Buckets) => {\n   *   const user = Users.copyAuth(buckets)\n   *   return user\n   * }\n   * ```\n   */\n  static copyAuth(auth, options) {\n    return new Buckets(auth.context, options === null || options === void 0 ? void 0 : options.debug);\n  }\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.withUserAuth}\n   *\n   * @example\n   * ```@typescript\n   * import { Buckets, UserAuth } from '@textile/hub'\n   *\n   * async function example (userAuth: UserAuth) {\n   *   const buckets = await Buckets.withUserAuth(userAuth)\n   * }\n   * ```\n   */\n\n\n  static withUserAuth(auth, options) {\n    const res = super.withUserAuth(auth, options);\n    return this.copyAuth(res, options);\n  }\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.withKeyInfo}\n   *\n   * @example\n   * ```@typescript\n   * import { Buckets, KeyInfo } from '@textile/hub'\n   *\n   * async function start () {\n   *   const keyInfo: KeyInfo = {\n   *     key: '<api key>',\n   *     secret: '<api secret>'\n   *   }\n   *   const buckets = await Buckets.withKeyInfo(keyInfo)\n   * }\n   * ```\n   */\n\n\n  static withKeyInfo(key, options) {\n    const _super = Object.create(null, {\n      withKeyInfo: {\n        get: () => super.withKeyInfo\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const auth = yield _super.withKeyInfo.call(this, key, options);\n      return this.copyAuth(auth, options);\n    });\n  }\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.withThread}\n   *\n   * @example\n   * ```@typescript\n   * import { Buckets, ThreadID } from '@textile/hub'\n   *\n   * async function example (threadID: ThreadID) {\n   *   const buckets = await Buckets.withThread(threadID)\n   * }\n   * ```\n   */\n\n\n  withThread(threadID) {\n    return super.withThread(threadID);\n  }\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.getToken}\n   *\n   * @example\n   * ```@typescript\n   * import { Buckets, PrivateKey } from '@textile/hub'\n   *\n   * async function example (buckets: Buckets, identity: PrivateKey) {\n   *   const token = await buckets.getToken(identity)\n   *   return token // already added to `buckets` scope\n   * }\n   * ```\n   */\n\n\n  getToken(identity) {\n    const _super = Object.create(null, {\n      getToken: {\n        get: () => super.getToken\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return _super.getToken.call(this, identity);\n    });\n  }\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.getTokenChallenge}\n   *\n   * @example\n   * ```typescript\n   * import { Buckets, PrivateKey } from '@textile/hub'\n   *\n   * async function example (buckets: Buckets, identity: PrivateKey) {\n   *   const token = await buckets.getTokenChallenge(\n   *     identity.public.toString(),\n   *     (challenge: Uint8Array) => {\n   *       return new Promise((resolve, reject) => {\n   *         // This is where you should program PrivateKey to respond to challenge\n   *         // Read more here: https://docs.textile.io/tutorials/hub/production-auth/\n   *       })\n   *     }\n   *   )\n   *   return token\n   * }\n   * ```\n   */\n\n\n  getTokenChallenge(publicKey, callback) {\n    const _super = Object.create(null, {\n      getTokenChallenge: {\n        get: () => super.getTokenChallenge\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return _super.getTokenChallenge.call(this, publicKey, callback);\n    });\n  }\n  /**\n   * (Deprecated) Open a new / existing bucket by bucket name and ThreadID (create not required)\n   * @param name name of bucket\n   * @param threadName the name of the thread where the bucket is stored (default `buckets`)\n   * @param isPrivate encrypt the bucket contents (default `false`)\n   * @param threadID id of thread where bucket is stored\n   * @deprecated Open has been replaced with getOrCreate\n   */\n\n\n  open(name, threadName = 'buckets', isPrivate = false, threadID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.getOrCreate(name, threadName, isPrivate, threadID);\n    });\n  }\n  /**\n   * (Deprecated) Open a new / existing bucket by bucket name and ThreadID (create not required)\n   * @param name name of bucket\n   * @param threadName the name of the thread where the bucket is stored (default `buckets`)\n   * @param isPrivate encrypt the bucket contents (default `false`)\n   * @param threadID id of thread where bucket is stored\n   * @deprecated getOrInit has been replaced with getOrCreate\n   */\n\n\n  getOrInit(name, threadName = 'buckets', isPrivate = false, threadID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.getOrCreate(name, threadName, isPrivate, threadID);\n    });\n  }\n  /**\n   * Open a new / existing bucket by bucket name and ThreadID (create not required)\n   * Replaces `open` command in older versions.\n   * @param name name of bucket\n   * @param threadName the name of the thread where the bucket is stored (default `buckets`)\n   * @param isPrivate encrypt the bucket contents (default `false`)\n   * @param threadID id of thread where bucket is stored\n   *\n   * @remarks\n   * The IPFS protocol and its implementations are still in heavy\n   * development. By using Textile, you are acknowledging that you\n   * understand there may be risks to storing your content on or\n   * using decentralized storage services.\n   *\n   * @example\n   * Create a Bucket called \"app-name-files\"\n   * ```typescript\n   * import { Buckets, UserAuth } from '@textile/hub'\n   *\n   * const open = async (auth: UserAuth, name: string) => {\n   *     const buckets = Buckets.withUserAuth(auth)\n   *     const { root, threadID } = await buckets.getOrCreate(name)\n   *     return { buckets, root, threadID }\n   * }\n   * ```\n   */\n\n\n  getOrCreate(name, threadName = 'buckets', isPrivate = false, threadID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = new hub_threads_client_1.Client(this.context);\n\n      if (threadID) {\n        const id = threadID;\n        const res = yield client.listThreads();\n        const exists = res.listList.find(thread => thread.id === id);\n\n        if (!exists) {\n          const id = threads_id_1.ThreadID.fromString(threadID);\n          yield client.newDB(id, threadName);\n        }\n\n        this.withThread(threadID);\n      } else {\n        try {\n          const res = yield client.getThread(threadName);\n          threadID = typeof res.id === 'string' ? res.id : threads_id_1.ThreadID.fromBytes(res.id).toString();\n          this.withThread(threadID);\n        } catch (error) {\n          if (error.message !== 'Thread not found') {\n            throw new Error(error.message);\n          }\n\n          const newId = threads_id_1.ThreadID.fromRandom();\n          yield client.newDB(newId, threadName);\n          threadID = newId.toString();\n          this.withThread(threadID);\n        }\n      }\n\n      const roots = yield this.list();\n      const existing = roots.find(bucket => bucket.name === name);\n\n      if (existing) {\n        return {\n          root: existing,\n          threadID\n        };\n      }\n\n      const created = yield this.create(name, isPrivate);\n      return {\n        root: created.root,\n        threadID\n      };\n    });\n  }\n  /**\n   * (Deprecated) Creates a new bucket.\n   * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.\n   * @param isPrivate encrypt the bucket contents (default `false`)\n   * @deprecated Init has been replaced by create\n   */\n\n\n  init(name, isPrivate = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.create(name, isPrivate);\n    });\n  }\n  /**\n   * Creates a new bucket.\n   * @public\n   * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.\n   * @param isPrivate encrypt the bucket contents (default `false`)\n   * @example\n   * Create a Bucket called \"app-name-files\"\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const create = async (buckets: Buckets) => {\n   *     return buckets.create(\"app-name-files\")\n   * }\n   * ```\n   */\n\n\n  create(name, isPrivate = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('create request');\n      return api_1.bucketsCreate(this, name, isPrivate);\n    });\n  }\n  /**\n   * Returns the bucket root CID\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   */\n\n\n  root(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('root request');\n      return api_1.bucketsRoot(this, key);\n    });\n  }\n  /**\n   * Returns a list of bucket links.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @example\n   * Generate the HTTP, IPNS, and IPFS links for a Bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const getIpnsLink = async (buckets: Buckets, bucketKey: string) => {\n   *    const links = await buckets.links(bucketKey)\n   *    return links.ipns\n   * }\n   *\n   * const getWwwLink = async (buckets: Buckets, bucketKey: string) => {\n   *    const links = await buckets.links(bucketKey)\n   *    return links.www\n   * }\n   * ```\n   */\n\n\n  links(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('link request');\n      return api_1.bucketsLinks(this, key);\n    });\n  }\n  /**\n   * Returns a list of all bucket roots.\n   * @example\n   * Find an existing Bucket named \"app-name-files\"\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const exists = async (buckets: Buckets) => {\n   *     const roots = await buckets.list();\n   *     return roots.find((bucket) => bucket.name ===  \"app-name-files\")\n   * }\n   * ````\n   */\n\n\n  list() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('list request');\n      return api_1.bucketsList(this);\n    });\n  }\n  /**\n   * Returns information about a bucket path.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param depth (optional) will walk the entire bucket to target depth (default = 1)\n   */\n\n\n  listPath(key, path, depth = 1) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('list path request');\n      return yield utils_1.listPathRecursive(this, key, path, depth);\n    });\n  }\n  /**\n   * listPathRecursive returns a nested object of all paths (and info) in a bucket\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param dirs (optional) if false will include only file paths\n   * @param depth (optional) will walk the entire bucket to target depth (default = 1)\n   *\n   * @example\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function printPaths(buckets: Buckets, bucketKey: string) {\n   *   const list = await buckets.listPathFlat(bucketKey, '')\n   *   console.log(list)\n   * }\n   * // [\n   * //   '.textileseed',\n   * //   'dir1',\n   * //   'dir1/file1.jpg',\n   * //   'path',\n   * //   'path/to',\n   * //   'path/to/file2.jpg'\n   * // ]\n   * ```\n   */\n\n\n  listPathFlat(key, path, dirs = true, depth = 5) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('list path recursive request');\n      return yield utils_1.listPathFlat(this, key, path, dirs, depth);\n    });\n  }\n  /**\n   * listIpfsPath returns items at a particular path in a UnixFS path living in the IPFS network.\n   * @param path UnixFS path\n   */\n\n\n  listIpfsPath(path) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('list path request');\n      return api_1.bucketsListIpfsPath(this, path);\n    });\n  }\n  /**\n   * Pushes a file to a bucket path.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param input The input file/stream/object.\n   * @param opts Options to control response stream. Currently only supports a progress function.\n   * @remarks\n   * This will return the resolved path and the bucket's new root path.\n   * @example\n   * Push a file to the root of a bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const pushFile = async (buckets: Buckets, content: string, bucketKey: string) => {\n   *    const file = { path: '/index.html', content: Buffer.from(content) }\n   *    return await buckets.pushPath(bucketKey!, 'index.html', file)\n   * }\n   * ```\n   *\n   * @example\n   * Push an folder in node.js\n   * ```typescript\n   * import fs from 'fs'\n   * import util from 'util'\n   * import glob from 'glob'\n   * import { Buckets } from '@textile/hub'\n   *\n   * const globDir = util.promisify(glob)\n   *\n   * // expects an already setup buckets session using getOrCreate or withThread\n   * const exists = async (buckets: Buckets, bucketKey: string, dir: string) => {\n   *   const files = await globDir('<dir glob options>')\n   *   return await Promise.all(files.map(async (file) => {\n   *     const filePath = dir + '/' + file\n   *     var content = fs.createReadStream(filePath, { highWaterMark: 1024 * 1024 * 3 });\n   *     const upload = {\n   *       path: file,\n   *       content\n   *     }\n   *     return await buckets.pushPath(bucketKey, file, upload)\n   *   }))\n   * }\n   * ```\n   */\n\n\n  pushPath(key, path, input, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return api_1.bucketsPushPath(this, key, path, input, opts);\n    });\n  }\n  /**\n   * Pulls the bucket path, returning the bytes of the given file.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param opts Options to control response stream. Currently only supports a progress function.\n   *\n   * @example\n   * Pull a file by its relative path and console.log the progress.\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const pullFile = async (buckets: Buckets, key: string, path: string) => {\n   *    const display = (num?: number) => {\n   *      console.log('Progress:', num)\n   *    }\n   *    buckets.pullPath(key, path, {progress: display})\n   * }\n   * ```\n   */\n\n\n  pullPath(key, path, opts) {\n    return api_1.bucketsPullPath(this, key, path, opts);\n  }\n  /**\n   * Pushes a file to a bucket path.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param cid The IPFS cid of the dag to set at the path.\n   *\n   * @example\n   * Push a file to the root of a bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const pushRoot = async (buckets: Buckets, key: string, cid: string) => {\n   *    return await buckets.setPath(key, '/', cid)\n   * }\n   * ```\n   */\n\n\n  setPath(key, path, cid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return api_1.bucketsSetPath(this, key, path, cid);\n    });\n  }\n  /**\n   * pullIpfsPath pulls the path from a remote UnixFS dag, writing it to writer if it's a file.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param opts Options to control response stream. Currently only supports a progress function.\n   *\n   * @example\n   * Pull a file by its IPFS path and console.log the progress.\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const pullFile = async (buckets: Buckets, path: string) => {\n   *    const display = (num?: number) => {\n   *      console.log('Progress:', num)\n   *    }\n   *    buckets.pullIpfsPath(path, {progress: display})\n   * }\n   * ```\n   */\n\n\n  pullIpfsPath(path, opts) {\n    return api_1.bucketsPullIpfsPath(this, path, opts);\n  }\n  /**\n   * Removes an entire bucket. Files and directories will be unpinned (cannot be undone).\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   *\n   * @example\n   * Remove a Bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const remove = async (buckets: Buckets, key: string) => {\n   *    buckets.remove(key)\n   * }\n   * ```\n   */\n\n\n  remove(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('remove request');\n      return api_1.bucketsRemove(this, key);\n    });\n  }\n  /**\n   * Returns information about a bucket path (cannot be undone).\n   *\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A relative path within a bucket.\n   * @param root optional to specify a root.\n   *\n   * @example\n   * Remove a file by its relative path\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const remove = async (buckets: Buckets, key: string) => {\n   *    buckets.remove(key)\n   * }\n   * ```\n   */\n\n\n  removePath(key, path, root) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('remove path request');\n      return api_1.bucketsRemovePath(this, key, path, root);\n    });\n  }\n  /**\n   * (Experimental) Store a snapshot of the bucket on Filecoin.\n   * @remarks\n   * Filecoin support is experimental. By using Textile, you\n   * are acknowledging that you understand there may be risks to\n   * storing your content on or using decentralized storage\n   * services.\n   *\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   *\n   * @example\n   * Remove a file by its relative path\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function archive (buckets: Buckets, key: string) {\n   *    buckets.archive(key)\n   * }\n   * ```\n   */\n\n\n  archive(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('archive request');\n      return api_1.bucketsArchive(this, key);\n    });\n  }\n  /**\n   * archiveStatus returns the status of a Filecoin bucket archive.\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   *\n   * @example\n   * Remove a file by its relative path\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function status (buckets: Buckets, key: string) {\n   *    buckets.archive(key)\n   * }\n   * ```\n   */\n\n\n  archiveStatus(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('archive status request');\n      return api_1.bucketsArchiveStatus(this, key);\n    });\n  }\n  /**\n   * archiveInfo returns info about a Filecoin bucket archive.\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   *\n   * @example\n   * Display the info for an existing archives of the bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function log (buckets: Buckets, key: string) {\n   *    const info = await buckets.archiveInfo(key)\n   *    console.log(info.cid, info.deals.length)\n   * }\n   * ```\n   */\n\n\n  archiveInfo(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('archive info request');\n      return api_1.bucketsArchiveInfo(this, key);\n    });\n  }\n  /**\n   * archiveWatch watches status events from a Filecoin bucket archive.\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   *\n   * @example\n   * Watch deal state changes for a active bucket archive request.\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function logChanges (buckets: Buckets, key: string) {\n   *    const log = (reply?: {id?: string, msg: string}, err?: Error | undefined) => {\n   *        if (err || !reply) return console.log(err)\n   *        console.log(reply.id, reply.msg)\n   *    }\n   *    buckets.archiveWatch(key, log)\n   * }\n   * ```\n   */\n\n\n  archiveWatch(key, callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('archive watch request');\n      return api_1.bucketsArchiveWatch(this, key, callback);\n    });\n  }\n\n}\n\nexports.Buckets = Buckets;","map":{"version":3,"sources":["../src/buckets.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Buckets = void 0;\nconst grpc_authentication_1 = require(\"@textile/grpc-authentication\");\nconst hub_threads_client_1 = require(\"@textile/hub-threads-client\");\nconst threads_id_1 = require(\"@textile/threads-id\");\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\nconst api_1 = require(\"./api\");\nconst utils_1 = require(\"./utils\");\nconst logger = loglevel_1.default.getLogger('buckets');\n/**\n * Buckets a client wrapper for interacting with the Textile Buckets API.\n * @example\n * Initialize the Bucket API and open an existing bucket (or create if new).\n * ```typescript\n * import { Buckets, UserAuth } from '@textile/hub'\n *\n * const getOrCreate = async (auth: UserAuth, bucketName: string) => {\n *   const buckets = Buckets.withUserAuth(auth)\n *   // Automatically scopes future calls on `buckets` to the Thread containing the bucket\n *   const { root, threadID } = await buckets.getOrCreate(bucketName)\n *   if (!root) throw new Error('bucket not created')\n *   const bucketKey = root.key\n *   return { buckets, bucketKey }\n * }\n * ```\n *\n * @example\n * Print the links for the bucket\n * ```typescript\n * import { Buckets } from '@textile/hub'\n *\n * // This method requires that you run \"getOrCreate\" or have specified \"withThread\"\n * async function logLinks (buckets: Buckets, bucketKey: string) {\n *   const links = await buckets.links(bucketKey)\n *   console.log(links)\n * }\n * ```\n *\n * @example\n * Find an existing Bucket\n * ```typescript\n * import { Buckets } from '@textile/hub'\n *\n * // This method requires that you already specify the Thread containing\n * // the bucket with buckets.withThread(<thread name>).\n * const exists = async (buckets: Buckets, bucketName: string) => {\n *     const roots = await buckets.list();\n *     return roots.find((bucket) => bucket.name === bucketName)\n * }\n * ```\n *\n * @example\n * Push an folder in node.js\n * ```typescript\n * import fs from 'fs'\n * import util from 'util'\n * import glob from 'glob'\n * import { Buckets } from '@textile/hub'\n *\n * const globDir = util.promisify(glob)\n *\n * // expects an already setup buckets session using getOrCreate or withThread\n * const exists = async (buckets: Buckets, bucketKey: string, dir: string) => {\n *   const files = await globDir('<dir glob options>')\n *   return await Promise.all(files.map(async (file) => {\n *     const filePath = dir + '/' + file\n *     var content = fs.createReadStream(filePath, { highWaterMark: 1024 * 1024 * 3 });\n *     const upload = {\n *       path: file,\n *       content\n *     }\n *     return await buckets.pushPath(bucketKey, file, upload)\n *   }))\n * }\n * ```\n */\nclass Buckets extends grpc_authentication_1.GrpcAuthentication {\n    /**\n     * {@inheritDoc @textile/hub#GrpcAuthentication.copyAuth}\n     *\n     * @example\n     * Copy an authenticated Users api instance to Buckets.\n     * ```typescript\n     * import { Buckets, Users } from '@textile/hub'\n     *\n     * const usersToBuckets = async (user: Users) => {\n     *   const buckets = Buckets.copyAuth(user)\n     *   return buckets\n     * }\n     * ```\n     *\n     * @example\n     * Copy an authenticated Buckets api instance to Users.\n     * ```typescript\n     * import { Buckets, Users } from '@textile/hub'\n     *\n     * const bucketsToUsers = async (buckets: Buckets) => {\n     *   const user = Users.copyAuth(buckets)\n     *   return user\n     * }\n     * ```\n     */\n    static copyAuth(auth, options) {\n        return new Buckets(auth.context, options === null || options === void 0 ? void 0 : options.debug);\n    }\n    /**\n     * {@inheritDoc @textile/hub#GrpcAuthentication.withUserAuth}\n     *\n     * @example\n     * ```@typescript\n     * import { Buckets, UserAuth } from '@textile/hub'\n     *\n     * async function example (userAuth: UserAuth) {\n     *   const buckets = await Buckets.withUserAuth(userAuth)\n     * }\n     * ```\n     */\n    static withUserAuth(auth, options) {\n        const res = super.withUserAuth(auth, options);\n        return this.copyAuth(res, options);\n    }\n    /**\n     * {@inheritDoc @textile/hub#GrpcAuthentication.withKeyInfo}\n     *\n     * @example\n     * ```@typescript\n     * import { Buckets, KeyInfo } from '@textile/hub'\n     *\n     * async function start () {\n     *   const keyInfo: KeyInfo = {\n     *     key: '<api key>',\n     *     secret: '<api secret>'\n     *   }\n     *   const buckets = await Buckets.withKeyInfo(keyInfo)\n     * }\n     * ```\n     */\n    static withKeyInfo(key, options) {\n        const _super = Object.create(null, {\n            withKeyInfo: { get: () => super.withKeyInfo }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const auth = yield _super.withKeyInfo.call(this, key, options);\n            return this.copyAuth(auth, options);\n        });\n    }\n    /**\n     * {@inheritDoc @textile/hub#GrpcAuthentication.withThread}\n     *\n     * @example\n     * ```@typescript\n     * import { Buckets, ThreadID } from '@textile/hub'\n     *\n     * async function example (threadID: ThreadID) {\n     *   const buckets = await Buckets.withThread(threadID)\n     * }\n     * ```\n     */\n    withThread(threadID) {\n        return super.withThread(threadID);\n    }\n    /**\n     * {@inheritDoc @textile/hub#GrpcAuthentication.getToken}\n     *\n     * @example\n     * ```@typescript\n     * import { Buckets, PrivateKey } from '@textile/hub'\n     *\n     * async function example (buckets: Buckets, identity: PrivateKey) {\n     *   const token = await buckets.getToken(identity)\n     *   return token // already added to `buckets` scope\n     * }\n     * ```\n     */\n    getToken(identity) {\n        const _super = Object.create(null, {\n            getToken: { get: () => super.getToken }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            return _super.getToken.call(this, identity);\n        });\n    }\n    /**\n     * {@inheritDoc @textile/hub#GrpcAuthentication.getTokenChallenge}\n     *\n     * @example\n     * ```typescript\n     * import { Buckets, PrivateKey } from '@textile/hub'\n     *\n     * async function example (buckets: Buckets, identity: PrivateKey) {\n     *   const token = await buckets.getTokenChallenge(\n     *     identity.public.toString(),\n     *     (challenge: Uint8Array) => {\n     *       return new Promise((resolve, reject) => {\n     *         // This is where you should program PrivateKey to respond to challenge\n     *         // Read more here: https://docs.textile.io/tutorials/hub/production-auth/\n     *       })\n     *     }\n     *   )\n     *   return token\n     * }\n     * ```\n     */\n    getTokenChallenge(publicKey, callback) {\n        const _super = Object.create(null, {\n            getTokenChallenge: { get: () => super.getTokenChallenge }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            return _super.getTokenChallenge.call(this, publicKey, callback);\n        });\n    }\n    /**\n     * (Deprecated) Open a new / existing bucket by bucket name and ThreadID (create not required)\n     * @param name name of bucket\n     * @param threadName the name of the thread where the bucket is stored (default `buckets`)\n     * @param isPrivate encrypt the bucket contents (default `false`)\n     * @param threadID id of thread where bucket is stored\n     * @deprecated Open has been replaced with getOrCreate\n     */\n    open(name, threadName = 'buckets', isPrivate = false, threadID) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getOrCreate(name, threadName, isPrivate, threadID);\n        });\n    }\n    /**\n     * (Deprecated) Open a new / existing bucket by bucket name and ThreadID (create not required)\n     * @param name name of bucket\n     * @param threadName the name of the thread where the bucket is stored (default `buckets`)\n     * @param isPrivate encrypt the bucket contents (default `false`)\n     * @param threadID id of thread where bucket is stored\n     * @deprecated getOrInit has been replaced with getOrCreate\n     */\n    getOrInit(name, threadName = 'buckets', isPrivate = false, threadID) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getOrCreate(name, threadName, isPrivate, threadID);\n        });\n    }\n    /**\n     * Open a new / existing bucket by bucket name and ThreadID (create not required)\n     * Replaces `open` command in older versions.\n     * @param name name of bucket\n     * @param threadName the name of the thread where the bucket is stored (default `buckets`)\n     * @param isPrivate encrypt the bucket contents (default `false`)\n     * @param threadID id of thread where bucket is stored\n     *\n     * @remarks\n     * The IPFS protocol and its implementations are still in heavy\n     * development. By using Textile, you are acknowledging that you\n     * understand there may be risks to storing your content on or\n     * using decentralized storage services.\n     *\n     * @example\n     * Create a Bucket called \"app-name-files\"\n     * ```typescript\n     * import { Buckets, UserAuth } from '@textile/hub'\n     *\n     * const open = async (auth: UserAuth, name: string) => {\n     *     const buckets = Buckets.withUserAuth(auth)\n     *     const { root, threadID } = await buckets.getOrCreate(name)\n     *     return { buckets, root, threadID }\n     * }\n     * ```\n     */\n    getOrCreate(name, threadName = 'buckets', isPrivate = false, threadID) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = new hub_threads_client_1.Client(this.context);\n            if (threadID) {\n                const id = threadID;\n                const res = yield client.listThreads();\n                const exists = res.listList.find((thread) => thread.id === id);\n                if (!exists) {\n                    const id = threads_id_1.ThreadID.fromString(threadID);\n                    yield client.newDB(id, threadName);\n                }\n                this.withThread(threadID);\n            }\n            else {\n                try {\n                    const res = yield client.getThread(threadName);\n                    threadID = typeof res.id === 'string' ? res.id : threads_id_1.ThreadID.fromBytes(res.id).toString();\n                    this.withThread(threadID);\n                }\n                catch (error) {\n                    if (error.message !== 'Thread not found') {\n                        throw new Error(error.message);\n                    }\n                    const newId = threads_id_1.ThreadID.fromRandom();\n                    yield client.newDB(newId, threadName);\n                    threadID = newId.toString();\n                    this.withThread(threadID);\n                }\n            }\n            const roots = yield this.list();\n            const existing = roots.find((bucket) => bucket.name === name);\n            if (existing) {\n                return { root: existing, threadID };\n            }\n            const created = yield this.create(name, isPrivate);\n            return { root: created.root, threadID };\n        });\n    }\n    /**\n     * (Deprecated) Creates a new bucket.\n     * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.\n     * @param isPrivate encrypt the bucket contents (default `false`)\n     * @deprecated Init has been replaced by create\n     */\n    init(name, isPrivate = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.create(name, isPrivate);\n        });\n    }\n    /**\n     * Creates a new bucket.\n     * @public\n     * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.\n     * @param isPrivate encrypt the bucket contents (default `false`)\n     * @example\n     * Create a Bucket called \"app-name-files\"\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const create = async (buckets: Buckets) => {\n     *     return buckets.create(\"app-name-files\")\n     * }\n     * ```\n     */\n    create(name, isPrivate = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('create request');\n            return api_1.bucketsCreate(this, name, isPrivate);\n        });\n    }\n    /**\n     * Returns the bucket root CID\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     */\n    root(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('root request');\n            return api_1.bucketsRoot(this, key);\n        });\n    }\n    /**\n     * Returns a list of bucket links.\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     * @example\n     * Generate the HTTP, IPNS, and IPFS links for a Bucket\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const getIpnsLink = async (buckets: Buckets, bucketKey: string) => {\n     *    const links = await buckets.links(bucketKey)\n     *    return links.ipns\n     * }\n     *\n     * const getWwwLink = async (buckets: Buckets, bucketKey: string) => {\n     *    const links = await buckets.links(bucketKey)\n     *    return links.www\n     * }\n     * ```\n     */\n    links(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('link request');\n            return api_1.bucketsLinks(this, key);\n        });\n    }\n    /**\n     * Returns a list of all bucket roots.\n     * @example\n     * Find an existing Bucket named \"app-name-files\"\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const exists = async (buckets: Buckets) => {\n     *     const roots = await buckets.list();\n     *     return roots.find((bucket) => bucket.name ===  \"app-name-files\")\n     * }\n     * ````\n     */\n    list() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('list request');\n            return api_1.bucketsList(this);\n        });\n    }\n    /**\n     * Returns information about a bucket path.\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     * @param path A file/object (sub)-path within a bucket.\n     * @param depth (optional) will walk the entire bucket to target depth (default = 1)\n     */\n    listPath(key, path, depth = 1) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('list path request');\n            return yield utils_1.listPathRecursive(this, key, path, depth);\n        });\n    }\n    /**\n     * listPathRecursive returns a nested object of all paths (and info) in a bucket\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     * @param path A file/object (sub)-path within a bucket.\n     * @param dirs (optional) if false will include only file paths\n     * @param depth (optional) will walk the entire bucket to target depth (default = 1)\n     *\n     * @example\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * async function printPaths(buckets: Buckets, bucketKey: string) {\n     *   const list = await buckets.listPathFlat(bucketKey, '')\n     *   console.log(list)\n     * }\n     * // [\n     * //   '.textileseed',\n     * //   'dir1',\n     * //   'dir1/file1.jpg',\n     * //   'path',\n     * //   'path/to',\n     * //   'path/to/file2.jpg'\n     * // ]\n     * ```\n     */\n    listPathFlat(key, path, dirs = true, depth = 5) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('list path recursive request');\n            return yield utils_1.listPathFlat(this, key, path, dirs, depth);\n        });\n    }\n    /**\n     * listIpfsPath returns items at a particular path in a UnixFS path living in the IPFS network.\n     * @param path UnixFS path\n     */\n    listIpfsPath(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('list path request');\n            return api_1.bucketsListIpfsPath(this, path);\n        });\n    }\n    /**\n     * Pushes a file to a bucket path.\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     * @param path A file/object (sub)-path within a bucket.\n     * @param input The input file/stream/object.\n     * @param opts Options to control response stream. Currently only supports a progress function.\n     * @remarks\n     * This will return the resolved path and the bucket's new root path.\n     * @example\n     * Push a file to the root of a bucket\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const pushFile = async (buckets: Buckets, content: string, bucketKey: string) => {\n     *    const file = { path: '/index.html', content: Buffer.from(content) }\n     *    return await buckets.pushPath(bucketKey!, 'index.html', file)\n     * }\n     * ```\n     *\n     * @example\n     * Push an folder in node.js\n     * ```typescript\n     * import fs from 'fs'\n     * import util from 'util'\n     * import glob from 'glob'\n     * import { Buckets } from '@textile/hub'\n     *\n     * const globDir = util.promisify(glob)\n     *\n     * // expects an already setup buckets session using getOrCreate or withThread\n     * const exists = async (buckets: Buckets, bucketKey: string, dir: string) => {\n     *   const files = await globDir('<dir glob options>')\n     *   return await Promise.all(files.map(async (file) => {\n     *     const filePath = dir + '/' + file\n     *     var content = fs.createReadStream(filePath, { highWaterMark: 1024 * 1024 * 3 });\n     *     const upload = {\n     *       path: file,\n     *       content\n     *     }\n     *     return await buckets.pushPath(bucketKey, file, upload)\n     *   }))\n     * }\n     * ```\n     */\n    pushPath(key, path, input, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return api_1.bucketsPushPath(this, key, path, input, opts);\n        });\n    }\n    /**\n     * Pulls the bucket path, returning the bytes of the given file.\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     * @param path A file/object (sub)-path within a bucket.\n     * @param opts Options to control response stream. Currently only supports a progress function.\n     *\n     * @example\n     * Pull a file by its relative path and console.log the progress.\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const pullFile = async (buckets: Buckets, key: string, path: string) => {\n     *    const display = (num?: number) => {\n     *      console.log('Progress:', num)\n     *    }\n     *    buckets.pullPath(key, path, {progress: display})\n     * }\n     * ```\n     */\n    pullPath(key, path, opts) {\n        return api_1.bucketsPullPath(this, key, path, opts);\n    }\n    /**\n     * Pushes a file to a bucket path.\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     * @param path A file/object (sub)-path within a bucket.\n     * @param cid The IPFS cid of the dag to set at the path.\n     *\n     * @example\n     * Push a file to the root of a bucket\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const pushRoot = async (buckets: Buckets, key: string, cid: string) => {\n     *    return await buckets.setPath(key, '/', cid)\n     * }\n     * ```\n     */\n    setPath(key, path, cid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return api_1.bucketsSetPath(this, key, path, cid);\n        });\n    }\n    /**\n     * pullIpfsPath pulls the path from a remote UnixFS dag, writing it to writer if it's a file.\n     * @param path A file/object (sub)-path within a bucket.\n     * @param opts Options to control response stream. Currently only supports a progress function.\n     *\n     * @example\n     * Pull a file by its IPFS path and console.log the progress.\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const pullFile = async (buckets: Buckets, path: string) => {\n     *    const display = (num?: number) => {\n     *      console.log('Progress:', num)\n     *    }\n     *    buckets.pullIpfsPath(path, {progress: display})\n     * }\n     * ```\n     */\n    pullIpfsPath(path, opts) {\n        return api_1.bucketsPullIpfsPath(this, path, opts);\n    }\n    /**\n     * Removes an entire bucket. Files and directories will be unpinned (cannot be undone).\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     *\n     * @example\n     * Remove a Bucket\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const remove = async (buckets: Buckets, key: string) => {\n     *    buckets.remove(key)\n     * }\n     * ```\n     */\n    remove(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('remove request');\n            return api_1.bucketsRemove(this, key);\n        });\n    }\n    /**\n     * Returns information about a bucket path (cannot be undone).\n     *\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     * @param path A relative path within a bucket.\n     * @param root optional to specify a root.\n     *\n     * @example\n     * Remove a file by its relative path\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * const remove = async (buckets: Buckets, key: string) => {\n     *    buckets.remove(key)\n     * }\n     * ```\n     */\n    removePath(key, path, root) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('remove path request');\n            return api_1.bucketsRemovePath(this, key, path, root);\n        });\n    }\n    /**\n     * (Experimental) Store a snapshot of the bucket on Filecoin.\n     * @remarks\n     * Filecoin support is experimental. By using Textile, you\n     * are acknowledging that you understand there may be risks to\n     * storing your content on or using decentralized storage\n     * services.\n     *\n     * @beta\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     *\n     * @example\n     * Remove a file by its relative path\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * async function archive (buckets: Buckets, key: string) {\n     *    buckets.archive(key)\n     * }\n     * ```\n     */\n    archive(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('archive request');\n            return api_1.bucketsArchive(this, key);\n        });\n    }\n    /**\n     * archiveStatus returns the status of a Filecoin bucket archive.\n     * @beta\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     *\n     * @example\n     * Remove a file by its relative path\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * async function status (buckets: Buckets, key: string) {\n     *    buckets.archive(key)\n     * }\n     * ```\n     */\n    archiveStatus(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('archive status request');\n            return api_1.bucketsArchiveStatus(this, key);\n        });\n    }\n    /**\n     * archiveInfo returns info about a Filecoin bucket archive.\n     * @beta\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     *\n     * @example\n     * Display the info for an existing archives of the bucket\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * async function log (buckets: Buckets, key: string) {\n     *    const info = await buckets.archiveInfo(key)\n     *    console.log(info.cid, info.deals.length)\n     * }\n     * ```\n     */\n    archiveInfo(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('archive info request');\n            return api_1.bucketsArchiveInfo(this, key);\n        });\n    }\n    /**\n     * archiveWatch watches status events from a Filecoin bucket archive.\n     * @beta\n     * @param key Unique (IPNS compatible) identifier key for a bucket.\n     *\n     * @example\n     * Watch deal state changes for a active bucket archive request.\n     * ```typescript\n     * import { Buckets } from '@textile/hub'\n     *\n     * async function logChanges (buckets: Buckets, key: string) {\n     *    const log = (reply?: {id?: string, msg: string}, err?: Error | undefined) => {\n     *        if (err || !reply) return console.log(err)\n     *        console.log(reply.id, reply.msg)\n     *    }\n     *    buckets.archiveWatch(key, log)\n     * }\n     * ```\n     */\n    archiveWatch(key, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('archive watch request');\n            return api_1.bucketsArchiveWatch(this, key, callback);\n        });\n    }\n}\nexports.Buckets = Buckets;\n//# sourceMappingURL=buckets.js.map"]},"metadata":{},"sourceType":"script"}