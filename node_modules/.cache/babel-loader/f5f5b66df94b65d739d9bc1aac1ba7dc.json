{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.marshalPrivateKey = exports.unmarshalPrivateKey = exports.marshalPublicKey = exports.unmarshalPublicKey = exports.generateKeyPair = exports.supportedKeys = exports.keyTypeError = void 0;\n\nconst ed25519 = __importStar(require(\"./ed25519\"));\n\nconst proto_keys_1 = require(\"./proto.keys\");\n/**\n * Exposes an interface to various cryptographic key generation routines.\n * Currently the 'ed25519' types are supported, although ed25519 keys\n * support only signing and verification of messages.\n */\n\n\nexports.keyTypeError = new Error(\"Unsupported key type.\");\nexports.supportedKeys = {\n  ed25519\n}; // Generates a keypair of the given type and bitsize\n\nexports.generateKeyPair = (type, bytesLength) => __awaiter(void 0, void 0, void 0, function* () {\n  if (type !== \"Ed25519\") throw exports.keyTypeError;\n  return ed25519.generateKeyPair(bytesLength);\n});\n/**\n * Converts a protobuf serialized public key into its representative object\n * @param buf The input key bytes.\n */\n\n\nexports.unmarshalPublicKey = buf => {\n  const decoded = proto_keys_1.decodePublicKey(buf);\n  const data = decoded.Data;\n\n  switch (decoded.Type) {\n    case \"Ed25519\"\n    /* Ed25519 */\n    :\n      return exports.supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n\n    case \"RSA\"\n    /* RSA */\n    :\n    case \"Secp256k1\"\n    /* Secp256k1 */\n    :\n    default:\n      throw exports.keyTypeError;\n  }\n};\n/**\n * Converts a public key object into a protobuf serialized public key\n * @param key public key.\n * @param type key type. Currently only ED25519 is supported.\n */\n\n\nexports.marshalPublicKey = (key, type = \"ED25519\") => {\n  if (type !== \"ED25519\") throw exports.keyTypeError;\n  return key.bytes;\n};\n/**\n * Converts a protobuf serialized private key into its representative object\n * @param buf The input key bytes.\n */\n\n\nexports.unmarshalPrivateKey = buf => {\n  const decoded = proto_keys_1.decodePrivateKey(buf);\n  const data = decoded.Data;\n\n  switch (decoded.Type) {\n    case \"Ed25519\"\n    /* Ed25519 */\n    :\n      return exports.supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);\n\n    case \"RSA\"\n    /* RSA */\n    :\n    case \"Secp256k1\"\n    /* Secp256k1 */\n    :\n    default:\n      throw exports.keyTypeError;\n  }\n}; // Converts a private key object into a protobuf serialized private key\n\n\nexports.marshalPrivateKey = (key, type = \"ED25519\") => {\n  if (type !== \"ED25519\") throw exports.keyTypeError;\n  return key.bytes;\n};","map":{"version":3,"sources":["../src/keys.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAEA;;;;;;;AAMa,OAAA,CAAA,YAAA,GAAe,IAAI,KAAJ,CAAU,uBAAV,CAAf;AAEA,OAAA,CAAA,aAAA,GAAgB;AAC3B,EAAA;AAD2B,CAAhB,C,CAIb;;AACa,OAAA,CAAA,eAAA,GAAkB,CAC7B,IAD6B,EAE7B,WAF6B,KAGN,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACvB,MAAI,IAAI,KAAK,SAAb,EAAwB,MAAM,OAAA,CAAA,YAAN;AACxB,SAAO,OAAO,CAAC,eAAR,CAAwB,WAAxB,CAAP;AACD,CAHwB,CAHZ;AAQb;;;;;;AAIa,OAAA,CAAA,kBAAA,GAAsB,GAAD,IAA+B;AAC/D,QAAM,OAAO,GAAG,YAAA,CAAA,eAAA,CAAgB,GAAhB,CAAhB;AACA,QAAM,IAAI,GAAG,OAAO,CAAC,IAArB;;AAEA,UAAQ,OAAO,CAAC,IAAhB;AACE,SAAA;AAAA;AAAA;AACE,aAAO,OAAA,CAAA,aAAA,CAAc,OAAd,CAAsB,yBAAtB,CAAgD,IAAhD,CAAP;;AACF,SAAA;AAAA;AAAA;AACA,SAAA;AAAA;AAAA;AACA;AACE,YAAM,OAAA,CAAA,YAAN;AANJ;AAQD,CAZY;AAcb;;;;;;;AAKa,OAAA,CAAA,gBAAA,GAAmB,CAAC,GAAD,EAAiB,IAAI,GAAG,SAAxB,KAAqC;AACnE,MAAI,IAAI,KAAK,SAAb,EAAwB,MAAM,OAAA,CAAA,YAAN;AACxB,SAAO,GAAG,CAAC,KAAX;AACD,CAHY;AAKb;;;;;;AAIa,OAAA,CAAA,mBAAA,GAAuB,GAAD,IAAyC;AAC1E,QAAM,OAAO,GAAG,YAAA,CAAA,gBAAA,CAAiB,GAAjB,CAAhB;AACA,QAAM,IAAI,GAAG,OAAO,CAAC,IAArB;;AAEA,UAAQ,OAAO,CAAC,IAAhB;AACE,SAAA;AAAA;AAAA;AACE,aAAO,OAAA,CAAA,aAAA,CAAc,OAAd,CAAsB,0BAAtB,CAAiD,IAAjD,CAAP;;AACF,SAAA;AAAA;AAAA;AACA,SAAA;AAAA;AAAA;AACA;AACE,YAAM,OAAA,CAAA,YAAN;AANJ;AAQD,CAZY,C,CAcb;;;AACa,OAAA,CAAA,iBAAA,GAAoB,CAAC,GAAD,EAAkB,IAAI,GAAG,SAAzB,KAAsC;AACrE,MAAI,IAAI,KAAK,SAAb,EAAwB,MAAM,OAAA,CAAA,YAAN;AACxB,SAAO,GAAG,CAAC,KAAX;AACD,CAHY","sourcesContent":["import * as ed25519 from \"./ed25519\"\nimport { PrivateKey, PublicKey } from \"./interfaces\"\nimport { decodePrivateKey, decodePublicKey, KeyType } from \"./proto.keys\"\n\n/**\n * Exposes an interface to various cryptographic key generation routines.\n * Currently the 'ed25519' types are supported, although ed25519 keys\n * support only signing and verification of messages.\n */\n\nexport const keyTypeError = new Error(\"Unsupported key type.\")\n\nexport const supportedKeys = {\n  ed25519,\n}\n\n// Generates a keypair of the given type and bitsize\nexport const generateKeyPair = async (\n  type: \"Ed25519\",\n  bytesLength?: number\n): Promise<PrivateKey> => {\n  if (type !== \"Ed25519\") throw keyTypeError\n  return ed25519.generateKeyPair(bytesLength)\n}\n\n/**\n * Converts a protobuf serialized public key into its representative object\n * @param buf The input key bytes.\n */\nexport const unmarshalPublicKey = (buf: Uint8Array): PublicKey => {\n  const decoded = decodePublicKey(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\n    case KeyType.RSA:\n    case KeyType.Secp256k1:\n    default:\n      throw keyTypeError\n  }\n}\n\n/**\n * Converts a public key object into a protobuf serialized public key\n * @param key public key.\n * @param type key type. Currently only ED25519 is supported.\n */\nexport const marshalPublicKey = (key: PublicKey, type = \"ED25519\") => {\n  if (type !== \"ED25519\") throw keyTypeError\n  return key.bytes\n}\n\n/**\n * Converts a protobuf serialized private key into its representative object\n * @param buf The input key bytes.\n */\nexport const unmarshalPrivateKey = (buf: Uint8Array): Promise<PrivateKey> => {\n  const decoded = decodePrivateKey(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data)\n    case KeyType.RSA:\n    case KeyType.Secp256k1:\n    default:\n      throw keyTypeError\n  }\n}\n\n// Converts a private key object into a protobuf serialized private key\nexport const marshalPrivateKey = (key: PrivateKey, type = \"ED25519\") => {\n  if (type !== \"ED25519\") throw keyTypeError\n  return key.bytes\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}