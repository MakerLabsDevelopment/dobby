{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodePrivateKey = exports.encodePrivateKey = exports.decodePublicKey = exports.encodePublicKey = exports.decodeKeyType = exports.encodeKeyType = void 0;\nexports.encodeKeyType = {\n  RSA: 0,\n  Ed25519: 1,\n  Secp256k1: 2\n};\nexports.decodeKeyType = {\n  0: \"RSA\"\n  /* RSA */\n  ,\n  1: \"Ed25519\"\n  /* Ed25519 */\n  ,\n  2: \"Secp256k1\"\n  /* Secp256k1 */\n\n};\n\nfunction encodePublicKey(message) {\n  let bb = popByteBuffer();\n\n  _encodePublicKey(message, bb);\n\n  return toUint8Array(bb);\n}\n\nexports.encodePublicKey = encodePublicKey;\n\nfunction _encodePublicKey(message, bb) {\n  // required KeyType Type = 1;\n  let $Type = message.Type;\n\n  if ($Type !== undefined) {\n    writeVarint32(bb, 8);\n    writeVarint32(bb, exports.encodeKeyType[$Type]);\n  } // required bytes Data = 2;\n\n\n  let $Data = message.Data;\n\n  if ($Data !== undefined) {\n    writeVarint32(bb, 18);\n    writeVarint32(bb, $Data.length), writeBytes(bb, $Data);\n  }\n}\n\nfunction decodePublicKey(binary) {\n  return _decodePublicKey(wrapByteBuffer(binary));\n}\n\nexports.decodePublicKey = decodePublicKey;\n\nfunction _decodePublicKey(bb) {\n  let message = {};\n\n  end_of_message: while (!isAtEnd(bb)) {\n    let tag = readVarint32(bb);\n\n    switch (tag >>> 3) {\n      case 0:\n        break end_of_message;\n      // required KeyType Type = 1;\n\n      case 1:\n        {\n          message.Type = exports.decodeKeyType[readVarint32(bb)];\n          break;\n        }\n      // required bytes Data = 2;\n\n      case 2:\n        {\n          message.Data = readBytes(bb, readVarint32(bb));\n          break;\n        }\n\n      default:\n        skipUnknownField(bb, tag & 7);\n    }\n  }\n\n  if (message.Type === undefined) throw new Error(\"Missing required field: Type\");\n  if (message.Data === undefined) throw new Error(\"Missing required field: Data\");\n  return message;\n}\n\nfunction encodePrivateKey(message) {\n  let bb = popByteBuffer();\n\n  _encodePrivateKey(message, bb);\n\n  return toUint8Array(bb);\n}\n\nexports.encodePrivateKey = encodePrivateKey;\n\nfunction _encodePrivateKey(message, bb) {\n  // required KeyType Type = 1;\n  let $Type = message.Type;\n\n  if ($Type !== undefined) {\n    writeVarint32(bb, 8);\n    writeVarint32(bb, exports.encodeKeyType[$Type]);\n  } // required bytes Data = 2;\n\n\n  let $Data = message.Data;\n\n  if ($Data !== undefined) {\n    writeVarint32(bb, 18);\n    writeVarint32(bb, $Data.length), writeBytes(bb, $Data);\n  }\n}\n\nfunction decodePrivateKey(binary) {\n  return _decodePrivateKey(wrapByteBuffer(binary));\n}\n\nexports.decodePrivateKey = decodePrivateKey;\n\nfunction _decodePrivateKey(bb) {\n  let message = {};\n\n  end_of_message: while (!isAtEnd(bb)) {\n    let tag = readVarint32(bb);\n\n    switch (tag >>> 3) {\n      case 0:\n        break end_of_message;\n      // required KeyType Type = 1;\n\n      case 1:\n        {\n          message.Type = exports.decodeKeyType[readVarint32(bb)];\n          break;\n        }\n      // required bytes Data = 2;\n\n      case 2:\n        {\n          message.Data = readBytes(bb, readVarint32(bb));\n          break;\n        }\n\n      default:\n        skipUnknownField(bb, tag & 7);\n    }\n  }\n\n  if (message.Type === undefined) throw new Error(\"Missing required field: Type\");\n  if (message.Data === undefined) throw new Error(\"Missing required field: Data\");\n  return message;\n}\n\nfunction pushTemporaryLength(bb) {\n  let length = readVarint32(bb);\n  let limit = bb.limit;\n  bb.limit = bb.offset + length;\n  return limit;\n}\n\nfunction skipUnknownField(bb, type) {\n  switch (type) {\n    case 0:\n      while (readByte(bb) & 0x80) {}\n\n      break;\n\n    case 2:\n      skip(bb, readVarint32(bb));\n      break;\n\n    case 5:\n      skip(bb, 4);\n      break;\n\n    case 1:\n      skip(bb, 8);\n      break;\n\n    default:\n      throw new Error(\"Unimplemented type: \" + type);\n  }\n}\n\nfunction stringToLong(value) {\n  return {\n    low: value.charCodeAt(0) | value.charCodeAt(1) << 16,\n    high: value.charCodeAt(2) | value.charCodeAt(3) << 16,\n    unsigned: false\n  };\n}\n\nfunction longToString(value) {\n  let low = value.low;\n  let high = value.high;\n  return String.fromCharCode(low & 0xFFFF, low >>> 16, high & 0xFFFF, high >>> 16);\n} // The code below was modified from https://github.com/protobufjs/bytebuffer.js\n// which is under the Apache License 2.0.\n\n\nlet f32 = new Float32Array(1);\nlet f32_u8 = new Uint8Array(f32.buffer);\nlet f64 = new Float64Array(1);\nlet f64_u8 = new Uint8Array(f64.buffer);\n\nfunction intToLong(value) {\n  value |= 0;\n  return {\n    low: value,\n    high: value >> 31,\n    unsigned: value >= 0\n  };\n}\n\nlet bbStack = [];\n\nfunction popByteBuffer() {\n  const bb = bbStack.pop();\n  if (!bb) return {\n    bytes: new Uint8Array(64),\n    offset: 0,\n    limit: 0\n  };\n  bb.offset = bb.limit = 0;\n  return bb;\n}\n\nfunction pushByteBuffer(bb) {\n  bbStack.push(bb);\n}\n\nfunction wrapByteBuffer(bytes) {\n  return {\n    bytes,\n    offset: 0,\n    limit: bytes.length\n  };\n}\n\nfunction toUint8Array(bb) {\n  let bytes = bb.bytes;\n  let limit = bb.limit;\n  return bytes.length === limit ? bytes : bytes.subarray(0, limit);\n}\n\nfunction skip(bb, offset) {\n  if (bb.offset + offset > bb.limit) {\n    throw new Error('Skip past limit');\n  }\n\n  bb.offset += offset;\n}\n\nfunction isAtEnd(bb) {\n  return bb.offset >= bb.limit;\n}\n\nfunction grow(bb, count) {\n  let bytes = bb.bytes;\n  let offset = bb.offset;\n  let limit = bb.limit;\n  let finalOffset = offset + count;\n\n  if (finalOffset > bytes.length) {\n    let newBytes = new Uint8Array(finalOffset * 2);\n    newBytes.set(bytes);\n    bb.bytes = newBytes;\n  }\n\n  bb.offset = finalOffset;\n\n  if (finalOffset > limit) {\n    bb.limit = finalOffset;\n  }\n\n  return offset;\n}\n\nfunction advance(bb, count) {\n  let offset = bb.offset;\n\n  if (offset + count > bb.limit) {\n    throw new Error('Read past limit');\n  }\n\n  bb.offset += count;\n  return offset;\n}\n\nfunction readBytes(bb, count) {\n  let offset = advance(bb, count);\n  return bb.bytes.subarray(offset, offset + count);\n}\n\nfunction writeBytes(bb, buffer) {\n  let offset = grow(bb, buffer.length);\n  bb.bytes.set(buffer, offset);\n}\n\nfunction readString(bb, count) {\n  // Sadly a hand-coded UTF8 decoder is much faster than subarray+TextDecoder in V8\n  let offset = advance(bb, count);\n  let fromCharCode = String.fromCharCode;\n  let bytes = bb.bytes;\n  let invalid = '\\uFFFD';\n  let text = '';\n\n  for (let i = 0; i < count; i++) {\n    let c1 = bytes[i + offset],\n        c2,\n        c3,\n        c4,\n        c; // 1 byte\n\n    if ((c1 & 0x80) === 0) {\n      text += fromCharCode(c1);\n    } // 2 bytes\n    else if ((c1 & 0xE0) === 0xC0) {\n        if (i + 1 >= count) text += invalid;else {\n          c2 = bytes[i + offset + 1];\n          if ((c2 & 0xC0) !== 0x80) text += invalid;else {\n            c = (c1 & 0x1F) << 6 | c2 & 0x3F;\n            if (c < 0x80) text += invalid;else {\n              text += fromCharCode(c);\n              i++;\n            }\n          }\n        }\n      } // 3 bytes\n      else if ((c1 & 0xF0) == 0xE0) {\n          if (i + 2 >= count) text += invalid;else {\n            c2 = bytes[i + offset + 1];\n            c3 = bytes[i + offset + 2];\n            if (((c2 | c3 << 8) & 0xC0C0) !== 0x8080) text += invalid;else {\n              c = (c1 & 0x0F) << 12 | (c2 & 0x3F) << 6 | c3 & 0x3F;\n              if (c < 0x0800 || c >= 0xD800 && c <= 0xDFFF) text += invalid;else {\n                text += fromCharCode(c);\n                i += 2;\n              }\n            }\n          }\n        } // 4 bytes\n        else if ((c1 & 0xF8) == 0xF0) {\n            if (i + 3 >= count) text += invalid;else {\n              c2 = bytes[i + offset + 1];\n              c3 = bytes[i + offset + 2];\n              c4 = bytes[i + offset + 3];\n              if (((c2 | c3 << 8 | c4 << 16) & 0xC0C0C0) !== 0x808080) text += invalid;else {\n                c = (c1 & 0x07) << 0x12 | (c2 & 0x3F) << 0x0C | (c3 & 0x3F) << 0x06 | c4 & 0x3F;\n                if (c < 0x10000 || c > 0x10FFFF) text += invalid;else {\n                  c -= 0x10000;\n                  text += fromCharCode((c >> 10) + 0xD800, (c & 0x3FF) + 0xDC00);\n                  i += 3;\n                }\n              }\n            }\n          } else text += invalid;\n  }\n\n  return text;\n}\n\nfunction writeString(bb, text) {\n  // Sadly a hand-coded UTF8 encoder is much faster than TextEncoder+set in V8\n  let n = text.length;\n  let byteCount = 0; // Write the byte count first\n\n  for (let i = 0; i < n; i++) {\n    let c = text.charCodeAt(i);\n\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\n    }\n\n    byteCount += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  writeVarint32(bb, byteCount);\n  let offset = grow(bb, byteCount);\n  let bytes = bb.bytes; // Then write the bytes\n\n  for (let i = 0; i < n; i++) {\n    let c = text.charCodeAt(i);\n\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\n    }\n\n    if (c < 0x80) {\n      bytes[offset++] = c;\n    } else {\n      if (c < 0x800) {\n        bytes[offset++] = c >> 6 & 0x1F | 0xC0;\n      } else {\n        if (c < 0x10000) {\n          bytes[offset++] = c >> 12 & 0x0F | 0xE0;\n        } else {\n          bytes[offset++] = c >> 18 & 0x07 | 0xF0;\n          bytes[offset++] = c >> 12 & 0x3F | 0x80;\n        }\n\n        bytes[offset++] = c >> 6 & 0x3F | 0x80;\n      }\n\n      bytes[offset++] = c & 0x3F | 0x80;\n    }\n  }\n}\n\nfunction writeByteBuffer(bb, buffer) {\n  let offset = grow(bb, buffer.limit);\n  let from = bb.bytes;\n  let to = buffer.bytes; // This for loop is much faster than subarray+set on V8\n\n  for (let i = 0, n = buffer.limit; i < n; i++) {\n    from[i + offset] = to[i];\n  }\n}\n\nfunction readByte(bb) {\n  return bb.bytes[advance(bb, 1)];\n}\n\nfunction writeByte(bb, value) {\n  let offset = grow(bb, 1);\n  bb.bytes[offset] = value;\n}\n\nfunction readFloat(bb) {\n  let offset = advance(bb, 4);\n  let bytes = bb.bytes; // Manual copying is much faster than subarray+set in V8\n\n  f32_u8[0] = bytes[offset++];\n  f32_u8[1] = bytes[offset++];\n  f32_u8[2] = bytes[offset++];\n  f32_u8[3] = bytes[offset++];\n  return f32[0];\n}\n\nfunction writeFloat(bb, value) {\n  let offset = grow(bb, 4);\n  let bytes = bb.bytes;\n  f32[0] = value; // Manual copying is much faster than subarray+set in V8\n\n  bytes[offset++] = f32_u8[0];\n  bytes[offset++] = f32_u8[1];\n  bytes[offset++] = f32_u8[2];\n  bytes[offset++] = f32_u8[3];\n}\n\nfunction readDouble(bb) {\n  let offset = advance(bb, 8);\n  let bytes = bb.bytes; // Manual copying is much faster than subarray+set in V8\n\n  f64_u8[0] = bytes[offset++];\n  f64_u8[1] = bytes[offset++];\n  f64_u8[2] = bytes[offset++];\n  f64_u8[3] = bytes[offset++];\n  f64_u8[4] = bytes[offset++];\n  f64_u8[5] = bytes[offset++];\n  f64_u8[6] = bytes[offset++];\n  f64_u8[7] = bytes[offset++];\n  return f64[0];\n}\n\nfunction writeDouble(bb, value) {\n  let offset = grow(bb, 8);\n  let bytes = bb.bytes;\n  f64[0] = value; // Manual copying is much faster than subarray+set in V8\n\n  bytes[offset++] = f64_u8[0];\n  bytes[offset++] = f64_u8[1];\n  bytes[offset++] = f64_u8[2];\n  bytes[offset++] = f64_u8[3];\n  bytes[offset++] = f64_u8[4];\n  bytes[offset++] = f64_u8[5];\n  bytes[offset++] = f64_u8[6];\n  bytes[offset++] = f64_u8[7];\n}\n\nfunction readInt32(bb) {\n  let offset = advance(bb, 4);\n  let bytes = bb.bytes;\n  return bytes[offset] | bytes[offset + 1] << 8 | bytes[offset + 2] << 16 | bytes[offset + 3] << 24;\n}\n\nfunction writeInt32(bb, value) {\n  let offset = grow(bb, 4);\n  let bytes = bb.bytes;\n  bytes[offset] = value;\n  bytes[offset + 1] = value >> 8;\n  bytes[offset + 2] = value >> 16;\n  bytes[offset + 3] = value >> 24;\n}\n\nfunction readInt64(bb, unsigned) {\n  return {\n    low: readInt32(bb),\n    high: readInt32(bb),\n    unsigned\n  };\n}\n\nfunction writeInt64(bb, value) {\n  writeInt32(bb, value.low);\n  writeInt32(bb, value.high);\n}\n\nfunction readVarint32(bb) {\n  let c = 0;\n  let value = 0;\n  let b;\n\n  do {\n    b = readByte(bb);\n    if (c < 32) value |= (b & 0x7F) << c;\n    c += 7;\n  } while (b & 0x80);\n\n  return value;\n}\n\nfunction writeVarint32(bb, value) {\n  value >>>= 0;\n\n  while (value >= 0x80) {\n    writeByte(bb, value & 0x7f | 0x80);\n    value >>>= 7;\n  }\n\n  writeByte(bb, value);\n}\n\nfunction readVarint64(bb, unsigned) {\n  let part0 = 0;\n  let part1 = 0;\n  let part2 = 0;\n  let b;\n  b = readByte(bb);\n  part0 = b & 0x7F;\n\n  if (b & 0x80) {\n    b = readByte(bb);\n    part0 |= (b & 0x7F) << 7;\n\n    if (b & 0x80) {\n      b = readByte(bb);\n      part0 |= (b & 0x7F) << 14;\n\n      if (b & 0x80) {\n        b = readByte(bb);\n        part0 |= (b & 0x7F) << 21;\n\n        if (b & 0x80) {\n          b = readByte(bb);\n          part1 = b & 0x7F;\n\n          if (b & 0x80) {\n            b = readByte(bb);\n            part1 |= (b & 0x7F) << 7;\n\n            if (b & 0x80) {\n              b = readByte(bb);\n              part1 |= (b & 0x7F) << 14;\n\n              if (b & 0x80) {\n                b = readByte(bb);\n                part1 |= (b & 0x7F) << 21;\n\n                if (b & 0x80) {\n                  b = readByte(bb);\n                  part2 = b & 0x7F;\n\n                  if (b & 0x80) {\n                    b = readByte(bb);\n                    part2 |= (b & 0x7F) << 7;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    low: part0 | part1 << 28,\n    high: part1 >>> 4 | part2 << 24,\n    unsigned\n  };\n}\n\nfunction writeVarint64(bb, value) {\n  let part0 = value.low >>> 0;\n  let part1 = (value.low >>> 28 | value.high << 4) >>> 0;\n  let part2 = value.high >>> 24; // ref: src/google/protobuf/io/coded_stream.cc\n\n  let size = part2 === 0 ? part1 === 0 ? part0 < 1 << 14 ? part0 < 1 << 7 ? 1 : 2 : part0 < 1 << 21 ? 3 : 4 : part1 < 1 << 14 ? part1 < 1 << 7 ? 5 : 6 : part1 < 1 << 21 ? 7 : 8 : part2 < 1 << 7 ? 9 : 10;\n  let offset = grow(bb, size);\n  let bytes = bb.bytes;\n\n  switch (size) {\n    case 10:\n      bytes[offset + 9] = part2 >>> 7 & 0x01;\n\n    case 9:\n      bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;\n\n    case 8:\n      bytes[offset + 7] = size !== 8 ? part1 >>> 21 | 0x80 : part1 >>> 21 & 0x7F;\n\n    case 7:\n      bytes[offset + 6] = size !== 7 ? part1 >>> 14 | 0x80 : part1 >>> 14 & 0x7F;\n\n    case 6:\n      bytes[offset + 5] = size !== 6 ? part1 >>> 7 | 0x80 : part1 >>> 7 & 0x7F;\n\n    case 5:\n      bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;\n\n    case 4:\n      bytes[offset + 3] = size !== 4 ? part0 >>> 21 | 0x80 : part0 >>> 21 & 0x7F;\n\n    case 3:\n      bytes[offset + 2] = size !== 3 ? part0 >>> 14 | 0x80 : part0 >>> 14 & 0x7F;\n\n    case 2:\n      bytes[offset + 1] = size !== 2 ? part0 >>> 7 | 0x80 : part0 >>> 7 & 0x7F;\n\n    case 1:\n      bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;\n  }\n}\n\nfunction readVarint32ZigZag(bb) {\n  let value = readVarint32(bb); // ref: src/google/protobuf/wire_format_lite.h\n\n  return value >>> 1 ^ -(value & 1);\n}\n\nfunction writeVarint32ZigZag(bb, value) {\n  // ref: src/google/protobuf/wire_format_lite.h\n  writeVarint32(bb, value << 1 ^ value >> 31);\n}\n\nfunction readVarint64ZigZag(bb) {\n  let value = readVarint64(bb,\n  /* unsigned */\n  false);\n  let low = value.low;\n  let high = value.high;\n  let flip = -(low & 1); // ref: src/google/protobuf/wire_format_lite.h\n\n  return {\n    low: (low >>> 1 | high << 31) ^ flip,\n    high: high >>> 1 ^ flip,\n    unsigned: false\n  };\n}\n\nfunction writeVarint64ZigZag(bb, value) {\n  let low = value.low;\n  let high = value.high;\n  let flip = high >> 31; // ref: src/google/protobuf/wire_format_lite.h\n\n  writeVarint64(bb, {\n    low: low << 1 ^ flip,\n    high: (high << 1 | low >>> 31) ^ flip,\n    unsigned: false\n  });\n}","map":{"version":3,"sources":["../src/proto.keys.ts"],"names":[],"mappings":"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","sourcesContent":["export const enum KeyType {\n  RSA = \"RSA\",\n  Ed25519 = \"Ed25519\",\n  Secp256k1 = \"Secp256k1\",\n}\n\nexport const encodeKeyType: { [key: string]: number } = {\n  RSA: 0,\n  Ed25519: 1,\n  Secp256k1: 2,\n};\n\nexport const decodeKeyType: { [key: number]: KeyType } = {\n  0: KeyType.RSA,\n  1: KeyType.Ed25519,\n  2: KeyType.Secp256k1,\n};\n\nexport interface PublicKey {\n  Type: KeyType;\n  Data: Uint8Array;\n}\n\nexport function encodePublicKey(message: PublicKey): Uint8Array {\n  let bb = popByteBuffer();\n  _encodePublicKey(message, bb);\n  return toUint8Array(bb);\n}\n\nfunction _encodePublicKey(message: PublicKey, bb: ByteBuffer): void {\n  // required KeyType Type = 1;\n  let $Type = message.Type;\n  if ($Type !== undefined) {\n    writeVarint32(bb, 8);\n    writeVarint32(bb, encodeKeyType[$Type]);\n  }\n\n  // required bytes Data = 2;\n  let $Data = message.Data;\n  if ($Data !== undefined) {\n    writeVarint32(bb, 18);\n    writeVarint32(bb, $Data.length), writeBytes(bb, $Data);\n  }\n}\n\nexport function decodePublicKey(binary: Uint8Array): PublicKey {\n  return _decodePublicKey(wrapByteBuffer(binary));\n}\n\nfunction _decodePublicKey(bb: ByteBuffer): PublicKey {\n  let message: PublicKey = {} as any;\n\n  end_of_message: while (!isAtEnd(bb)) {\n    let tag = readVarint32(bb);\n\n    switch (tag >>> 3) {\n      case 0:\n        break end_of_message;\n\n      // required KeyType Type = 1;\n      case 1: {\n        message.Type = decodeKeyType[readVarint32(bb)];\n        break;\n      }\n\n      // required bytes Data = 2;\n      case 2: {\n        message.Data = readBytes(bb, readVarint32(bb));\n        break;\n      }\n\n      default:\n        skipUnknownField(bb, tag & 7);\n    }\n  }\n\n  if (message.Type === undefined)\n    throw new Error(\"Missing required field: Type\");\n\n  if (message.Data === undefined)\n    throw new Error(\"Missing required field: Data\");\n\n  return message;\n}\n\nexport interface PrivateKey {\n  Type: KeyType;\n  Data: Uint8Array;\n}\n\nexport function encodePrivateKey(message: PrivateKey): Uint8Array {\n  let bb = popByteBuffer();\n  _encodePrivateKey(message, bb);\n  return toUint8Array(bb);\n}\n\nfunction _encodePrivateKey(message: PrivateKey, bb: ByteBuffer): void {\n  // required KeyType Type = 1;\n  let $Type = message.Type;\n  if ($Type !== undefined) {\n    writeVarint32(bb, 8);\n    writeVarint32(bb, encodeKeyType[$Type]);\n  }\n\n  // required bytes Data = 2;\n  let $Data = message.Data;\n  if ($Data !== undefined) {\n    writeVarint32(bb, 18);\n    writeVarint32(bb, $Data.length), writeBytes(bb, $Data);\n  }\n}\n\nexport function decodePrivateKey(binary: Uint8Array): PrivateKey {\n  return _decodePrivateKey(wrapByteBuffer(binary));\n}\n\nfunction _decodePrivateKey(bb: ByteBuffer): PrivateKey {\n  let message: PrivateKey = {} as any;\n\n  end_of_message: while (!isAtEnd(bb)) {\n    let tag = readVarint32(bb);\n\n    switch (tag >>> 3) {\n      case 0:\n        break end_of_message;\n\n      // required KeyType Type = 1;\n      case 1: {\n        message.Type = decodeKeyType[readVarint32(bb)];\n        break;\n      }\n\n      // required bytes Data = 2;\n      case 2: {\n        message.Data = readBytes(bb, readVarint32(bb));\n        break;\n      }\n\n      default:\n        skipUnknownField(bb, tag & 7);\n    }\n  }\n\n  if (message.Type === undefined)\n    throw new Error(\"Missing required field: Type\");\n\n  if (message.Data === undefined)\n    throw new Error(\"Missing required field: Data\");\n\n  return message;\n}\n\nexport interface Long {\n  low: number;\n  high: number;\n  unsigned: boolean;\n}\n\ninterface ByteBuffer {\n  bytes: Uint8Array;\n  offset: number;\n  limit: number;\n}\n\nfunction pushTemporaryLength(bb: ByteBuffer): number {\n  let length = readVarint32(bb);\n  let limit = bb.limit;\n  bb.limit = bb.offset + length;\n  return limit;\n}\n\nfunction skipUnknownField(bb: ByteBuffer, type: number): void {\n  switch (type) {\n    case 0: while (readByte(bb) & 0x80) { } break;\n    case 2: skip(bb, readVarint32(bb)); break;\n    case 5: skip(bb, 4); break;\n    case 1: skip(bb, 8); break;\n    default: throw new Error(\"Unimplemented type: \" + type);\n  }\n}\n\nfunction stringToLong(value: string): Long {\n  return {\n    low: value.charCodeAt(0) | (value.charCodeAt(1) << 16),\n    high: value.charCodeAt(2) | (value.charCodeAt(3) << 16),\n    unsigned: false,\n  };\n}\n\nfunction longToString(value: Long): string {\n  let low = value.low;\n  let high = value.high;\n  return String.fromCharCode(\n    low & 0xFFFF,\n    low >>> 16,\n    high & 0xFFFF,\n    high >>> 16);\n}\n\n// The code below was modified from https://github.com/protobufjs/bytebuffer.js\n// which is under the Apache License 2.0.\n\nlet f32 = new Float32Array(1);\nlet f32_u8 = new Uint8Array(f32.buffer);\n\nlet f64 = new Float64Array(1);\nlet f64_u8 = new Uint8Array(f64.buffer);\n\nfunction intToLong(value: number): Long {\n  value |= 0;\n  return {\n    low: value,\n    high: value >> 31,\n    unsigned: value >= 0,\n  };\n}\n\nlet bbStack: ByteBuffer[] = [];\n\nfunction popByteBuffer(): ByteBuffer {\n  const bb = bbStack.pop();\n  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };\n  bb.offset = bb.limit = 0;\n  return bb;\n}\n\nfunction pushByteBuffer(bb: ByteBuffer): void {\n  bbStack.push(bb);\n}\n\nfunction wrapByteBuffer(bytes: Uint8Array): ByteBuffer {\n  return { bytes, offset: 0, limit: bytes.length };\n}\n\nfunction toUint8Array(bb: ByteBuffer): Uint8Array {\n  let bytes = bb.bytes;\n  let limit = bb.limit;\n  return bytes.length === limit ? bytes : bytes.subarray(0, limit);\n}\n\nfunction skip(bb: ByteBuffer, offset: number): void {\n  if (bb.offset + offset > bb.limit) {\n    throw new Error('Skip past limit');\n  }\n  bb.offset += offset;\n}\n\nfunction isAtEnd(bb: ByteBuffer): boolean {\n  return bb.offset >= bb.limit;\n}\n\nfunction grow(bb: ByteBuffer, count: number): number {\n  let bytes = bb.bytes;\n  let offset = bb.offset;\n  let limit = bb.limit;\n  let finalOffset = offset + count;\n  if (finalOffset > bytes.length) {\n    let newBytes = new Uint8Array(finalOffset * 2);\n    newBytes.set(bytes);\n    bb.bytes = newBytes;\n  }\n  bb.offset = finalOffset;\n  if (finalOffset > limit) {\n    bb.limit = finalOffset;\n  }\n  return offset;\n}\n\nfunction advance(bb: ByteBuffer, count: number): number {\n  let offset = bb.offset;\n  if (offset + count > bb.limit) {\n    throw new Error('Read past limit');\n  }\n  bb.offset += count;\n  return offset;\n}\n\nfunction readBytes(bb: ByteBuffer, count: number): Uint8Array {\n  let offset = advance(bb, count);\n  return bb.bytes.subarray(offset, offset + count);\n}\n\nfunction writeBytes(bb: ByteBuffer, buffer: Uint8Array): void {\n  let offset = grow(bb, buffer.length);\n  bb.bytes.set(buffer, offset);\n}\n\nfunction readString(bb: ByteBuffer, count: number): string {\n  // Sadly a hand-coded UTF8 decoder is much faster than subarray+TextDecoder in V8\n  let offset = advance(bb, count);\n  let fromCharCode = String.fromCharCode;\n  let bytes = bb.bytes;\n  let invalid = '\\uFFFD';\n  let text = '';\n\n  for (let i = 0; i < count; i++) {\n    let c1 = bytes[i + offset], c2: number, c3: number, c4: number, c: number;\n\n    // 1 byte\n    if ((c1 & 0x80) === 0) {\n      text += fromCharCode(c1);\n    }\n\n    // 2 bytes\n    else if ((c1 & 0xE0) === 0xC0) {\n      if (i + 1 >= count) text += invalid;\n      else {\n        c2 = bytes[i + offset + 1];\n        if ((c2 & 0xC0) !== 0x80) text += invalid;\n        else {\n          c = ((c1 & 0x1F) << 6) | (c2 & 0x3F);\n          if (c < 0x80) text += invalid;\n          else {\n            text += fromCharCode(c);\n            i++;\n          }\n        }\n      }\n    }\n\n    // 3 bytes\n    else if ((c1 & 0xF0) == 0xE0) {\n      if (i + 2 >= count) text += invalid;\n      else {\n        c2 = bytes[i + offset + 1];\n        c3 = bytes[i + offset + 2];\n        if (((c2 | (c3 << 8)) & 0xC0C0) !== 0x8080) text += invalid;\n        else {\n          c = ((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);\n          if (c < 0x0800 || (c >= 0xD800 && c <= 0xDFFF)) text += invalid;\n          else {\n            text += fromCharCode(c);\n            i += 2;\n          }\n        }\n      }\n    }\n\n    // 4 bytes\n    else if ((c1 & 0xF8) == 0xF0) {\n      if (i + 3 >= count) text += invalid;\n      else {\n        c2 = bytes[i + offset + 1];\n        c3 = bytes[i + offset + 2];\n        c4 = bytes[i + offset + 3];\n        if (((c2 | (c3 << 8) | (c4 << 16)) & 0xC0C0C0) !== 0x808080) text += invalid;\n        else {\n          c = ((c1 & 0x07) << 0x12) | ((c2 & 0x3F) << 0x0C) | ((c3 & 0x3F) << 0x06) | (c4 & 0x3F);\n          if (c < 0x10000 || c > 0x10FFFF) text += invalid;\n          else {\n            c -= 0x10000;\n            text += fromCharCode((c >> 10) + 0xD800, (c & 0x3FF) + 0xDC00);\n            i += 3;\n          }\n        }\n      }\n    }\n\n    else text += invalid;\n  }\n\n  return text;\n}\n\nfunction writeString(bb: ByteBuffer, text: string): void {\n  // Sadly a hand-coded UTF8 encoder is much faster than TextEncoder+set in V8\n  let n = text.length;\n  let byteCount = 0;\n\n  // Write the byte count first\n  for (let i = 0; i < n; i++) {\n    let c = text.charCodeAt(i);\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\n    }\n    byteCount += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n  writeVarint32(bb, byteCount);\n\n  let offset = grow(bb, byteCount);\n  let bytes = bb.bytes;\n\n  // Then write the bytes\n  for (let i = 0; i < n; i++) {\n    let c = text.charCodeAt(i);\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\n    }\n    if (c < 0x80) {\n      bytes[offset++] = c;\n    } else {\n      if (c < 0x800) {\n        bytes[offset++] = ((c >> 6) & 0x1F) | 0xC0;\n      } else {\n        if (c < 0x10000) {\n          bytes[offset++] = ((c >> 12) & 0x0F) | 0xE0;\n        } else {\n          bytes[offset++] = ((c >> 18) & 0x07) | 0xF0;\n          bytes[offset++] = ((c >> 12) & 0x3F) | 0x80;\n        }\n        bytes[offset++] = ((c >> 6) & 0x3F) | 0x80;\n      }\n      bytes[offset++] = (c & 0x3F) | 0x80;\n    }\n  }\n}\n\nfunction writeByteBuffer(bb: ByteBuffer, buffer: ByteBuffer): void {\n  let offset = grow(bb, buffer.limit);\n  let from = bb.bytes;\n  let to = buffer.bytes;\n\n  // This for loop is much faster than subarray+set on V8\n  for (let i = 0, n = buffer.limit; i < n; i++) {\n    from[i + offset] = to[i];\n  }\n}\n\nfunction readByte(bb: ByteBuffer): number {\n  return bb.bytes[advance(bb, 1)];\n}\n\nfunction writeByte(bb: ByteBuffer, value: number): void {\n  let offset = grow(bb, 1);\n  bb.bytes[offset] = value;\n}\n\nfunction readFloat(bb: ByteBuffer): number {\n  let offset = advance(bb, 4);\n  let bytes = bb.bytes;\n\n  // Manual copying is much faster than subarray+set in V8\n  f32_u8[0] = bytes[offset++];\n  f32_u8[1] = bytes[offset++];\n  f32_u8[2] = bytes[offset++];\n  f32_u8[3] = bytes[offset++];\n  return f32[0];\n}\n\nfunction writeFloat(bb: ByteBuffer, value: number): void {\n  let offset = grow(bb, 4);\n  let bytes = bb.bytes;\n  f32[0] = value;\n\n  // Manual copying is much faster than subarray+set in V8\n  bytes[offset++] = f32_u8[0];\n  bytes[offset++] = f32_u8[1];\n  bytes[offset++] = f32_u8[2];\n  bytes[offset++] = f32_u8[3];\n}\n\nfunction readDouble(bb: ByteBuffer): number {\n  let offset = advance(bb, 8);\n  let bytes = bb.bytes;\n\n  // Manual copying is much faster than subarray+set in V8\n  f64_u8[0] = bytes[offset++];\n  f64_u8[1] = bytes[offset++];\n  f64_u8[2] = bytes[offset++];\n  f64_u8[3] = bytes[offset++];\n  f64_u8[4] = bytes[offset++];\n  f64_u8[5] = bytes[offset++];\n  f64_u8[6] = bytes[offset++];\n  f64_u8[7] = bytes[offset++];\n  return f64[0];\n}\n\nfunction writeDouble(bb: ByteBuffer, value: number): void {\n  let offset = grow(bb, 8);\n  let bytes = bb.bytes;\n  f64[0] = value;\n\n  // Manual copying is much faster than subarray+set in V8\n  bytes[offset++] = f64_u8[0];\n  bytes[offset++] = f64_u8[1];\n  bytes[offset++] = f64_u8[2];\n  bytes[offset++] = f64_u8[3];\n  bytes[offset++] = f64_u8[4];\n  bytes[offset++] = f64_u8[5];\n  bytes[offset++] = f64_u8[6];\n  bytes[offset++] = f64_u8[7];\n}\n\nfunction readInt32(bb: ByteBuffer): number {\n  let offset = advance(bb, 4);\n  let bytes = bb.bytes;\n  return (\n    bytes[offset] |\n    (bytes[offset + 1] << 8) |\n    (bytes[offset + 2] << 16) |\n    (bytes[offset + 3] << 24)\n  );\n}\n\nfunction writeInt32(bb: ByteBuffer, value: number): void {\n  let offset = grow(bb, 4);\n  let bytes = bb.bytes;\n  bytes[offset] = value;\n  bytes[offset + 1] = value >> 8;\n  bytes[offset + 2] = value >> 16;\n  bytes[offset + 3] = value >> 24;\n}\n\nfunction readInt64(bb: ByteBuffer, unsigned: boolean): Long {\n  return {\n    low: readInt32(bb),\n    high: readInt32(bb),\n    unsigned,\n  };\n}\n\nfunction writeInt64(bb: ByteBuffer, value: Long): void {\n  writeInt32(bb, value.low);\n  writeInt32(bb, value.high);\n}\n\nfunction readVarint32(bb: ByteBuffer): number {\n  let c = 0;\n  let value = 0;\n  let b: number;\n  do {\n    b = readByte(bb);\n    if (c < 32) value |= (b & 0x7F) << c;\n    c += 7;\n  } while (b & 0x80);\n  return value;\n}\n\nfunction writeVarint32(bb: ByteBuffer, value: number): void {\n  value >>>= 0;\n  while (value >= 0x80) {\n    writeByte(bb, (value & 0x7f) | 0x80);\n    value >>>= 7;\n  }\n  writeByte(bb, value);\n}\n\nfunction readVarint64(bb: ByteBuffer, unsigned: boolean): Long {\n  let part0 = 0;\n  let part1 = 0;\n  let part2 = 0;\n  let b: number;\n\n  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {\n    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {\n      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {\n        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {\n\n          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {\n            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {\n              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {\n                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {\n\n                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {\n                    b = readByte(bb); part2 |= (b & 0x7F) << 7;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    low: part0 | (part1 << 28),\n    high: (part1 >>> 4) | (part2 << 24),\n    unsigned,\n  };\n}\n\nfunction writeVarint64(bb: ByteBuffer, value: Long): void {\n  let part0 = value.low >>> 0;\n  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;\n  let part2 = value.high >>> 24;\n\n  // ref: src/google/protobuf/io/coded_stream.cc\n  let size =\n    part2 === 0 ?\n      part1 === 0 ?\n        part0 < 1 << 14 ?\n          part0 < 1 << 7 ? 1 : 2 :\n          part0 < 1 << 21 ? 3 : 4 :\n        part1 < 1 << 14 ?\n          part1 < 1 << 7 ? 5 : 6 :\n          part1 < 1 << 21 ? 7 : 8 :\n      part2 < 1 << 7 ? 9 : 10;\n\n  let offset = grow(bb, size);\n  let bytes = bb.bytes;\n\n  switch (size) {\n    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;\n    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;\n    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;\n    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;\n    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;\n    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;\n    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;\n    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;\n    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;\n    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;\n  }\n}\n\nfunction readVarint32ZigZag(bb: ByteBuffer): number {\n  let value = readVarint32(bb);\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  return (value >>> 1) ^ -(value & 1);\n}\n\nfunction writeVarint32ZigZag(bb: ByteBuffer, value: number): void {\n  // ref: src/google/protobuf/wire_format_lite.h\n  writeVarint32(bb, (value << 1) ^ (value >> 31));\n}\n\nfunction readVarint64ZigZag(bb: ByteBuffer): Long {\n  let value = readVarint64(bb, /* unsigned */ false);\n  let low = value.low;\n  let high = value.high;\n  let flip = -(low & 1);\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  return {\n    low: ((low >>> 1) | (high << 31)) ^ flip,\n    high: (high >>> 1) ^ flip,\n    unsigned: false,\n  };\n}\n\nfunction writeVarint64ZigZag(bb: ByteBuffer, value: Long): void {\n  let low = value.low;\n  let high = value.high;\n  let flip = high >> 31;\n\n  // ref: src/google/protobuf/wire_format_lite.h\n  writeVarint64(bb, {\n    low: (low << 1) ^ flip,\n    high: ((high << 1) | (low >>> 31)) ^ flip,\n    unsigned: false,\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}