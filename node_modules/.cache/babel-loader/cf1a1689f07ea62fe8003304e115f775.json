{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateKeyPair = exports.unmarshalEd25519PublicKey = exports.unmarshalEd25519PrivateKey = exports.Ed25519PrivateKey = exports.Ed25519PublicKey = exports.constants = void 0;\n\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\n\nconst multibase_1 = __importDefault(require(\"multibase\"));\n\nconst proto_keys_1 = require(\"./proto.keys\");\n\nconst utils_1 = require(\"./utils\"); // import * as ed from 'noble-ed25519'\n\n\nconst ed = libp2p_crypto_1.keys.supportedKeys.ed25519;\nexports.constants = {\n  PUBLIC_KEY_BYTE_LENGTH: 32,\n  PRIVATE_KEY_BYTE_LENGTH: 32,\n  SEED_BYTE_LENGTH: 32,\n  SIGN_BYTE_LENGTH: 64,\n  HASH_BYTE_LENGTH: 64\n};\n\nclass Ed25519PublicKey {\n  constructor(publicKey) {\n    this.publicKey = publicKey;\n    this.publicKey = utils_1.ensureKey(publicKey, exports.constants.PUBLIC_KEY_BYTE_LENGTH);\n  }\n\n  verify(data, sig) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // return ed.verify(sig, data, this.publicKey)\n      const key = new ed.Ed25519PublicKey(this.buffer);\n      return key.verify(Buffer.from(data), Buffer.from(sig));\n    });\n  }\n\n  marshal() {\n    return new Uint8Array(this.publicKey);\n  }\n\n  get buffer() {\n    return Buffer.from(this.publicKey);\n  }\n\n  get bytes() {\n    return proto_keys_1.encodePublicKey({\n      Type: \"Ed25519\"\n      /* Ed25519 */\n      ,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    const bytes = key.bytes;\n    return this.bytes.every((value, index) => value === bytes[index]);\n  }\n\n  hash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return utils_1.sha256Multihash(this.bytes);\n    });\n  }\n\n}\n\nexports.Ed25519PublicKey = Ed25519PublicKey;\n\nclass Ed25519PrivateKey {\n  /**\n   * Construct a Ed25519 private key.\n   * @param key 64 byte Uint8Array or Buffer containing private key\n   * @param publicKey 32 byte Uint8Array or Buffer containing public key\n   */\n  constructor(privateKey, publicKey) {\n    this.privateKey = privateKey;\n    this.publicKey = publicKey;\n    this.privateKey = utils_1.ensureKey(privateKey, exports.constants.PRIVATE_KEY_BYTE_LENGTH);\n    this.publicKey = utils_1.ensureKey(publicKey, exports.constants.PUBLIC_KEY_BYTE_LENGTH);\n  }\n\n  sign(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // return ed.sign(message, this.privateKey)\n      const privateKey = Buffer.concat([this.privateKeyBuffer, this.publicKeyBuffer]);\n      const key = new ed.Ed25519PrivateKey(privateKey, this.publicKeyBuffer);\n      return key.sign(Buffer.from(message));\n    });\n  }\n\n  get public() {\n    return new Ed25519PublicKey(this.publicKey);\n  }\n\n  marshal() {\n    // ED25519 private keys are represented by two 32-bytes curve points (private and public\n    // components)\n    const full = new Uint8Array(this.privateKey.byteLength + this.publicKey.byteLength * 2);\n    full.set(this.privateKey);\n    full.set(this.publicKey, this.privateKey.byteLength); // @note To match the output of libp2p-crypto, we also append redundant public key bytes\n\n    full.set(this.publicKey, this.privateKey.byteLength + this.publicKey.byteLength);\n    return full;\n  }\n\n  get publicKeyBuffer() {\n    return Buffer.from(this.publicKey);\n  }\n\n  get privateKeyBuffer() {\n    return Buffer.from(this.privateKey);\n  }\n\n  get bytes() {\n    return proto_keys_1.encodePrivateKey({\n      Type: \"Ed25519\"\n      /* Ed25519 */\n      ,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    const bytes = key.bytes;\n    return this.bytes.every((value, index) => value === bytes[index]);\n  }\n\n  hash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return utils_1.sha256Multihash(this.bytes);\n    });\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   */\n\n\n  id() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const hash = yield this.public.hash();\n      return multibase_1.default.encode(\"base58btc\", hash).toString().slice(1);\n    });\n  }\n\n}\n\nexports.Ed25519PrivateKey = Ed25519PrivateKey;\n\nfunction unmarshalEd25519PrivateKey(bytes) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // We might have the public key bytes appended twice, but we can ignore the extra public\n    // bytes on the end (no need to check it either)\n    const privateKeyBytes = bytes.slice(0, exports.constants.PRIVATE_KEY_BYTE_LENGTH);\n    const publicKeyBytes = bytes.slice(exports.constants.PRIVATE_KEY_BYTE_LENGTH, exports.constants.PRIVATE_KEY_BYTE_LENGTH + exports.constants.PUBLIC_KEY_BYTE_LENGTH);\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n  });\n}\n\nexports.unmarshalEd25519PrivateKey = unmarshalEd25519PrivateKey;\n\nfunction unmarshalEd25519PublicKey(bytes) {\n  return new Ed25519PublicKey(bytes);\n}\n\nexports.unmarshalEd25519PublicKey = unmarshalEd25519PublicKey;\n\nfunction generateKeyPair( // eslint-disable-next-line @typescript-eslint/no-unused-vars\nbytesLength = exports.constants.PRIVATE_KEY_BYTE_LENGTH) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // const privateKey = ed.utils.randomPrivateKey(bytesLength)\n    // const publicKey = await ed.getPublicKey(privateKey)\n    const key = yield ed.generateKeyPair();\n    const bytes = key.marshal();\n    const privateKey = bytes.slice(0, exports.constants.PRIVATE_KEY_BYTE_LENGTH);\n    const publicKey = bytes.slice(exports.constants.PRIVATE_KEY_BYTE_LENGTH, exports.constants.PRIVATE_KEY_BYTE_LENGTH + exports.constants.PUBLIC_KEY_BYTE_LENGTH);\n    return new Ed25519PrivateKey(privateKey, publicKey);\n  });\n}\n\nexports.generateKeyPair = generateKeyPair;","map":{"version":3,"sources":["../src/ed25519.ts"],"names":[],"mappings":"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","sourcesContent":["import { keys } from \"libp2p-crypto\"\nimport multibase from \"multibase\"\nimport { PrivateKey, PublicKey } from \"./interfaces\"\nimport { encodePrivateKey, encodePublicKey, KeyType } from \"./proto.keys\"\nimport { ensureKey, sha256Multihash } from \"./utils\"\n\n// import * as ed from 'noble-ed25519'\nconst ed = keys.supportedKeys.ed25519\n\nexport const constants = {\n  PUBLIC_KEY_BYTE_LENGTH: 32,\n  PRIVATE_KEY_BYTE_LENGTH: 32,\n  SEED_BYTE_LENGTH: 32,\n  SIGN_BYTE_LENGTH: 64,\n  HASH_BYTE_LENGTH: 64,\n}\n\nexport class Ed25519PublicKey implements PublicKey {\n  constructor(private publicKey: Uint8Array) {\n    this.publicKey = ensureKey(publicKey, constants.PUBLIC_KEY_BYTE_LENGTH)\n  }\n\n  async verify(data: Uint8Array, sig: Uint8Array): Promise<boolean> {\n    // return ed.verify(sig, data, this.publicKey)\n    const key = new ed.Ed25519PublicKey(this.buffer)\n    return key.verify(Buffer.from(data), Buffer.from(sig))\n  }\n\n  marshal(): Uint8Array {\n    return new Uint8Array(this.publicKey)\n  }\n\n  get buffer(): Buffer {\n    return Buffer.from(this.publicKey)\n  }\n\n  get bytes(): Uint8Array {\n    return encodePublicKey({\n      Type: KeyType.Ed25519,\n      Data: this.marshal(),\n    })\n  }\n\n  equals(key: PublicKey): boolean {\n    const bytes = key.bytes\n    return this.bytes.every((value, index) => value === bytes[index])\n  }\n\n  async hash(): Promise<Uint8Array> {\n    return sha256Multihash(this.bytes)\n  }\n}\n\nexport class Ed25519PrivateKey implements PrivateKey {\n  /**\n   * Construct a Ed25519 private key.\n   * @param key 64 byte Uint8Array or Buffer containing private key\n   * @param publicKey 32 byte Uint8Array or Buffer containing public key\n   */\n  constructor(private privateKey: Uint8Array, private publicKey: Uint8Array) {\n    this.privateKey = ensureKey(privateKey, constants.PRIVATE_KEY_BYTE_LENGTH)\n    this.publicKey = ensureKey(publicKey, constants.PUBLIC_KEY_BYTE_LENGTH)\n  }\n\n  async sign(message: Uint8Array): Promise<Buffer> {\n    // return ed.sign(message, this.privateKey)\n    const privateKey = Buffer.concat([\n      this.privateKeyBuffer,\n      this.publicKeyBuffer,\n    ])\n    const key = new ed.Ed25519PrivateKey(privateKey, this.publicKeyBuffer)\n    return key.sign(Buffer.from(message))\n  }\n\n  get public(): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.publicKey)\n  }\n\n  marshal(): Uint8Array {\n    // ED25519 private keys are represented by two 32-bytes curve points (private and public\n    // components)\n    const full = new Uint8Array(\n      this.privateKey.byteLength + this.publicKey.byteLength * 2\n    )\n    full.set(this.privateKey)\n    full.set(this.publicKey, this.privateKey.byteLength)\n    // @note To match the output of libp2p-crypto, we also append redundant public key bytes\n    full.set(\n      this.publicKey,\n      this.privateKey.byteLength + this.publicKey.byteLength\n    )\n    return full\n  }\n\n  get publicKeyBuffer(): Buffer {\n    return Buffer.from(this.publicKey)\n  }\n\n  get privateKeyBuffer(): Buffer {\n    return Buffer.from(this.privateKey)\n  }\n\n  get bytes(): Uint8Array {\n    return encodePrivateKey({\n      Type: KeyType.Ed25519,\n      Data: this.marshal(),\n    })\n  }\n\n  equals(key: PrivateKey): boolean {\n    const bytes = key.bytes\n    return this.bytes.every((value, index) => value === bytes[index])\n  }\n\n  async hash(): Promise<Uint8Array> {\n    return sha256Multihash(this.bytes)\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   */\n  async id(): Promise<string> {\n    const hash = await this.public.hash()\n    return multibase\n      .encode(\"base58btc\", hash as Buffer)\n      .toString()\n      .slice(1)\n  }\n}\n\nexport async function unmarshalEd25519PrivateKey(\n  bytes: Uint8Array\n): Promise<Ed25519PrivateKey> {\n  // We might have the public key bytes appended twice, but we can ignore the extra public\n  // bytes on the end (no need to check it either)\n  const privateKeyBytes = bytes.slice(0, constants.PRIVATE_KEY_BYTE_LENGTH)\n  const publicKeyBytes = bytes.slice(\n    constants.PRIVATE_KEY_BYTE_LENGTH,\n    constants.PRIVATE_KEY_BYTE_LENGTH + constants.PUBLIC_KEY_BYTE_LENGTH\n  )\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nexport function unmarshalEd25519PublicKey(bytes: Uint8Array): Ed25519PublicKey {\n  return new Ed25519PublicKey(bytes)\n}\n\nexport async function generateKeyPair(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  bytesLength = constants.PRIVATE_KEY_BYTE_LENGTH\n): Promise<Ed25519PrivateKey> {\n  // const privateKey = ed.utils.randomPrivateKey(bytesLength)\n  // const publicKey = await ed.getPublicKey(privateKey)\n  const key = await ed.generateKeyPair()\n  const bytes = key.marshal()\n  const privateKey = bytes.slice(0, constants.PRIVATE_KEY_BYTE_LENGTH)\n  const publicKey = bytes.slice(\n    constants.PRIVATE_KEY_BYTE_LENGTH,\n    constants.PRIVATE_KEY_BYTE_LENGTH + constants.PUBLIC_KEY_BYTE_LENGTH\n  )\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}