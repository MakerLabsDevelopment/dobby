{"ast":null,"code":"\"use strict\";\n\nvar __await = this && this.__await || function (v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\n\nvar __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nvar __asyncDelegator = this && this.__asyncDelegator || function (o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normaliseInput = void 0;\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\nconst buffer_1 = require(\"buffer\");\n/**\n * Transform types\n *\n * @remarks\n * This function comes from {@link https://github.com/ipfs/js-ipfs-utils/blob/master/src/files/normalise-input.js}\n * @example\n * Supported types\n * ```yaml\n * // INPUT TYPES\n * Bytes (Buffer|ArrayBuffer|TypedArray) [single file]\n * Bloby (Blob|File) [single file]\n * String [single file]\n * { path, content: Bytes } [single file]\n * { path, content: Bloby } [single file]\n * { path, content: String } [single file]\n * { path, content: Iterable<Number> } [single file]\n * { path, content: Iterable<Bytes> } [single file]\n * { path, content: AsyncIterable<Bytes> } [single file]\n * Iterable<Number> [single file]\n * Iterable<Bytes> [single file]\n * Iterable<Bloby> [multiple files]\n * Iterable<String> [multiple files]\n * Iterable<{ path, content: Bytes }> [multiple files]\n * Iterable<{ path, content: Bloby }> [multiple files]\n * Iterable<{ path, content: String }> [multiple files]\n * Iterable<{ path, content: Iterable<Number> }> [multiple files]\n * Iterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * AsyncIterable<Bytes> [single file]\n * AsyncIterable<Bloby> [multiple files]\n * AsyncIterable<String> [multiple files]\n * AsyncIterable<{ path, content: Bytes }> [multiple files]\n * AsyncIterable<{ path, content: Bloby }> [multiple files]\n * AsyncIterable<{ path, content: String }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Number> }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n *\n * // OUTPUT\n * AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n * ```\n *\n * @public\n *\n * @param {Object} input\n * @return AsyncInterable<{ path, content: AsyncIterable<Buffer> }>\n */\n\n\nfunction normaliseInput(input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw new Error(`Unexpected input: ${input}`);\n  } // String\n\n\n  if (typeof input === 'string' || input instanceof String) {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        // eslint-disable-line require-await\n        yield yield __await(toFileObject(input));\n      });\n    }();\n  } // Buffer|ArrayBuffer|TypedArray\n  // Blob|File\n\n\n  if (isBytes(input) || isBloby(input)) {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        // eslint-disable-line require-await\n        yield yield __await(toFileObject(input));\n      });\n    }();\n  } // Iterable<?>\n\n\n  if (input[Symbol.iterator]) {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        // eslint-disable-line require-await\n        const iterator = input[Symbol.iterator]();\n        const first = iterator.next();\n        if (first.done) return yield __await(iterator // Iterable<Number>\n        // Iterable<Bytes>\n        ); // Iterable<Number>\n        // Iterable<Bytes>\n\n        if (Number.isInteger(first.value) || isBytes(first.value)) {\n          yield yield __await(toFileObject(function* () {\n            yield first.value;\n            yield* iterator;\n          }()));\n          return yield __await(void 0);\n        } // Iterable<Bloby>\n        // Iterable<String>\n        // Iterable<{ path, content }>\n\n\n        if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n          yield yield __await(toFileObject(first.value));\n\n          for (const obj of iterator) {\n            yield yield __await(toFileObject(obj));\n          }\n\n          return yield __await(void 0);\n        }\n\n        throw new Error('Unexpected input: ' + typeof input);\n      });\n    }();\n  } // window.ReadableStream\n\n\n  if (typeof input.getReader === 'function') {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        var e_1, _a;\n\n        try {\n          for (var _b = __asyncValues(browserStreamToIt(input)), _c; _c = yield __await(_b.next()), !_c.done;) {\n            const obj = _c.value;\n            yield yield __await(toFileObject(obj));\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      });\n    }();\n  } // AsyncIterable<?>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        var e_2, _a;\n\n        const iterator = input[Symbol.asyncIterator]();\n        const first = yield __await(iterator.next());\n        if (first.done) return yield __await(iterator // AsyncIterable<Bytes>\n        ); // AsyncIterable<Bytes>\n\n        if (isBytes(first.value)) {\n          yield yield __await(toFileObject(function () {\n            return __asyncGenerator(this, arguments, function* () {\n              // eslint-disable-line require-await\n              yield yield __await(first.value);\n              yield __await(yield* __asyncDelegator(__asyncValues(iterator)));\n            });\n          }()));\n          return yield __await(void 0);\n        } // AsyncIterable<Bloby>\n        // AsyncIterable<String>\n        // AsyncIterable<{ path, content }>\n\n\n        if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n          yield yield __await(toFileObject(first.value));\n\n          try {\n            for (var iterator_1 = __asyncValues(iterator), iterator_1_1; iterator_1_1 = yield __await(iterator_1.next()), !iterator_1_1.done;) {\n              const obj = iterator_1_1.value;\n              yield yield __await(toFileObject(obj));\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (iterator_1_1 && !iterator_1_1.done && (_a = iterator_1.return)) yield __await(_a.call(iterator_1));\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n\n          return yield __await(void 0);\n        }\n\n        throw new Error('Unexpected input: ' + typeof input);\n      });\n    }();\n  } // { path, content: ? }\n  // Note: Detected _after_ AsyncIterable<?> because Node.js streams have a\n  // `path` property that passes this check.\n\n\n  if (isFileObject(input)) {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        // eslint-disable-line require-await\n        yield yield __await(toFileObject(input));\n      });\n    }();\n  }\n\n  throw new Error('Unexpected input: ' + typeof input);\n}\n\nexports.normaliseInput = normaliseInput;\n\nfunction toFileObject(input) {\n  const obj = {\n    path: input.path || '',\n    mode: input.mode,\n    mtime: input.mtime\n  };\n\n  if (input.content) {\n    obj.content = toAsyncIterable(input.content);\n  } else if (!input.path) {\n    // Not already a file object with path or content prop\n    obj.content = toAsyncIterable(input);\n  }\n\n  return obj;\n}\n\nfunction toAsyncIterable(input) {\n  // Bytes | String\n  if (isBytes(input) || typeof input === 'string') {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        // eslint-disable-line require-await\n        yield yield __await(toBuffer(input));\n      });\n    }();\n  } // Bloby\n\n\n  if (isBloby(input)) {\n    return blobToAsyncGenerator(input);\n  } // Browser stream\n\n\n  if (typeof input.getReader === 'function') {\n    return browserStreamToIt(input);\n  } // Iterator<?>\n\n\n  if (input[Symbol.iterator]) {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        // eslint-disable-line require-await\n        const iterator = input[Symbol.iterator]();\n        const first = iterator.next();\n        if (first.done) return yield __await(iterator // Iterable<Number>\n        ); // Iterable<Number>\n\n        if (Number.isInteger(first.value)) {\n          yield yield __await(toBuffer(Array.from(function* () {\n            yield first.value;\n            yield* iterator;\n          }())));\n          return yield __await(void 0);\n        } // Iterable<Bytes>\n\n\n        if (isBytes(first.value)) {\n          yield yield __await(toBuffer(first.value));\n\n          for (const chunk of iterator) {\n            yield yield __await(toBuffer(chunk));\n          }\n\n          return yield __await(void 0);\n        }\n\n        throw new Error('Unexpected input: ' + typeof input);\n      });\n    }();\n  } // AsyncIterable<Bytes>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return function () {\n      return __asyncGenerator(this, arguments, function* () {\n        var e_3, _a;\n\n        try {\n          for (var input_1 = __asyncValues(input), input_1_1; input_1_1 = yield __await(input_1.next()), !input_1_1.done;) {\n            const chunk = input_1_1.value;\n            yield yield __await(toBuffer(chunk));\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) yield __await(_a.call(input_1));\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      });\n    }();\n  }\n\n  throw new Error(`Unexpected input: ${input}`);\n}\n\nfunction toBuffer(chunk) {\n  return isBytes(chunk) ? chunk : buffer_1.Buffer.from(chunk);\n}\n\nfunction isBytes(obj) {\n  return buffer_1.Buffer.isBuffer(obj) || ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\n\nfunction isBloby(obj) {\n  return typeof globalThis.Blob !== 'undefined' && obj instanceof globalThis.Blob;\n} // An object with a path or content property\n\n\nfunction isFileObject(obj) {\n  return typeof obj === 'object' && (obj.path || obj.content);\n}\n\nfunction blobToAsyncGenerator(blob) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n  // @ts-ignore\n  if (typeof blob.stream === 'function') {\n    // firefox < 69 does not support blob.stream()\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    return browserStreamToIt(blob.stream());\n  }\n\n  return readBlob(blob);\n}\n\nfunction browserStreamToIt(stream) {\n  return __asyncGenerator(this, arguments, function* browserStreamToIt_1() {\n    const reader = stream.getReader();\n\n    while (true) {\n      const result = yield __await(reader.read());\n\n      if (result.done) {\n        return yield __await(void 0);\n      }\n\n      yield yield __await(result.value);\n    }\n  });\n}\n\nfunction readBlob(blob, options) {\n  return __asyncGenerator(this, arguments, function* readBlob_1() {\n    options = options || {};\n    const reader = new globalThis.FileReader();\n    const chunkSize = options.chunkSize || 1024 * 1024;\n    let offset = options.offset || 0;\n\n    const getNextChunk = () => new Promise((resolve, reject) => {\n      reader.onloadend = e => {\n        var _a;\n\n        const data = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n        resolve(data.byteLength === 0 ? null : data);\n      };\n\n      reader.onerror = reject;\n      const end = offset + chunkSize;\n      const slice = blob.slice(offset, end);\n      reader.readAsArrayBuffer(slice);\n      offset = end;\n    });\n\n    while (true) {\n      const data = yield __await(getNextChunk());\n\n      if (data == null) {\n        return yield __await(void 0);\n      }\n\n      yield yield __await(buffer_1.Buffer.from(data));\n    }\n  });\n}","map":{"version":3,"sources":["../../src/api/normalize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normaliseInput = void 0;\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst buffer_1 = require(\"buffer\");\n/**\n * Transform types\n *\n * @remarks\n * This function comes from {@link https://github.com/ipfs/js-ipfs-utils/blob/master/src/files/normalise-input.js}\n * @example\n * Supported types\n * ```yaml\n * // INPUT TYPES\n * Bytes (Buffer|ArrayBuffer|TypedArray) [single file]\n * Bloby (Blob|File) [single file]\n * String [single file]\n * { path, content: Bytes } [single file]\n * { path, content: Bloby } [single file]\n * { path, content: String } [single file]\n * { path, content: Iterable<Number> } [single file]\n * { path, content: Iterable<Bytes> } [single file]\n * { path, content: AsyncIterable<Bytes> } [single file]\n * Iterable<Number> [single file]\n * Iterable<Bytes> [single file]\n * Iterable<Bloby> [multiple files]\n * Iterable<String> [multiple files]\n * Iterable<{ path, content: Bytes }> [multiple files]\n * Iterable<{ path, content: Bloby }> [multiple files]\n * Iterable<{ path, content: String }> [multiple files]\n * Iterable<{ path, content: Iterable<Number> }> [multiple files]\n * Iterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * AsyncIterable<Bytes> [single file]\n * AsyncIterable<Bloby> [multiple files]\n * AsyncIterable<String> [multiple files]\n * AsyncIterable<{ path, content: Bytes }> [multiple files]\n * AsyncIterable<{ path, content: Bloby }> [multiple files]\n * AsyncIterable<{ path, content: String }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Number> }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n *\n * // OUTPUT\n * AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n * ```\n *\n * @public\n *\n * @param {Object} input\n * @return AsyncInterable<{ path, content: AsyncIterable<Buffer> }>\n */\nfunction normaliseInput(input) {\n    // must give us something\n    if (input === null || input === undefined) {\n        throw new Error(`Unexpected input: ${input}`);\n    }\n    // String\n    if (typeof input === 'string' || input instanceof String) {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                // eslint-disable-line require-await\n                yield yield __await(toFileObject(input));\n            });\n        })();\n    }\n    // Buffer|ArrayBuffer|TypedArray\n    // Blob|File\n    if (isBytes(input) || isBloby(input)) {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                // eslint-disable-line require-await\n                yield yield __await(toFileObject(input));\n            });\n        })();\n    }\n    // Iterable<?>\n    if (input[Symbol.iterator]) {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                // eslint-disable-line require-await\n                const iterator = input[Symbol.iterator]();\n                const first = iterator.next();\n                if (first.done)\n                    return yield __await(iterator\n                    // Iterable<Number>\n                    // Iterable<Bytes>\n                    );\n                // Iterable<Number>\n                // Iterable<Bytes>\n                if (Number.isInteger(first.value) || isBytes(first.value)) {\n                    yield yield __await(toFileObject((function* () {\n                        yield first.value;\n                        yield* iterator;\n                    })()));\n                    return yield __await(void 0);\n                }\n                // Iterable<Bloby>\n                // Iterable<String>\n                // Iterable<{ path, content }>\n                if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n                    yield yield __await(toFileObject(first.value));\n                    for (const obj of iterator) {\n                        yield yield __await(toFileObject(obj));\n                    }\n                    return yield __await(void 0);\n                }\n                throw new Error('Unexpected input: ' + typeof input);\n            });\n        })();\n    }\n    // window.ReadableStream\n    if (typeof input.getReader === 'function') {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                var e_1, _a;\n                try {\n                    for (var _b = __asyncValues(browserStreamToIt(input)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                        const obj = _c.value;\n                        yield yield __await(toFileObject(obj));\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            });\n        })();\n    }\n    // AsyncIterable<?>\n    if (input[Symbol.asyncIterator]) {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                var e_2, _a;\n                const iterator = input[Symbol.asyncIterator]();\n                const first = yield __await(iterator.next());\n                if (first.done)\n                    return yield __await(iterator\n                    // AsyncIterable<Bytes>\n                    );\n                // AsyncIterable<Bytes>\n                if (isBytes(first.value)) {\n                    yield yield __await(toFileObject((function () {\n                        return __asyncGenerator(this, arguments, function* () {\n                            // eslint-disable-line require-await\n                            yield yield __await(first.value);\n                            yield __await(yield* __asyncDelegator(__asyncValues(iterator)));\n                        });\n                    })()));\n                    return yield __await(void 0);\n                }\n                // AsyncIterable<Bloby>\n                // AsyncIterable<String>\n                // AsyncIterable<{ path, content }>\n                if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n                    yield yield __await(toFileObject(first.value));\n                    try {\n                        for (var iterator_1 = __asyncValues(iterator), iterator_1_1; iterator_1_1 = yield __await(iterator_1.next()), !iterator_1_1.done;) {\n                            const obj = iterator_1_1.value;\n                            yield yield __await(toFileObject(obj));\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (iterator_1_1 && !iterator_1_1.done && (_a = iterator_1.return)) yield __await(_a.call(iterator_1));\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                    return yield __await(void 0);\n                }\n                throw new Error('Unexpected input: ' + typeof input);\n            });\n        })();\n    }\n    // { path, content: ? }\n    // Note: Detected _after_ AsyncIterable<?> because Node.js streams have a\n    // `path` property that passes this check.\n    if (isFileObject(input)) {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                // eslint-disable-line require-await\n                yield yield __await(toFileObject(input));\n            });\n        })();\n    }\n    throw new Error('Unexpected input: ' + typeof input);\n}\nexports.normaliseInput = normaliseInput;\nfunction toFileObject(input) {\n    const obj = {\n        path: input.path || '',\n        mode: input.mode,\n        mtime: input.mtime,\n    };\n    if (input.content) {\n        obj.content = toAsyncIterable(input.content);\n    }\n    else if (!input.path) {\n        // Not already a file object with path or content prop\n        obj.content = toAsyncIterable(input);\n    }\n    return obj;\n}\nfunction toAsyncIterable(input) {\n    // Bytes | String\n    if (isBytes(input) || typeof input === 'string') {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                // eslint-disable-line require-await\n                yield yield __await(toBuffer(input));\n            });\n        })();\n    }\n    // Bloby\n    if (isBloby(input)) {\n        return blobToAsyncGenerator(input);\n    }\n    // Browser stream\n    if (typeof input.getReader === 'function') {\n        return browserStreamToIt(input);\n    }\n    // Iterator<?>\n    if (input[Symbol.iterator]) {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                // eslint-disable-line require-await\n                const iterator = input[Symbol.iterator]();\n                const first = iterator.next();\n                if (first.done)\n                    return yield __await(iterator\n                    // Iterable<Number>\n                    );\n                // Iterable<Number>\n                if (Number.isInteger(first.value)) {\n                    yield yield __await(toBuffer(Array.from((function* () {\n                        yield first.value;\n                        yield* iterator;\n                    })())));\n                    return yield __await(void 0);\n                }\n                // Iterable<Bytes>\n                if (isBytes(first.value)) {\n                    yield yield __await(toBuffer(first.value));\n                    for (const chunk of iterator) {\n                        yield yield __await(toBuffer(chunk));\n                    }\n                    return yield __await(void 0);\n                }\n                throw new Error('Unexpected input: ' + typeof input);\n            });\n        })();\n    }\n    // AsyncIterable<Bytes>\n    if (input[Symbol.asyncIterator]) {\n        return (function () {\n            return __asyncGenerator(this, arguments, function* () {\n                var e_3, _a;\n                try {\n                    for (var input_1 = __asyncValues(input), input_1_1; input_1_1 = yield __await(input_1.next()), !input_1_1.done;) {\n                        const chunk = input_1_1.value;\n                        yield yield __await(toBuffer(chunk));\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (input_1_1 && !input_1_1.done && (_a = input_1.return)) yield __await(_a.call(input_1));\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n            });\n        })();\n    }\n    throw new Error(`Unexpected input: ${input}`);\n}\nfunction toBuffer(chunk) {\n    return isBytes(chunk) ? chunk : buffer_1.Buffer.from(chunk);\n}\nfunction isBytes(obj) {\n    return buffer_1.Buffer.isBuffer(obj) || ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\nfunction isBloby(obj) {\n    return typeof globalThis.Blob !== 'undefined' && obj instanceof globalThis.Blob;\n}\n// An object with a path or content property\nfunction isFileObject(obj) {\n    return typeof obj === 'object' && (obj.path || obj.content);\n}\nfunction blobToAsyncGenerator(blob) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    if (typeof blob.stream === 'function') {\n        // firefox < 69 does not support blob.stream()\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        return browserStreamToIt(blob.stream());\n    }\n    return readBlob(blob);\n}\nfunction browserStreamToIt(stream) {\n    return __asyncGenerator(this, arguments, function* browserStreamToIt_1() {\n        const reader = stream.getReader();\n        while (true) {\n            const result = yield __await(reader.read());\n            if (result.done) {\n                return yield __await(void 0);\n            }\n            yield yield __await(result.value);\n        }\n    });\n}\nfunction readBlob(blob, options) {\n    return __asyncGenerator(this, arguments, function* readBlob_1() {\n        options = options || {};\n        const reader = new globalThis.FileReader();\n        const chunkSize = options.chunkSize || 1024 * 1024;\n        let offset = options.offset || 0;\n        const getNextChunk = () => new Promise((resolve, reject) => {\n            reader.onloadend = (e) => {\n                var _a;\n                const data = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n                resolve(data.byteLength === 0 ? null : data);\n            };\n            reader.onerror = reject;\n            const end = offset + chunkSize;\n            const slice = blob.slice(offset, end);\n            reader.readAsArrayBuffer(slice);\n            offset = end;\n        });\n        while (true) {\n            const data = yield __await(getNextChunk());\n            if (data == null) {\n                return yield __await(void 0);\n            }\n            yield yield __await(buffer_1.Buffer.from(data));\n        }\n    });\n}\n//# sourceMappingURL=normalize.js.map"]},"metadata":{},"sourceType":"script"}