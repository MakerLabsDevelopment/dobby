{"version":3,"file":"keys.js","sourceRoot":"","sources":["../src/keys.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mDAAoC;AAEpC,6CAAyE;AAEzE;;;;GAIG;AAEU,QAAA,YAAY,GAAG,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAA;AAEjD,QAAA,aAAa,GAAG;IAC3B,OAAO;CACR,CAAA;AAED,oDAAoD;AACvC,QAAA,eAAe,GAAG,CAC7B,IAAe,EACf,WAAoB,EACC,EAAE;IACvB,IAAI,IAAI,KAAK,SAAS;QAAE,MAAM,oBAAY,CAAA;IAC1C,OAAO,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,CAAA;AAC7C,CAAC,CAAA,CAAA;AAED;;;GAGG;AACU,QAAA,kBAAkB,GAAG,CAAC,GAAe,EAAa,EAAE;IAC/D,MAAM,OAAO,GAAG,4BAAe,CAAC,GAAG,CAAC,CAAA;IACpC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAA;IAEzB,QAAQ,OAAO,CAAC,IAAI,EAAE;QACpB;YACE,OAAO,qBAAa,CAAC,OAAO,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAA;QAC9D,qBAAiB;QACjB,iCAAuB;QACvB;YACE,MAAM,oBAAY,CAAA;KACrB;AACH,CAAC,CAAA;AAED;;;;GAIG;AACU,QAAA,gBAAgB,GAAG,CAAC,GAAc,EAAE,IAAI,GAAG,SAAS,EAAE,EAAE;IACnE,IAAI,IAAI,KAAK,SAAS;QAAE,MAAM,oBAAY,CAAA;IAC1C,OAAO,GAAG,CAAC,KAAK,CAAA;AAClB,CAAC,CAAA;AAED;;;GAGG;AACU,QAAA,mBAAmB,GAAG,CAAC,GAAe,EAAuB,EAAE;IAC1E,MAAM,OAAO,GAAG,6BAAgB,CAAC,GAAG,CAAC,CAAA;IACrC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAA;IAEzB,QAAQ,OAAO,CAAC,IAAI,EAAE;QACpB;YACE,OAAO,qBAAa,CAAC,OAAO,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAA;QAC/D,qBAAiB;QACjB,iCAAuB;QACvB;YACE,MAAM,oBAAY,CAAA;KACrB;AACH,CAAC,CAAA;AAED,uEAAuE;AAC1D,QAAA,iBAAiB,GAAG,CAAC,GAAe,EAAE,IAAI,GAAG,SAAS,EAAE,EAAE;IACrE,IAAI,IAAI,KAAK,SAAS;QAAE,MAAM,oBAAY,CAAA;IAC1C,OAAO,GAAG,CAAC,KAAK,CAAA;AAClB,CAAC,CAAA","sourcesContent":["import * as ed25519 from \"./ed25519\"\nimport { PrivateKey, PublicKey } from \"./interfaces\"\nimport { decodePrivateKey, decodePublicKey, KeyType } from \"./proto.keys\"\n\n/**\n * Exposes an interface to various cryptographic key generation routines.\n * Currently the 'ed25519' types are supported, although ed25519 keys\n * support only signing and verification of messages.\n */\n\nexport const keyTypeError = new Error(\"Unsupported key type.\")\n\nexport const supportedKeys = {\n  ed25519,\n}\n\n// Generates a keypair of the given type and bitsize\nexport const generateKeyPair = async (\n  type: \"Ed25519\",\n  bytesLength?: number\n): Promise<PrivateKey> => {\n  if (type !== \"Ed25519\") throw keyTypeError\n  return ed25519.generateKeyPair(bytesLength)\n}\n\n/**\n * Converts a protobuf serialized public key into its representative object\n * @param buf The input key bytes.\n */\nexport const unmarshalPublicKey = (buf: Uint8Array): PublicKey => {\n  const decoded = decodePublicKey(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\n    case KeyType.RSA:\n    case KeyType.Secp256k1:\n    default:\n      throw keyTypeError\n  }\n}\n\n/**\n * Converts a public key object into a protobuf serialized public key\n * @param key public key.\n * @param type key type. Currently only ED25519 is supported.\n */\nexport const marshalPublicKey = (key: PublicKey, type = \"ED25519\") => {\n  if (type !== \"ED25519\") throw keyTypeError\n  return key.bytes\n}\n\n/**\n * Converts a protobuf serialized private key into its representative object\n * @param buf The input key bytes.\n */\nexport const unmarshalPrivateKey = (buf: Uint8Array): Promise<PrivateKey> => {\n  const decoded = decodePrivateKey(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data)\n    case KeyType.RSA:\n    case KeyType.Secp256k1:\n    default:\n      throw keyTypeError\n  }\n}\n\n// Converts a private key object into a protobuf serialized private key\nexport const marshalPrivateKey = (key: PrivateKey, type = \"ED25519\") => {\n  if (type !== \"ED25519\") throw keyTypeError\n  return key.bytes\n}\n"]}