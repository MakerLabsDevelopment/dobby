"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateKeyPair = exports.unmarshalEd25519PublicKey = exports.unmarshalEd25519PrivateKey = exports.Ed25519PrivateKey = exports.Ed25519PublicKey = exports.constants = void 0;
const libp2p_crypto_1 = require("libp2p-crypto");
const multibase_1 = __importDefault(require("multibase"));
const proto_keys_1 = require("./proto.keys");
const utils_1 = require("./utils");
// import * as ed from 'noble-ed25519'
const ed = libp2p_crypto_1.keys.supportedKeys.ed25519;
exports.constants = {
    PUBLIC_KEY_BYTE_LENGTH: 32,
    PRIVATE_KEY_BYTE_LENGTH: 32,
    SEED_BYTE_LENGTH: 32,
    SIGN_BYTE_LENGTH: 64,
    HASH_BYTE_LENGTH: 64,
};
class Ed25519PublicKey {
    constructor(publicKey) {
        this.publicKey = publicKey;
        this.publicKey = utils_1.ensureKey(publicKey, exports.constants.PUBLIC_KEY_BYTE_LENGTH);
    }
    verify(data, sig) {
        return __awaiter(this, void 0, void 0, function* () {
            // return ed.verify(sig, data, this.publicKey)
            const key = new ed.Ed25519PublicKey(this.buffer);
            return key.verify(Buffer.from(data), Buffer.from(sig));
        });
    }
    marshal() {
        return new Uint8Array(this.publicKey);
    }
    get buffer() {
        return Buffer.from(this.publicKey);
    }
    get bytes() {
        return proto_keys_1.encodePublicKey({
            Type: "Ed25519" /* Ed25519 */,
            Data: this.marshal(),
        });
    }
    equals(key) {
        const bytes = key.bytes;
        return this.bytes.every((value, index) => value === bytes[index]);
    }
    hash() {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.sha256Multihash(this.bytes);
        });
    }
}
exports.Ed25519PublicKey = Ed25519PublicKey;
class Ed25519PrivateKey {
    /**
     * Construct a Ed25519 private key.
     * @param key 64 byte Uint8Array or Buffer containing private key
     * @param publicKey 32 byte Uint8Array or Buffer containing public key
     */
    constructor(privateKey, publicKey) {
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        this.privateKey = utils_1.ensureKey(privateKey, exports.constants.PRIVATE_KEY_BYTE_LENGTH);
        this.publicKey = utils_1.ensureKey(publicKey, exports.constants.PUBLIC_KEY_BYTE_LENGTH);
    }
    sign(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // return ed.sign(message, this.privateKey)
            const privateKey = Buffer.concat([
                this.privateKeyBuffer,
                this.publicKeyBuffer,
            ]);
            const key = new ed.Ed25519PrivateKey(privateKey, this.publicKeyBuffer);
            return key.sign(Buffer.from(message));
        });
    }
    get public() {
        return new Ed25519PublicKey(this.publicKey);
    }
    marshal() {
        // ED25519 private keys are represented by two 32-bytes curve points (private and public
        // components)
        const full = new Uint8Array(this.privateKey.byteLength + this.publicKey.byteLength * 2);
        full.set(this.privateKey);
        full.set(this.publicKey, this.privateKey.byteLength);
        // @note To match the output of libp2p-crypto, we also append redundant public key bytes
        full.set(this.publicKey, this.privateKey.byteLength + this.publicKey.byteLength);
        return full;
    }
    get publicKeyBuffer() {
        return Buffer.from(this.publicKey);
    }
    get privateKeyBuffer() {
        return Buffer.from(this.privateKey);
    }
    get bytes() {
        return proto_keys_1.encodePrivateKey({
            Type: "Ed25519" /* Ed25519 */,
            Data: this.marshal(),
        });
    }
    equals(key) {
        const bytes = key.bytes;
        return this.bytes.every((value, index) => value === bytes[index]);
    }
    hash() {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.sha256Multihash(this.bytes);
        });
    }
    /**
     * Gets the ID of the key.
     *
     * The key id is the base58 encoding of the SHA-256 multihash of its public key.
     * The public key is a protobuf encoding containing a type and the DER encoding
     * of the PKCS SubjectPublicKeyInfo.
     */
    id() {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = yield this.public.hash();
            return multibase_1.default
                .encode("base58btc", hash)
                .toString()
                .slice(1);
        });
    }
}
exports.Ed25519PrivateKey = Ed25519PrivateKey;
function unmarshalEd25519PrivateKey(bytes) {
    return __awaiter(this, void 0, void 0, function* () {
        // We might have the public key bytes appended twice, but we can ignore the extra public
        // bytes on the end (no need to check it either)
        const privateKeyBytes = bytes.slice(0, exports.constants.PRIVATE_KEY_BYTE_LENGTH);
        const publicKeyBytes = bytes.slice(exports.constants.PRIVATE_KEY_BYTE_LENGTH, exports.constants.PRIVATE_KEY_BYTE_LENGTH + exports.constants.PUBLIC_KEY_BYTE_LENGTH);
        return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
    });
}
exports.unmarshalEd25519PrivateKey = unmarshalEd25519PrivateKey;
function unmarshalEd25519PublicKey(bytes) {
    return new Ed25519PublicKey(bytes);
}
exports.unmarshalEd25519PublicKey = unmarshalEd25519PublicKey;
function generateKeyPair(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
bytesLength = exports.constants.PRIVATE_KEY_BYTE_LENGTH) {
    return __awaiter(this, void 0, void 0, function* () {
        // const privateKey = ed.utils.randomPrivateKey(bytesLength)
        // const publicKey = await ed.getPublicKey(privateKey)
        const key = yield ed.generateKeyPair();
        const bytes = key.marshal();
        const privateKey = bytes.slice(0, exports.constants.PRIVATE_KEY_BYTE_LENGTH);
        const publicKey = bytes.slice(exports.constants.PRIVATE_KEY_BYTE_LENGTH, exports.constants.PRIVATE_KEY_BYTE_LENGTH + exports.constants.PUBLIC_KEY_BYTE_LENGTH);
        return new Ed25519PrivateKey(privateKey, publicKey);
    });
}
exports.generateKeyPair = generateKeyPair;
//# sourceMappingURL=ed25519.js.map