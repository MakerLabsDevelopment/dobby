{"version":3,"file":"log.js","sourceRoot":"","sources":["../../src/thread/log.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Multiaddr } from \"@textile/multiaddr\"\nimport { keys, multihash, PrivateKey, PublicKey } from \"@textile/threads-crypto\"\nimport CID from \"cids\"\nimport multibase from \"multibase\"\n\nfunction areEqual(a: Uint8Array, b: Uint8Array) {\n  if (a.byteLength !== b.byteLength) return false\n  return a.every((val, i) => val === b[i])\n}\n\nconst computeDigest = (pubKey: PublicKey) => {\n  if (pubKey.bytes.length <= 42) {\n    return multihash(pubKey.bytes, 0x00)\n  } else {\n    return pubKey.hash()\n  }\n}\n\nconst computeLogId = async (privKey?: PrivateKey, pubKey?: PublicKey) => {\n  const key = pubKey ?? privKey?.public\n  if (key === undefined) throw new Error(\"Valid public or private key required\")\n  const digest = await computeDigest(key)\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return new LogID(digest, privKey, pubKey)\n}\n\n/**\n * LogID represents a simplified PeerID used for tracking thread logs.\n * It is a minimal implementation of PeerID useful mostly for marshaling and unmarshaling.\n */\nexport class LogID {\n  constructor(\n    readonly id: Uint8Array,\n    readonly privKey?: PrivateKey,\n    readonly pubKey: PublicKey | undefined = privKey?.public\n  ) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error(\"invalid id provided\")\n    }\n    if (privKey && pubKey && !areEqual(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error(\"inconsistent arguments\")\n    }\n  }\n\n  static async fromRandom(bytesLength?: number): Promise<LogID> {\n    const key = await keys.generateKeyPair(\"Ed25519\", bytesLength)\n    return computeLogId(key)\n  }\n\n  static fromBytes(buf: Uint8Array): LogID {\n    return new LogID(buf)\n  }\n\n  static fromB58String(str: string): LogID {\n    const cid = new CID(str)\n    // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n    if (!(cid.codec === \"libp2p-key\" || cid.codec === \"dag-pb\")) {\n      throw new Error(\"Invalid multicodec\")\n    }\n    return new LogID(cid.multihash)\n  }\n\n  static fromPublicKey(key: PublicKey | Uint8Array): Promise<LogID> {\n    if (key instanceof Uint8Array) {\n      return computeLogId(undefined, keys.unmarshalPublicKey(key))\n    }\n    return computeLogId(undefined, key)\n  }\n\n  static async fromPrivateKey(key: PrivateKey | Uint8Array): Promise<LogID> {\n    if (key instanceof Uint8Array) {\n      return computeLogId(await keys.unmarshalPrivateKey(key))\n    }\n    return computeLogId(key)\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey(): Uint8Array | undefined {\n    if (this.pubKey) {\n      return keys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey(): Uint8Array | undefined {\n    if (this.privKey) {\n      return keys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  toBytes(): Uint8Array {\n    return this.id\n  }\n\n  toB58String(): string {\n    return multibase\n      .encode(\"base58btc\", Buffer.from(this.id))\n      .toString()\n      .slice(1)\n  }\n\n  // Return self-describing String representation\n  toString(): string {\n    const cid = new CID(1, \"libp2p-key\", Buffer.from(this.id), \"base32\")\n    return cid.toBaseEncodedString(\"base32\")\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given LogID.\n   */\n  equals(id: Uint8Array | LogID): boolean {\n    if (id instanceof Uint8Array) {\n      return areEqual(this.id, id)\n    } else if (id.id) {\n      return areEqual(this.id, id.id)\n    } else {\n      throw new Error(\"not valid Id\")\n    }\n  }\n\n  /*\n   * Check if this LogID instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid(): boolean {\n    return Boolean(\n      this.privKey &&\n        this.privKey.public &&\n        this.privKey.public.bytes &&\n        this.pubKey?.bytes instanceof Uint8Array &&\n        areEqual(this.privKey.public.bytes, this.pubKey.bytes)\n    )\n  }\n}\n\nexport const PeerId = {\n  BytesToString: (buf: Uint8Array): string => new LogID(buf).toB58String(),\n}\n\n/**\n * LogInfo holds known info about a log.\n */\nexport interface LogInfo {\n  /**\n   * The logs ID.\n   */\n  id: LogID\n  /**\n   * The logs public key used to check signatures.\n   */\n  pubKey?: PublicKey\n  /**\n   * The logs private key, used to sign content when available.\n   */\n  privKey?: PrivateKey\n  /**\n   * The set of Multiaddrs associated with this log.\n   */\n  addrs?: Set<Multiaddr>\n  /**\n   * The set of heads for this log.\n   */\n  head?: CID\n}\n"]}