"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerId = exports.LogID = void 0;
const threads_crypto_1 = require("@textile/threads-crypto");
const cids_1 = __importDefault(require("cids"));
const multibase_1 = __importDefault(require("multibase"));
function areEqual(a, b) {
    if (a.byteLength !== b.byteLength)
        return false;
    return a.every((val, i) => val === b[i]);
}
const computeDigest = (pubKey) => {
    if (pubKey.bytes.length <= 42) {
        return threads_crypto_1.multihash(pubKey.bytes, 0x00);
    }
    else {
        return pubKey.hash();
    }
};
const computeLogId = (privKey, pubKey) => __awaiter(void 0, void 0, void 0, function* () {
    const key = pubKey !== null && pubKey !== void 0 ? pubKey : privKey === null || privKey === void 0 ? void 0 : privKey.public;
    if (key === undefined)
        throw new Error("Valid public or private key required");
    const digest = yield computeDigest(key);
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new LogID(digest, privKey, pubKey);
});
/**
 * LogID represents a simplified PeerID used for tracking thread logs.
 * It is a minimal implementation of PeerID useful mostly for marshaling and unmarshaling.
 */
class LogID {
    constructor(id, privKey, pubKey = privKey === null || privKey === void 0 ? void 0 : privKey.public) {
        this.id = id;
        this.privKey = privKey;
        this.pubKey = pubKey;
        if (!(id instanceof Uint8Array)) {
            throw new Error("invalid id provided");
        }
        if (privKey && pubKey && !areEqual(privKey.public.bytes, pubKey.bytes)) {
            throw new Error("inconsistent arguments");
        }
    }
    static fromRandom(bytesLength) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield threads_crypto_1.keys.generateKeyPair("Ed25519", bytesLength);
            return computeLogId(key);
        });
    }
    static fromBytes(buf) {
        return new LogID(buf);
    }
    static fromB58String(str) {
        const cid = new cids_1.default(str);
        // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)
        if (!(cid.codec === "libp2p-key" || cid.codec === "dag-pb")) {
            throw new Error("Invalid multicodec");
        }
        return new LogID(cid.multihash);
    }
    static fromPublicKey(key) {
        if (key instanceof Uint8Array) {
            return computeLogId(undefined, threads_crypto_1.keys.unmarshalPublicKey(key));
        }
        return computeLogId(undefined, key);
    }
    static fromPrivateKey(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (key instanceof Uint8Array) {
                return computeLogId(yield threads_crypto_1.keys.unmarshalPrivateKey(key));
            }
            return computeLogId(key);
        });
    }
    // Return the protobuf version of the public key, matching go ipfs formatting
    marshalPubKey() {
        if (this.pubKey) {
            return threads_crypto_1.keys.marshalPublicKey(this.pubKey);
        }
    }
    // Return the protobuf version of the private key, matching go ipfs formatting
    marshalPrivKey() {
        if (this.privKey) {
            return threads_crypto_1.keys.marshalPrivateKey(this.privKey);
        }
    }
    toBytes() {
        return this.id;
    }
    toB58String() {
        return multibase_1.default
            .encode("base58btc", Buffer.from(this.id))
            .toString()
            .slice(1);
    }
    // Return self-describing String representation
    toString() {
        const cid = new cids_1.default(1, "libp2p-key", Buffer.from(this.id), "base32");
        return cid.toBaseEncodedString("base32");
    }
    /**
     * Checks the equality of `this` peer against a given LogID.
     */
    equals(id) {
        if (id instanceof Uint8Array) {
            return areEqual(this.id, id);
        }
        else if (id.id) {
            return areEqual(this.id, id.id);
        }
        else {
            throw new Error("not valid Id");
        }
    }
    /*
     * Check if this LogID instance is valid (privKey -> pubKey -> Id)
     */
    isValid() {
        var _a;
        return Boolean(this.privKey &&
            this.privKey.public &&
            this.privKey.public.bytes &&
            ((_a = this.pubKey) === null || _a === void 0 ? void 0 : _a.bytes) instanceof Uint8Array &&
            areEqual(this.privKey.public.bytes, this.pubKey.bytes));
    }
}
exports.LogID = LogID;
exports.PeerId = {
    BytesToString: (buf) => new LogID(buf).toB58String(),
};
//# sourceMappingURL=log.js.map