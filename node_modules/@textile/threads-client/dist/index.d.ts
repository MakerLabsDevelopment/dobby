/**
 * @packageDocumentation
 * @module @textile/threads-client
 */
import { grpc } from "@improbable-eng/grpc-web";
import { ContextInterface } from "@textile/context";
import { KeyInfo, UserAuth } from "@textile/security";
import * as pb from "@textile/threads-client-grpc/threads_pb";
import { Identity, Libp2pCryptoIdentity } from "@textile/threads-core";
import { ThreadID } from "@textile/threads-id";
import { CriterionJSON, Filter, Instance, InstanceList, Query, QueryJSON, ReadTransaction, SortJSON, ValueJSON, Where, WriteTransaction } from "./models";
export { Filter, Query, Where, WriteTransaction, ReadTransaction, Instance, InstanceList, QueryJSON, ValueJSON, CriterionJSON, SortJSON, };
export interface CollectionInfo {
    name: string;
    schema: any;
    indexesList: Array<pb.Index.AsObject>;
}
export interface CollectionConfig {
    name: string;
    schema: any;
    indexes: pb.Index.AsObject;
}
export declare function maybeLocalAddr(ip: string): boolean | RegExpMatchArray;
export declare enum Action {
    CREATE = 0,
    SAVE = 1,
    DELETE = 2
}
export interface Update<T = any> extends Instance<T> {
    collectionName: string;
    instanceID: string;
    action: Action;
}
/**
 * DBInfo contains joining/sharing information for a Thread/DB.
 */
export interface DBInfo {
    /**
     * The Thread Key, encoded as a base32 string.
     * @see ThreadKey for details.
     */
    key: string;
    /**
     * The Multiaddrs for a peer hosting the given Thread/DB.
     */
    addrs: string[];
}
/**
 * Client is a web-gRPC wrapper client for communicating with a webgRPC-enabled Threads server.
 * This client library can be used to interact with a local or remote Textile gRPC-service
 * It is a wrapper around Textile Thread's 'DB' API, which is defined here:
 * https://github.com/textileio/go-threads/blob/master/api/pb/api.proto.
 *
 * @example
 * ```typescript
 * import {Client, Identity, UserAuth} from '@textile/threads'
 *
 * async function setupDB(auth: UserAuth, identity: Identity) {
 *   // Initialize the client
 *   const client = Client.withUserAuth(auth)
 *
 *   // Connect the user to your API
 *   const userToken = await client.getToken(identity)
 *
 *   // Create a new DB
 *   const threadID = await client.newDB(undefined, 'nasa')
 *
 *   // Create a new Collection from an Object
 *   const buzz = {
 *     name: 'Buzz',
 *     missions: 2,
 *     _id: '',
 *   }
 *   await client.newCollectionFromObject(threadID, 'astronauts', buzz)
 *
 *   // Store the buzz object in the new collection
 *   await client.create(threadID, 'astronauts', [buzz])
 *
 *   return threadID
 * }
 * ```
 */
export declare class Client {
    context: ContextInterface;
    serviceHost: string;
    rpcOptions: grpc.RpcOptions;
    /**
     * Creates a new gRPC client instance for accessing the Textile Threads API.
     * @param context The context to use for interacting with the APIs. Can be modified later.
     * @param debug Should we run in debug mode. Defaults to false.
     */
    constructor(context?: ContextInterface, debug?: boolean);
    /**
     * Create a new gRPC client instance from a supplied user auth object.
     * Assumes all default gRPC settlings. For customization options, use a context object directly.
     * The callback method will automatically refresh expiring credentials.
     * @param auth The user auth object or an async callback that returns a user auth object.
     * @example
     * ```typescript
     * import {UserAuth, Client} from '@textile/threads'
     *
     * function create (auth: UserAuth) {
     *   return Client.withUserAuth(auth)
     * }
     * ```
     * @example
     * ```typescript
     * import {UserAuth, Client} from '@textile/threads'
     *
     * function setCallback (callback: () => Promise<UserAuth>) {
     *   return Client.withUserAuth(callback)
     * }
     * ```
     */
    static withUserAuth(auth: UserAuth | (() => Promise<UserAuth>), host?: string, debug?: boolean): Client;
    /**
     * Create a new gRPC client instance from a supplied key and secret
     * @param key The KeyInfo object containing {key: string, secret: string, type: 0}. 0 === User Group Key, 1 === Account Key
     * @param host The remote gRPC host to connect with. Should be left as default.
     * @param debug Whether to run in debug mode. Defaults to false.
     * @example
     * ```typescript
     * import {KeyInfo, Client} from '@textile/threads'
     *
     * async function create (keyInfo: KeyInfo) {
     *   return await Client.withKeyInfo(keyInfo)
     * }
     * ```
     */
    static withKeyInfo(key: KeyInfo, host?: string, debug?: boolean): Promise<Client>;
    /**
     * Create a random user identity.
     * @deprecated
     * @remarks
     * See `PrivateKey`
     */
    static randomIdentity(): Promise<Libp2pCryptoIdentity>;
    /**
     * Obtain a token per user (identity) for interacting with the remote API.
     * @param identity A user identity to use for creating records in the database. A random identity
     * can be created with `Client.randomIdentity(), however, it is not easy/possible to migrate
     * identities after the fact. Please store or otherwise persist any identity information if
     * you wish to retrieve user data later, or use an external identity provider.
     * @param ctx Context object containing web-gRPC headers and settings.
     * @example
     * ```typescript
     * import {Client, Identity} from '@textile/threads'
     *
     * async function newToken (client: Client, user: Identity) {
     *   // Token is added to the client connection at the same time
     *   const token = await client.getToken(user)
     *   return token
     * }
     * ```
     */
    getToken(identity: Identity, ctx?: ContextInterface): Promise<string>;
    /**
     * Obtain a token per user (identity) for interacting with the remote API.
     * @param publicKey The public key of a user identity to use for creating records in the database.
     * A random identity can be created with `Client.randomIdentity(), however, it is not
     * easy/possible to migrate identities after the fact. Please store or otherwise persist any
     * identity information if you wish to retrieve user data later, or use an external identity
     * provider.
     * @param callback A callback function that takes a `challenge` argument and returns a signed
     * message using the input challenge and the private key associated with `publicKey`.
     * @param ctx Context object containing web-gRPC headers and settings.
     * @remarks `publicKey` must be the corresponding public key of the private key used in `callback`.
     */
    getTokenChallenge(publicKey: string, callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>, ctx?: ContextInterface): Promise<string>;
    /**
     * newDB creates a new store on the remote node.
     * @param threadID the ID of the database
     * @param name The human-readable name for the database
     * @example
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * async function createDB (client: Client) {
     *   const threadID: ThreadID = await client.newDB()
     *   return threadID
     * }
     * ```
     */
    newDB(threadID?: ThreadID, name?: string): Promise<ThreadID>;
    /**
     * open creates and enters a new store on the remote node.
     * @param threadID the ID of the database
     * @param name The human-readable name for the database
     * @example
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * async function openDB (client: Client, threadID: ThreadID) {
     *   await client.open(threadID)
     * }
     * ```
     */
    open(threadID: ThreadID, name?: string): Promise<void>;
    /**
     * Deletes an entire DB.
     * @param threadID the ID of the database.
     * @example
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * async function deleteDB (client: Client, threadID: ThreadID) {
     *   await client.deleteDB(threadID)
     *   return
     * }
     * ```
     */
    deleteDB(threadID: ThreadID): Promise<void>;
    /**
     * Lists all known DBs.
     * @remarks this API is blocked on the Hub. Use `listThreads` when importing Client
     * from `@textile/hub` as an alternative.
     */
    listDBs(): Promise<Record<string, pb.GetDBInfoReply.AsObject | undefined>>;
    /**
     * Lists the collections in a thread
     * @param thread the ID of the database
     */
    listCollections(thread: ThreadID): Promise<Array<pb.GetCollectionInfoReply.AsObject>>;
    /**
     * newCollection registers a new collection schema under the given name.
     * The schema must be a valid json-schema.org schema, and can be a JSON string or object.
     * @param threadID the ID of the database
     * @param name The human-readable name for the collection.
     * @param schema The actual json-schema.org compatible schema object.
     * @param indexes A set of index definitions for indexing instance fields.
     *
     * @example
     * Change a new astronauts collection
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * const astronauts = {
     *   title: "Astronauts",
     *   type: "object",
     *   required: ["_id"],
     *   properties: {
     *     _id: {
     *       type: "string",
     *       description: "The instance's id.",
     *     },
     *     name: {
     *       type: "string",
     *       description: "The astronauts name.",
     *     },
     *     missions: {
     *       description: "The number of missions.",
     *       type: "integer",
     *       minimum: 0,
     *     },
     *   },
     * }
     *
     * async function newCollection (client: Client, threadID: ThreadID) {
     *   return await client.updateCollection(threadID, 'astronauts', astronauts)
     * }
     * ```
     */
    newCollection(threadID: ThreadID, name: string, schema: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    /**
     * newCollectionFromObject creates and registers a new collection under the given name.
     * The input object must be serializable to JSON, and contain only json-schema.org types.
     * @param threadID the ID of the database
     * @param name The human-readable name for the collection.
     * @param obj The actual object to attempt to extract a schema from.
     * @param indexes A set of index definitions for indexing instance fields.
     *
     * @example
     * Change a new astronauts collection based of Buzz
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * async function newCollection (client: Client, threadID: ThreadID) {
     *   const buzz = {
     *     name: 'Buzz',
     *     missions: 2,
     *     _id: '',
     *   }
     *   return await client.newCollectionFromObject(threadID, 'astronauts', buzz)
     * }
     * ```
     */
    newCollectionFromObject(threadID: ThreadID, name: string, obj: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    /**
     * updateCollection updates an existing collection.
     * Currently, updates can include name and schema.
     * @todo Allow update of indexing information.
     * @param threadID the ID of the database
     * @param name the new name of the collection
     * @param schema the new schema of the collection
     *
     * @example
     * Change the name of our astronauts collection
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * const astronauts = {
     *   title: "Astronauts",
     *   type: "object",
     *   required: ["_id"],
     *   properties: {
     *     _id: {
     *       type: "string",
     *       description: "The instance's id.",
     *     },
     *     name: {
     *       type: "string",
     *       description: "The astronauts name.",
     *     },
     *     missions: {
     *       description: "The number of missions.",
     *       type: "integer",
     *       minimum: 0,
     *     },
     *   },
     * }
     *
     * async function changeName (client: Client, threadID: ThreadID) {
     *   return await client.updateCollection(threadID, 'toy-story-characters', astronauts)
     * }
     * ```
     */
    updateCollection(threadID: ThreadID, name: string, schema: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    /**
     * Deletes an existing collection.
     * @param threadID the ID of the database.
     * @param name The human-readable name for the collection.
     * @param schema The actual json-schema.org compatible schema object.
     * @example
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * async function deleteAstronauts (client: Client, thread: ThreadID) {
     *   await client.deleteCollection(thread, 'astronauts')
     *   return
     * }
     * ```
     */
    deleteCollection(threadID: ThreadID, name: string): Promise<void>;
    /**
     * Returns an existing indexes for a collection.
     * @param threadID the ID of the database.
     * @param name The human-readable name for the collection.
     *
     * @example
     * Return a set of indexes for our astronauts collection
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * async function getIndexes (client: Client, threadID: ThreadID) {
     *   return await client.getCollectionIndexes(threadID, 'astronauts')
     * }
     * ```
     */
    getCollectionIndexes(threadID: ThreadID, name: string): Promise<pb.Index.AsObject[]>;
    getCollectionInfo(threadID: ThreadID, name: string): Promise<CollectionInfo>;
    /**
     * newDBFromAddr initializes the client with the given store, connecting to the given
     * thread address (database). It should be called before any operation on the store, and is an
     * alternative to start, which creates a local store. newDBFromAddr should also include the
     * read/follow key, which should be a Buffer, Uint8Array or base32-encoded string.
     * @remarks
     * See getDBInfo for a possible source of the address and keys. See ThreadKey for
     * information about thread keys.
     * @param address The address for the thread with which to connect.
     * Should be of the form /ip4/<url/ip-address>/tcp/<port>/p2p/<peer-id>/thread/<thread-id>
     * @param key The set of keys to use to connect to the database
     * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.
     */
    newDBFromAddr(address: string, key: string | Uint8Array, collections?: Array<{
        name: string;
        schema: any;
    }>): Promise<ThreadID>;
    /**
     * Connect client to an existing database using information in the DBInfo object
     * This should be called before any operation on the store, and is an alternative
     * to open, which re-opens a database already opened by the user.
     * @remarks This is a helper method around newDBFromAddr, which takes the 'raw' output
     * from getDBInfo. See getDBInfo for a possible source of the address and keys.
     * @param info The output from a call to getDBInfo on a separate peer.
     * @param includeLocal Whether to try dialing addresses that appear to be on the local host.
     * Defaults to false, preferring to add from public ip addresses.
     * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.
     *
     * @example
     * Get DB info and use DB info to join an existing remote thread (e.g. invited)
     * ```typescript
     * import {Client, DBInfo, ThreadID} from '@textile/threads'
     *
     * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {
     *   return await client.getDBInfo(threadID)
     * }
     *
     * async function joinFromInfo (client: Client, info: DBInfo) {
     *   return await client.joinFromInfo(info)
     * }
     * ```
     */
    joinFromInfo(info: DBInfo, includeLocal?: boolean, collections?: Array<{
        name: string;
        schema: any;
    }>): Promise<ThreadID>;
    /**
     * Returns a DBInfo objection containing metadata required to invite other peers to join a given thread.
     * @param threadID the ID of the database
     * @returns An object with an encoded thread key, and a list of multiaddrs.
     *
     * @example
     * Get DB info and use DB info to join an existing remote thread (e.g. invited)
     * ```typescript
     * import {Client, DBInfo, ThreadID} from '@textile/threads'
     *
     * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {
     *   return await client.getDBInfo(threadID)
     * }
     *
     * async function joinFromInfo (client: Client, info: DBInfo) {
     *   return await client.joinFromInfo(info)
     * }
     * ```
     */
    getDBInfo(threadID: ThreadID): Promise<DBInfo>;
    /**
     * Creates a new model instance in the given store.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param values An array of model instances as JSON/JS objects.
     *
     * @example
     * Create a new entry in our collection
     * ```typescript
     * import {Client, ThreadID, Where} from '@textile/threads'
     *
     * interface Astronaut {
     *   name: string
     *   missions: number
     *   _id: string
     * }
     *
     * async function createBuzz (client: Client, threadID: ThreadID) {
     *   const buzz: Astronaut = {
     *     name: 'Buzz',
     *     missions: 2,
     *     _id: '',
     *   }
     *
     *   await client.create(threadID, 'astronauts', [buzz])
     * }
     * ```
     */
    create(threadID: ThreadID, collectionName: string, values: any[]): Promise<string[]>;
    /**
     * Saves changes to an existing model instance in the given store.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param values An array of model instances as JSON/JS objects.
     * Each model instance must have a valid existing `_id` property.
     *
     * @example
     * Update an existing instance
     * ```typescript
     * import {Client, ThreadID, Where} from '@textile/threads'
     *
     * interface Astronaut {
     *   name: string
     *   missions: number
     *   _id: string
     * }
     *
     * async function updateBuzz (client: Client, threadID: ThreadID) {
     *   const query = new Where('name').eq('Buzz')
     *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)
     *
     *   if (result.instancesList.length < 1) return
     *
     *   const buzz = result.instancesList[0]
     *   buzz.missions += 1
     *
     *   return await client.save(threadID, 'astronauts', [buzz])
     * }
     * ```
     */
    save(threadID: ThreadID, collectionName: string, values: any[]): Promise<void>;
    /**
     * Deletes an existing model instance from the given store.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param IDs An array of instance ids to delete.
     *
     * @example
     * Delete any instances that return from a query
     * ```typescript
     * import {Client, ThreadID, Where} from '@textile/threads'
     *
     * interface Astronaut {
     *   name: string
     *   missions: number
     *   _id: string
     * }
     *
     * async function deleteBuzz (client: Client, threadID: ThreadID) {
     *   const query = new Where('name').eq('Buzz')
     *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)
     *
     *   if (result.instancesList.length < 1) return
     *
     *   const ids = await result.instancesList.map((instance) => instance._id)
     *   await client.delete(threadID, 'astronauts', ids)
     * }
     * ```
     */
    delete(threadID: ThreadID, collectionName: string, IDs: string[]): Promise<void>;
    /**
     * Check if a given instance exists in the collection.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param IDs An array of instance ids to check for.
     *
     * @example
     * Check if an instance exists
     * ```typescript
     * import {Client, ThreadID, Where} from '@textile/threads'
     *
     * async function instanceExists (client: Client, threadID: ThreadID, id: string) {
     *   return await client.has(threadID, 'astronauts', [id])
     * }
     * ```
     */
    has(threadID: ThreadID, collectionName: string, IDs: string[]): Promise<boolean>;
    /**
     * Queries a collection for entities matching the given query parameters.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param query The object that describes the query. User Query class or primitive QueryJSON type.
     *
     * @example
     * Query with return type
     * ```typescript
     * import {Client, ThreadID, Where} from '@textile/threads'
     *
     * interface Astronaut {
     *   name: string
     *   missions: number
     *   _id: string
     * }
     *
     * async function getAstronautByName (client: Client, threadID: ThreadID, name: string) {
     *   const query = new Where('name').eq(name)
     *   const astronaut = await client.find<Astronaut>(threadID, 'astronauts', query)
     *   return astronaut
     * }
     * ```
     */
    find<T = any>(threadID: ThreadID, collectionName: string, query: QueryJSON): Promise<InstanceList<T>>;
    /**
     * Queries the collection by a known instance ID.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param ID The id of the instance to search for.
     *
     * @example
     * Find and cast a known model by instance ID.
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * interface Astronaut {
     *   name: string
     *   missions: number
     *   _id: string
     * }
     *
     * async function getAstronaut (client: Client, threadID: ThreadID, id: string) {
     *   const astronaut = await client.findByID<Astronaut>(threadID, 'astronauts', id)
     *   return astronaut
     * }
     * ```
     *
     * @example
     * Simple find and return any instance
     * ```typescript
     * import {Client, ThreadID} from '@textile/threads'
     *
     * async function getInstance (client: Client, threadID: ThreadID, id: string) {
     *   return await client.findByID(threadID, 'astronauts', id)
     * }
     * ```
     */
    findByID<T = any>(threadID: ThreadID, collectionName: string, ID: string): Promise<Instance<T>>;
    /**
     * Verify checks existing instance changes.
     * Each model instance must have a valid existing `_id` property.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param values An array of model instances as JSON/JS objects.
     *
     * @example
     * Update an existing instance
     * ```typescript
     * import {Client, ThreadID, Where} from '@textile/threads'
     *
     * interface Astronaut {
     *   name: string
     *   missions: number
     *   _id: string
     * }
     *
     * async function verifyBuzz (client: Client, threadID: ThreadID) {
     *   const query = new Where('name').eq('Buzz')
     *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)
     *
     *   if (result.instancesList.length < 1) return
     *
     *   const buzz = result.instancesList[0]
     *   buzz.missions += 1
     *
     *   // Is this going to be a valid update?
     *   return await client.verify(threadID, 'astronauts', [buzz])
     * }
     * ```
     */
    verify(threadID: ThreadID, collectionName: string, values: any[]): Promise<Error | undefined>;
    /**
     * readTransaction creates a new read-only transaction object. See ReadTransaction for details.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     */
    readTransaction(threadID: ThreadID, collectionName: string): ReadTransaction;
    /**
     * writeTransaction creates a new writeable transaction object. See WriteTransaction for details.
     * @param threadID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     */
    writeTransaction(threadID: ThreadID, collectionName: string): WriteTransaction;
    /**
     * listen opens a long-lived connection with a remote node, running the given callback on each new update to the given instance.
     * The return value is a `close` function, which cleanly closes the connection with the remote node.
     * @param threadID the ID of the database
     * @param filters contains an array of Filters
     * @param callback The callback to call on each update to the given instance.
     *
     * @example
     * ```typescript
     * import {Client, ThreadID, Update} from '@textile/threads'
     *
     * interface Astronaut {
     *   name: string
     *   missions: number
     *   _id: string
     * }
     * function setupListener (client: Client, threadID: ThreadID) {
     *   const callback = (update?: Update<Astronaut>) => {
     *     // Not safe if more than the Astronauts collection existed in the same DB
     *     if (!update || !update.instance) return
     *     console.log('New update:', update.instance.name, update.instance.missions)
     *   }
     *   const closer = client.listen(threadID, [], callback)
     *   return closer
     * }
     * ```
     *
     * @example
     * Listen to only CREATE events on a specific Collection.
     * ```typescript
     * import {Client, ThreadID, Update} from '@textile/threads'
     *
     * interface Astronaut {
     *   name: string
     *   missions: number
     *   _id: string
     * }
     * function setupListener (client: Client, threadID: ThreadID) {
     *   const callback = (update?: Update<Astronaut>) => {
     *     if (!update || !update.instance) return
     *     console.log('New update:', update.instance.name, update.instance.missions)
     *   }
     *   const filters = [
     *     {collectionName: 'Astronauts'},
     *     {actionTypes: ['CREATE']}
     *   ]
     *   const closer = client.listen(threadID, filters, callback)
     *   return closer
     * }
     * ```
     */
    listen<T = any>(threadID: ThreadID, filters: Filter[], callback: (reply?: Update<T>, err?: Error) => void): grpc.Request;
    private unary;
}
export default Client;
