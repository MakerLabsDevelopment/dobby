{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module @textile/threads-client\n */\nimport { grpc } from \"@improbable-eng/grpc-web\"\nimport { Context, ContextInterface, defaultHost } from \"@textile/context\"\nimport { WebsocketTransport } from \"@textile/grpc-transport\"\nimport { Multiaddr } from \"@textile/multiaddr\"\nimport { KeyInfo, UserAuth } from \"@textile/security\"\nimport * as pb from \"@textile/threads-client-grpc/threads_pb\"\nimport {\n  API,\n  APIGetToken,\n  APIListen,\n} from \"@textile/threads-client-grpc/threads_pb_service\"\nimport {\n  Identity,\n  Libp2pCryptoIdentity,\n  ThreadKey,\n} from \"@textile/threads-core\"\nimport { ThreadID } from \"@textile/threads-id\"\nimport toJsonSchema from \"to-json-schema\"\nimport {\n  CriterionJSON,\n  Filter,\n  Instance,\n  InstanceList,\n  Query,\n  QueryJSON,\n  ReadTransaction,\n  SortJSON,\n  ValueJSON,\n  Where,\n  WriteTransaction,\n} from \"./models\"\n\nexport {\n  Filter,\n  Query,\n  Where,\n  WriteTransaction,\n  ReadTransaction,\n  Instance,\n  InstanceList,\n  QueryJSON,\n  ValueJSON,\n  CriterionJSON,\n  SortJSON,\n}\n\nexport interface CollectionInfo {\n  name: string\n  schema: any\n  indexesList: Array<pb.Index.AsObject>\n}\n\nexport interface CollectionConfig {\n  name: string\n  schema: any\n  indexes: pb.Index.AsObject\n}\n\nconst encoder = new TextEncoder()\n\nexport function maybeLocalAddr(ip: string): boolean | RegExpMatchArray {\n  return (\n    [\"localhost\", \"\", \"::1\"].includes(ip) ||\n    ip.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/) ||\n    ip.startsWith(\"192.168.\") ||\n    ip.startsWith(\"10.0.\") ||\n    ip.endsWith(\".local\")\n  )\n}\n\nexport enum Action {\n  CREATE = 0,\n  SAVE,\n  DELETE,\n}\n\nexport interface Update<T = any> extends Instance<T> {\n  collectionName: string\n  instanceID: string\n  action: Action\n}\n\n/**\n * DBInfo contains joining/sharing information for a Thread/DB.\n */\nexport interface DBInfo {\n  /**\n   * The Thread Key, encoded as a base32 string.\n   * @see ThreadKey for details.\n   */\n  key: string\n  /**\n   * The Multiaddrs for a peer hosting the given Thread/DB.\n   */\n  addrs: string[]\n}\n\n/**\n * Client is a web-gRPC wrapper client for communicating with a webgRPC-enabled Threads server.\n * This client library can be used to interact with a local or remote Textile gRPC-service\n * It is a wrapper around Textile Thread's 'DB' API, which is defined here:\n * https://github.com/textileio/go-threads/blob/master/api/pb/api.proto.\n *\n * @example\n * ```typescript\n * import {Client, Identity, UserAuth} from '@textile/threads'\n *\n * async function setupDB(auth: UserAuth, identity: Identity) {\n *   // Initialize the client\n *   const client = Client.withUserAuth(auth)\n *\n *   // Connect the user to your API\n *   const userToken = await client.getToken(identity)\n *\n *   // Create a new DB\n *   const threadID = await client.newDB(undefined, 'nasa')\n *\n *   // Create a new Collection from an Object\n *   const buzz = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *   await client.newCollectionFromObject(threadID, 'astronauts', buzz)\n *\n *   // Store the buzz object in the new collection\n *   await client.create(threadID, 'astronauts', [buzz])\n *\n *   return threadID\n * }\n * ```\n */\nexport class Client {\n  public serviceHost: string\n  public rpcOptions: grpc.RpcOptions\n  /**\n   * Creates a new gRPC client instance for accessing the Textile Threads API.\n   * @param context The context to use for interacting with the APIs. Can be modified later.\n   * @param debug Should we run in debug mode. Defaults to false.\n   */\n  constructor(public context: ContextInterface = new Context(), debug = false) {\n    this.serviceHost = context.host\n    this.rpcOptions = {\n      transport: WebsocketTransport(),\n      debug,\n    }\n  }\n\n  /**\n   * Create a new gRPC client instance from a supplied user auth object.\n   * Assumes all default gRPC settlings. For customization options, use a context object directly.\n   * The callback method will automatically refresh expiring credentials.\n   * @param auth The user auth object or an async callback that returns a user auth object.\n   * @example\n   * ```typescript\n   * import {UserAuth, Client} from '@textile/threads'\n   *\n   * function create (auth: UserAuth) {\n   *   return Client.withUserAuth(auth)\n   * }\n   * ```\n   * @example\n   * ```typescript\n   * import {UserAuth, Client} from '@textile/threads'\n   *\n   * function setCallback (callback: () => Promise<UserAuth>) {\n   *   return Client.withUserAuth(callback)\n   * }\n   * ```\n   */\n  static withUserAuth(\n    auth: UserAuth | (() => Promise<UserAuth>),\n    host = defaultHost,\n    debug = false\n  ): Client {\n    const context =\n      typeof auth === \"object\"\n        ? Context.fromUserAuth(auth, host)\n        : Context.fromUserAuthCallback(auth, host)\n    return new Client(context, debug)\n  }\n\n  /**\n   * Create a new gRPC client instance from a supplied key and secret\n   * @param key The KeyInfo object containing {key: string, secret: string, type: 0}. 0 === User Group Key, 1 === Account Key\n   * @param host The remote gRPC host to connect with. Should be left as default.\n   * @param debug Whether to run in debug mode. Defaults to false.\n   * @example\n   * ```typescript\n   * import {KeyInfo, Client} from '@textile/threads'\n   *\n   * async function create (keyInfo: KeyInfo) {\n   *   return await Client.withKeyInfo(keyInfo)\n   * }\n   * ```\n   */\n  static async withKeyInfo(\n    key: KeyInfo,\n    host = defaultHost,\n    debug = false\n  ): Promise<Client> {\n    const context = new Context(host)\n    await context.withKeyInfo(key)\n    return new Client(context, debug)\n  }\n\n  /**\n   * Create a random user identity.\n   * @deprecated\n   * @remarks\n   * See `PrivateKey`\n   */\n  static async randomIdentity(): Promise<Libp2pCryptoIdentity> {\n    return Libp2pCryptoIdentity.fromRandom()\n  }\n\n  /**\n   * Obtain a token per user (identity) for interacting with the remote API.\n   * @param identity A user identity to use for creating records in the database. A random identity\n   * can be created with `Client.randomIdentity(), however, it is not easy/possible to migrate\n   * identities after the fact. Please store or otherwise persist any identity information if\n   * you wish to retrieve user data later, or use an external identity provider.\n   * @param ctx Context object containing web-gRPC headers and settings.\n   * @example\n   * ```typescript\n   * import {Client, Identity} from '@textile/threads'\n   *\n   * async function newToken (client: Client, user: Identity) {\n   *   // Token is added to the client connection at the same time\n   *   const token = await client.getToken(user)\n   *   return token\n   * }\n   * ```\n   */\n  async getToken(identity: Identity, ctx?: ContextInterface): Promise<string> {\n    return this.getTokenChallenge(\n      identity.public.toString(),\n      async (challenge: Uint8Array) => {\n        return identity.sign(challenge)\n      },\n      ctx\n    )\n  }\n\n  /**\n   * Obtain a token per user (identity) for interacting with the remote API.\n   * @param publicKey The public key of a user identity to use for creating records in the database.\n   * A random identity can be created with `Client.randomIdentity(), however, it is not\n   * easy/possible to migrate identities after the fact. Please store or otherwise persist any\n   * identity information if you wish to retrieve user data later, or use an external identity\n   * provider.\n   * @param callback A callback function that takes a `challenge` argument and returns a signed\n   * message using the input challenge and the private key associated with `publicKey`.\n   * @param ctx Context object containing web-gRPC headers and settings.\n   * @remarks `publicKey` must be the corresponding public key of the private key used in `callback`.\n   */\n  async getTokenChallenge(\n    publicKey: string,\n    callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>,\n    ctx?: ContextInterface\n  ): Promise<string> {\n    const client = grpc.client<\n      pb.GetTokenRequest,\n      pb.GetTokenReply,\n      APIGetToken\n    >(API.GetToken, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    })\n    return new Promise<string>((resolve, reject) => {\n      let token = \"\"\n      client.onMessage(async (message: pb.GetTokenReply) => {\n        if (message.hasChallenge()) {\n          const challenge = message.getChallenge_asU8()\n          const signature = await callback(challenge)\n          const req = new pb.GetTokenRequest()\n          req.setSignature(signature)\n          client.send(req)\n          client.finishSend()\n        } else if (message.hasToken()) {\n          token = message.getToken()\n        }\n      })\n      client.onEnd((\n        code: grpc.Code,\n        message: string /** trailers: grpc.Metadata */\n      ) => {\n        client.close()\n        if (code === grpc.Code.OK) {\n          this.context.withToken(token)\n          resolve(token)\n        } else {\n          reject(new Error(message))\n        }\n      })\n      const req = new pb.GetTokenRequest()\n      req.setKey(publicKey)\n      this.context.toMetadata(ctx).then((metadata) => {\n        client.start(metadata)\n        client.send(req)\n      })\n    })\n  }\n\n  /**\n   * newDB creates a new store on the remote node.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the database\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function createDB (client: Client) {\n   *   const threadID: ThreadID = await client.newDB()\n   *   return threadID\n   * }\n   * ```\n   */\n  public async newDB(threadID?: ThreadID, name?: string): Promise<ThreadID> {\n    const dbID = threadID ?? ThreadID.fromRandom()\n    const req = new pb.NewDBRequest()\n    req.setDbid(dbID.toBytes())\n    if (name !== undefined) {\n      this.context.withThreadName(name)\n      req.setName(name)\n    }\n    await this.unary(API.NewDB, req)\n    // Update our context with out new thread id\n    this.context.withThread(dbID.toString())\n    return dbID\n  }\n\n  /**\n   * open creates and enters a new store on the remote node.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the database\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function openDB (client: Client, threadID: ThreadID) {\n   *   await client.open(threadID)\n   * }\n   * ```\n   */\n  public async open(threadID: ThreadID, name?: string): Promise<void> {\n    const req = new pb.ListDBsRequest()\n    const res = (await this.unary(API.ListDBs, req)) as pb.ListDBsReply.AsObject\n    for (const db of res.dbsList) {\n      const id = ThreadID.fromBytes(Buffer.from(db.dbid as string, \"base64\"))\n      if (id === threadID) {\n        this.context.withThread(threadID.toString())\n        return\n      }\n    }\n    await this.newDB(threadID, name)\n    this.context.withThread(threadID.toString())\n  }\n\n  /**\n   * Deletes an entire DB.\n   * @param threadID the ID of the database.\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function deleteDB (client: Client, threadID: ThreadID) {\n   *   await client.deleteDB(threadID)\n   *   return\n   * }\n   * ```\n   */\n  public async deleteDB(threadID: ThreadID): Promise<void> {\n    const req = new pb.DeleteDBRequest()\n    req.setDbid(threadID.toBytes())\n    await this.unary(API.DeleteDB, req)\n    return\n  }\n\n  /**\n   * Lists all known DBs.\n   * @remarks this API is blocked on the Hub. Use `listThreads` when importing Client\n   * from `@textile/hub` as an alternative.\n   */\n  public async listDBs(): Promise<\n    Record<string, pb.GetDBInfoReply.AsObject | undefined>\n  > {\n    const req = new pb.ListDBsRequest()\n    const res = (await this.unary(API.ListDBs, req)) as pb.ListDBsReply.AsObject\n    const dbs: Record<string, pb.GetDBInfoReply.AsObject | undefined> = {}\n    for (const db of res.dbsList) {\n      const id = ThreadID.fromBytes(\n        Buffer.from(db.dbid as string, \"base64\")\n      ).toString()\n      dbs[id] = db.info\n    }\n    return dbs\n  }\n\n  /**\n   * Lists the collections in a thread\n   * @param thread the ID of the database\n   */\n  public async listCollections(\n    thread: ThreadID\n  ): Promise<Array<pb.GetCollectionInfoReply.AsObject>> {\n    const req = new pb.ListCollectionsRequest()\n    req.setDbid(thread.toBytes())\n    const resp = (await this.unary(\n      API.ListCollections,\n      req\n    )) as pb.ListCollectionsReply.AsObject\n    return resp.collectionsList\n  }\n\n  /**\n   * newCollection registers a new collection schema under the given name.\n   * The schema must be a valid json-schema.org schema, and can be a JSON string or object.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the collection.\n   * @param schema The actual json-schema.org compatible schema object.\n   * @param indexes A set of index definitions for indexing instance fields.\n   *\n   * @example\n   * Change a new astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const astronauts = {\n   *   title: \"Astronauts\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: {\n   *       type: \"string\",\n   *       description: \"The instance's id.\",\n   *     },\n   *     name: {\n   *       type: \"string\",\n   *       description: \"The astronauts name.\",\n   *     },\n   *     missions: {\n   *       description: \"The number of missions.\",\n   *       type: \"integer\",\n   *       minimum: 0,\n   *     },\n   *   },\n   * }\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, 'astronauts', astronauts)\n   * }\n   * ```\n   */\n  public async newCollection(\n    threadID: ThreadID,\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    schema: any,\n    indexes?: pb.Index.AsObject[]\n  ): Promise<void> {\n    const req = new pb.NewCollectionRequest()\n    const config = new pb.CollectionConfig()\n    config.setName(name)\n    config.setSchema(encoder.encode(JSON.stringify(schema)))\n    const idx: pb.Index[] = []\n    for (const item of indexes ?? []) {\n      const index = new pb.Index()\n      index.setPath(item.path)\n      index.setUnique(item.unique)\n      idx.push(index)\n    }\n    config.setIndexesList(idx)\n    req.setDbid(threadID.toBytes())\n    req.setConfig(config)\n    await this.unary(API.NewCollection, req)\n    return\n  }\n\n  /**\n   * newCollectionFromObject creates and registers a new collection under the given name.\n   * The input object must be serializable to JSON, and contain only json-schema.org types.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the collection.\n   * @param obj The actual object to attempt to extract a schema from.\n   * @param indexes A set of index definitions for indexing instance fields.\n   *\n   * @example\n   * Change a new astronauts collection based of Buzz\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   const buzz = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *   return await client.newCollectionFromObject(threadID, 'astronauts', buzz)\n   * }\n   * ```\n   */\n  public async newCollectionFromObject(\n    threadID: ThreadID,\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    obj: any,\n    indexes?: pb.Index.AsObject[]\n  ): Promise<void> {\n    const schema = toJsonSchema(obj)\n    return this.newCollection(threadID, name, schema, indexes)\n  }\n\n  /**\n   * updateCollection updates an existing collection.\n   * Currently, updates can include name and schema.\n   * @todo Allow update of indexing information.\n   * @param threadID the ID of the database\n   * @param name the new name of the collection\n   * @param schema the new schema of the collection\n   *\n   * @example\n   * Change the name of our astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const astronauts = {\n   *   title: \"Astronauts\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: {\n   *       type: \"string\",\n   *       description: \"The instance's id.\",\n   *     },\n   *     name: {\n   *       type: \"string\",\n   *       description: \"The astronauts name.\",\n   *     },\n   *     missions: {\n   *       description: \"The number of missions.\",\n   *       type: \"integer\",\n   *       minimum: 0,\n   *     },\n   *   },\n   * }\n   *\n   * async function changeName (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, 'toy-story-characters', astronauts)\n   * }\n   * ```\n   */\n  public async updateCollection(\n    threadID: ThreadID,\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    schema: any,\n    indexes?: pb.Index.AsObject[]\n  ): Promise<void> {\n    const req = new pb.UpdateCollectionRequest()\n    const conf = new pb.CollectionConfig()\n    conf.setName(name)\n    conf.setSchema(encoder.encode(JSON.stringify(schema)))\n    const idx: pb.Index[] = []\n    for (const item of indexes ?? []) {\n      const index = new pb.Index()\n      index.setPath(item.path)\n      index.setUnique(item.unique)\n      idx.push(index)\n    }\n    conf.setIndexesList(idx)\n    req.setDbid(threadID.toBytes())\n    req.setConfig(conf)\n    await this.unary(API.UpdateCollection, req)\n    return\n  }\n\n  /**\n   * Deletes an existing collection.\n   * @param threadID the ID of the database.\n   * @param name The human-readable name for the collection.\n   * @param schema The actual json-schema.org compatible schema object.\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function deleteAstronauts (client: Client, thread: ThreadID) {\n   *   await client.deleteCollection(thread, 'astronauts')\n   *   return\n   * }\n   * ```\n   */\n  public async deleteCollection(\n    threadID: ThreadID,\n    name: string\n  ): Promise<void> {\n    const req = new pb.DeleteCollectionRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    await this.unary(API.DeleteCollection, req)\n    return\n  }\n\n  /**\n   * Returns an existing indexes for a collection.\n   * @param threadID the ID of the database.\n   * @param name The human-readable name for the collection.\n   *\n   * @example\n   * Return a set of indexes for our astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function getIndexes (client: Client, threadID: ThreadID) {\n   *   return await client.getCollectionIndexes(threadID, 'astronauts')\n   * }\n   * ```\n   */\n  public async getCollectionIndexes(\n    threadID: ThreadID,\n    name: string\n  ): Promise<pb.Index.AsObject[]> {\n    const req = new pb.GetCollectionIndexesRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    const res = (await this.unary(\n      API.GetCollectionIndexes,\n      req\n    )) as pb.GetCollectionIndexesReply.AsObject\n    return res.indexesList\n  }\n\n  public async getCollectionInfo(\n    threadID: ThreadID,\n    name: string\n  ): Promise<CollectionInfo> {\n    const req = new pb.GetCollectionInfoRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    const res = (await this.unary(\n      API.GetCollectionInfo,\n      req\n    )) as pb.GetCollectionInfoReply.AsObject\n    res.schema = JSON.parse(\n      (Buffer.from(res.schema as string, \"base64\") as unknown) as string\n    )\n    return res\n  }\n\n  /**\n   * newDBFromAddr initializes the client with the given store, connecting to the given\n   * thread address (database). It should be called before any operation on the store, and is an\n   * alternative to start, which creates a local store. newDBFromAddr should also include the\n   * read/follow key, which should be a Buffer, Uint8Array or base32-encoded string.\n   * @remarks\n   * See getDBInfo for a possible source of the address and keys. See ThreadKey for\n   * information about thread keys.\n   * @param address The address for the thread with which to connect.\n   * Should be of the form /ip4/<url/ip-address>/tcp/<port>/p2p/<peer-id>/thread/<thread-id>\n   * @param key The set of keys to use to connect to the database\n   * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.\n   */\n  public async newDBFromAddr(\n    address: string,\n    key: string | Uint8Array,\n    collections?: Array<{ name: string; schema: any }>\n  ): Promise<ThreadID> {\n    const req = new pb.NewDBFromAddrRequest()\n    const addr = new Multiaddr(address).buffer\n    req.setAddr(addr)\n    // Should always be encoded string, but might already be bytes\n    req.setKey(\n      typeof key === \"string\" ? ThreadKey.fromString(key).toBytes() : key\n    )\n    if (collections !== undefined) {\n      req.setCollectionsList(\n        collections.map((c) => {\n          const config = new pb.CollectionConfig()\n          config.setName(c.name)\n          config.setSchema(encoder.encode(JSON.stringify(c.schema)))\n          return config\n        })\n      )\n    }\n    await this.unary(API.NewDBFromAddr, req)\n    // Hacky way to extract threadid from addr that succeeded\n    // @todo: Return this directly from the gRPC API?\n    const result = new Multiaddr(Buffer.from(req.getAddr_asU8()))\n      .stringTuples()\n      .filter(([key]) => key === 406)\n    return ThreadID.fromString(result[0][1])\n  }\n\n  /**\n   * Connect client to an existing database using information in the DBInfo object\n   * This should be called before any operation on the store, and is an alternative\n   * to open, which re-opens a database already opened by the user.\n   * @remarks This is a helper method around newDBFromAddr, which takes the 'raw' output\n   * from getDBInfo. See getDBInfo for a possible source of the address and keys.\n   * @param info The output from a call to getDBInfo on a separate peer.\n   * @param includeLocal Whether to try dialing addresses that appear to be on the local host.\n   * Defaults to false, preferring to add from public ip addresses.\n   * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.\n   *\n   * @example\n   * Get DB info and use DB info to join an existing remote thread (e.g. invited)\n   * ```typescript\n   * import {Client, DBInfo, ThreadID} from '@textile/threads'\n   *\n   * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {\n   *   return await client.getDBInfo(threadID)\n   * }\n   *\n   * async function joinFromInfo (client: Client, info: DBInfo) {\n   *   return await client.joinFromInfo(info)\n   * }\n   * ```\n   */\n  public async joinFromInfo(\n    info: DBInfo,\n    includeLocal = false,\n    collections?: Array<{ name: string; schema: any }>\n  ): Promise<ThreadID> {\n    const req = new pb.NewDBFromAddrRequest()\n    const filtered = info.addrs\n      .map((addr) => new Multiaddr(addr))\n      .filter((addr) => includeLocal || !maybeLocalAddr(addr.toOptions().host))\n    for (const addr of filtered) {\n      req.setAddr(addr.buffer)\n      // Should always be encoded string, but might already be bytes\n      req.setKey(\n        typeof info.key === \"string\"\n          ? ThreadKey.fromString(info.key).toBytes()\n          : info.key\n      )\n      if (collections !== undefined) {\n        req.setCollectionsList(\n          collections.map((c) => {\n            const config = new pb.CollectionConfig()\n            config.setName(c.name)\n            config.setSchema(encoder.encode(JSON.stringify(c.schema)))\n            return config\n          })\n        )\n      }\n      // Try to add addrs one at a time, if one succeeds, we are done.\n      await this.unary(API.NewDBFromAddr, req)\n      // Hacky way to extract threadid from addr that succeeded\n      // @todo: Return this directly from the gRPC API?\n      const result = new Multiaddr(Buffer.from(req.getAddr_asU8()))\n        .stringTuples()\n        .filter(([key]) => key === 406)\n      return ThreadID.fromString(result[0][1])\n    }\n    throw new Error(\"No viable addresses for dialing\")\n  }\n\n  /**\n   * Returns a DBInfo objection containing metadata required to invite other peers to join a given thread.\n   * @param threadID the ID of the database\n   * @returns An object with an encoded thread key, and a list of multiaddrs.\n   *\n   * @example\n   * Get DB info and use DB info to join an existing remote thread (e.g. invited)\n   * ```typescript\n   * import {Client, DBInfo, ThreadID} from '@textile/threads'\n   *\n   * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {\n   *   return await client.getDBInfo(threadID)\n   * }\n   *\n   * async function joinFromInfo (client: Client, info: DBInfo) {\n   *   return await client.joinFromInfo(info)\n   * }\n   * ```\n   */\n  public async getDBInfo(threadID: ThreadID): Promise<DBInfo> {\n    const req = new pb.GetDBInfoRequest()\n    req.setDbid(threadID.toBytes())\n    const res = (await this.unary(\n      API.GetDBInfo,\n      req\n    )) as pb.GetDBInfoReply.AsObject\n    const threadKey = Buffer.from(res.key as string, \"base64\")\n    const key = ThreadKey.fromBytes(threadKey)\n    const addrs: string[] = []\n    for (const addr of res.addrsList) {\n      const a =\n        typeof addr === \"string\"\n          ? Buffer.from(addr, \"base64\")\n          : Buffer.from(addr)\n      const address = new Multiaddr(a).toString()\n      addrs.push(address)\n    }\n    return { key: key.toString(), addrs }\n  }\n\n  /**\n   * Creates a new model instance in the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   *\n   * @example\n   * Create a new entry in our collection\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function createBuzz (client: Client, threadID: ThreadID) {\n   *   const buzz: Astronaut = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *\n   *   await client.create(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public async create(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[]\n  ): Promise<string[]> {\n    const req = new pb.CreateRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = []\n    values.forEach((v) => {\n      list.push(encoder.encode(JSON.stringify(v)))\n    })\n    req.setInstancesList(list)\n    const res = (await this.unary(API.Create, req)) as pb.CreateReply.AsObject\n    return res.instanceidsList\n  }\n\n  /**\n   * Saves changes to an existing model instance in the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   * Each model instance must have a valid existing `_id` property.\n   *\n   * @example\n   * Update an existing instance\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function updateBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const buzz = result.instancesList[0]\n   *   buzz.missions += 1\n   *\n   *   return await client.save(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public async save(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[]\n  ): Promise<void> {\n    const req = new pb.SaveRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = []\n    values.forEach((v) => {\n      if (!v.hasOwnProperty(\"_id\")) {\n        v[\"_id\"] = \"\" // The server will add an ID if empty.\n      }\n      list.push(encoder.encode(JSON.stringify(v)))\n    })\n    req.setInstancesList(list)\n    await this.unary(API.Save, req)\n    return\n  }\n\n  /**\n   * Deletes an existing model instance from the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param IDs An array of instance ids to delete.\n   *\n   * @example\n   * Delete any instances that return from a query\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function deleteBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const ids = await result.instancesList.map((instance) => instance._id)\n   *   await client.delete(threadID, 'astronauts', ids)\n   * }\n   * ```\n   */\n  public async delete(\n    threadID: ThreadID,\n    collectionName: string,\n    IDs: string[]\n  ): Promise<void> {\n    const req = new pb.DeleteRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceidsList(IDs)\n    await this.unary(API.Delete, req)\n    return\n  }\n\n  /**\n   * Check if a given instance exists in the collection.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param IDs An array of instance ids to check for.\n   *\n   * @example\n   * Check if an instance exists\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * async function instanceExists (client: Client, threadID: ThreadID, id: string) {\n   *   return await client.has(threadID, 'astronauts', [id])\n   * }\n   * ```\n   */\n  public async has(\n    threadID: ThreadID,\n    collectionName: string,\n    IDs: string[]\n  ): Promise<boolean> {\n    const req = new pb.HasRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceidsList(IDs)\n    const res = (await this.unary(API.Has, req)) as pb.HasReply.AsObject\n    return res.exists\n  }\n\n  /**\n   * Queries a collection for entities matching the given query parameters.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param query The object that describes the query. User Query class or primitive QueryJSON type.\n   *\n   * @example\n   * Query with return type\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function getAstronautByName (client: Client, threadID: ThreadID, name: string) {\n   *   const query = new Where('name').eq(name)\n   *   const astronaut = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *   return astronaut\n   * }\n   * ```\n   */\n  public async find<T = any>(\n    threadID: ThreadID,\n    collectionName: string,\n    query: QueryJSON\n  ): Promise<InstanceList<T>> {\n    const req = new pb.FindRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    // @todo: Find a more isomorphic way to do this base64 round-trip\n    req.setQueryjson(encoder.encode(JSON.stringify(query)))\n    const res = (await this.unary(API.Find, req)) as pb.FindReply.AsObject\n    const ret: InstanceList<T> = {\n      instancesList: res.instancesList.map((instance) =>\n        JSON.parse(Buffer.from(instance as string, \"base64\").toString())\n      ),\n    }\n    return ret\n  }\n\n  /**\n   * Queries the collection by a known instance ID.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param ID The id of the instance to search for.\n   *\n   * @example\n   * Find and cast a known model by instance ID.\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function getAstronaut (client: Client, threadID: ThreadID, id: string) {\n   *   const astronaut = await client.findByID<Astronaut>(threadID, 'astronauts', id)\n   *   return astronaut\n   * }\n   * ```\n   *\n   * @example\n   * Simple find and return any instance\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function getInstance (client: Client, threadID: ThreadID, id: string) {\n   *   return await client.findByID(threadID, 'astronauts', id)\n   * }\n   * ```\n   */\n  public async findByID<T = any>(\n    threadID: ThreadID,\n    collectionName: string,\n    ID: string\n  ): Promise<Instance<T>> {\n    const req = new pb.FindByIDRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceid(ID)\n    const res = (await this.unary(\n      API.FindByID,\n      req\n    )) as pb.FindByIDReply.AsObject\n    const ret: Instance<T> = {\n      instance: JSON.parse(\n        Buffer.from(res.instance as string, \"base64\").toString()\n      ),\n    }\n    return ret\n  }\n\n  /**\n   * Verify checks existing instance changes.\n   * Each model instance must have a valid existing `_id` property.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   *\n   * @example\n   * Update an existing instance\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function verifyBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.instancesList.length < 1) return\n   *\n   *   const buzz = result.instancesList[0]\n   *   buzz.missions += 1\n   *\n   *   // Is this going to be a valid update?\n   *   return await client.verify(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public async verify(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[]\n  ): Promise<Error | undefined> {\n    const req = new pb.VerifyRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = values.map((v) => encoder.encode(JSON.stringify(v)))\n    req.setInstancesList(list)\n    const { transactionerror } = (await this.unary(\n      API.Verify,\n      req\n    )) as pb.VerifyReply.AsObject\n    return transactionerror ? new Error(transactionerror) : undefined\n  }\n\n  /**\n   * readTransaction creates a new read-only transaction object. See ReadTransaction for details.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   */\n  public readTransaction(\n    threadID: ThreadID,\n    collectionName: string\n  ): ReadTransaction {\n    const client = grpc.client(API.ReadTransaction, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    }) as grpc.Client<pb.ReadTransactionRequest, pb.ReadTransactionReply>\n    return new ReadTransaction(this.context, client, threadID, collectionName)\n  }\n\n  /**\n   * writeTransaction creates a new writeable transaction object. See WriteTransaction for details.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   */\n  public writeTransaction(\n    threadID: ThreadID,\n    collectionName: string\n  ): WriteTransaction {\n    const client = grpc.client(API.WriteTransaction, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    }) as grpc.Client<pb.WriteTransactionRequest, pb.WriteTransactionReply>\n    return new WriteTransaction(this.context, client, threadID, collectionName)\n  }\n\n  /**\n   * listen opens a long-lived connection with a remote node, running the given callback on each new update to the given instance.\n   * The return value is a `close` function, which cleanly closes the connection with the remote node.\n   * @param threadID the ID of the database\n   * @param filters contains an array of Filters\n   * @param callback The callback to call on each update to the given instance.\n   *\n   * @example\n   * ```typescript\n   * import {Client, ThreadID, Update} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   * function setupListener (client: Client, threadID: ThreadID) {\n   *   const callback = (update?: Update<Astronaut>) => {\n   *     // Not safe if more than the Astronauts collection existed in the same DB\n   *     if (!update || !update.instance) return\n   *     console.log('New update:', update.instance.name, update.instance.missions)\n   *   }\n   *   const closer = client.listen(threadID, [], callback)\n   *   return closer\n   * }\n   * ```\n   *\n   * @example\n   * Listen to only CREATE events on a specific Collection.\n   * ```typescript\n   * import {Client, ThreadID, Update} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   * function setupListener (client: Client, threadID: ThreadID) {\n   *   const callback = (update?: Update<Astronaut>) => {\n   *     if (!update || !update.instance) return\n   *     console.log('New update:', update.instance.name, update.instance.missions)\n   *   }\n   *   const filters = [\n   *     {collectionName: 'Astronauts'},\n   *     {actionTypes: ['CREATE']}\n   *   ]\n   *   const closer = client.listen(threadID, filters, callback)\n   *   return closer\n   * }\n   * ```\n   */\n  public listen<T = any>(\n    threadID: ThreadID,\n    filters: Filter[],\n    callback: (reply?: Update<T>, err?: Error) => void\n  ): grpc.Request {\n    const req = new pb.ListenRequest()\n    req.setDbid(threadID.toBytes())\n    for (const filter of filters) {\n      const requestFilter = new pb.ListenRequest.Filter()\n      if (filter.instanceID) {\n        requestFilter.setInstanceid(filter.instanceID)\n      } else if (filter.collectionName) {\n        requestFilter.setCollectionname(filter.collectionName)\n      }\n      if (filter.actionTypes) {\n        for (const at of filter.actionTypes) {\n          switch (at) {\n            case \"ALL\": {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.ALL)\n              break\n            }\n            case \"CREATE\": {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.CREATE)\n              break\n            }\n            case \"SAVE\": {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.SAVE)\n              break\n            }\n            case \"DELETE\": {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.DELETE)\n              break\n            }\n          }\n        }\n      } else {\n        requestFilter.setAction(0)\n      }\n      req.addFilters(requestFilter)\n    }\n\n    const decoder = new TextDecoder()\n\n    const client = grpc.client<pb.ListenRequest, pb.ListenReply, APIListen>(\n      API.Listen,\n      {\n        host: this.serviceHost,\n        transport: this.rpcOptions.transport,\n        debug: this.rpcOptions.debug,\n      }\n    )\n    client.onMessage((message: pb.ListenReply) => {\n      // Pull it apart explicitly\n      const instanceString = decoder.decode(message.getInstance_asU8())\n      const actionInt = message.getAction()\n      const action = (Action[actionInt] as unknown) as Action\n      const collectionName = message.getCollectionname()\n      const instanceID = message.getInstanceid()\n\n      const ret: Update<T> = {\n        collectionName,\n        instanceID,\n        action,\n        instance: undefined,\n      }\n      if (instanceString !== \"\") {\n        ret.instance = JSON.parse(instanceString)\n      }\n      callback(ret)\n    })\n\n    client.onEnd((\n      status: grpc.Code,\n      message: string /** trailers: grpc.Metadata */\n    ) => {\n      if (status !== grpc.Code.OK) {\n        callback(undefined, new Error(message))\n      }\n      callback()\n    })\n\n    this.context.toMetadata().then((metadata) => {\n      client.start(metadata)\n      client.send(req)\n      client.finishSend()\n    })\n    return { close: () => client.close() }\n  }\n\n  private async unary<\n    TRequest extends grpc.ProtobufMessage,\n    TResponse extends grpc.ProtobufMessage,\n    M extends grpc.UnaryMethodDefinition<TRequest, TResponse>\n  >(methodDescriptor: M, req: TRequest) {\n    const metadata = await this.context.toMetadata()\n    return new Promise((resolve, reject) => {\n      grpc.unary(methodDescriptor, {\n        transport: this.rpcOptions.transport,\n        debug: this.rpcOptions.debug,\n        request: req,\n        host: this.serviceHost,\n        metadata,\n        onEnd: (res) => {\n          const { status, statusMessage, message } = res\n          if (status === grpc.Code.OK) {\n            if (message) {\n              resolve(message.toObject())\n            } else {\n              resolve()\n            }\n          } else {\n            reject(new Error(statusMessage))\n          }\n        },\n      })\n    })\n  }\n}\n\nexport default Client\n"]}